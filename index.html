<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sillywa.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人学习记录博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Sillywa&#39;s Blog">
<meta property="og:url" content="https://sillywa.com/index.html">
<meta property="og:site_name" content="Sillywa&#39;s Blog">
<meta property="og:description" content="个人学习记录博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sillywa">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sillywa.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sillywa's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sillywa's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/03/06/vi%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/06/vi%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">vi基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-06 14:40:39" itemprop="dateCreated datePublished" datetime="2019-03-06T14:40:39+08:00">2019-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:55:56" itemprop="dateModified" datetime="2020-09-23T16:55:56+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>vi 是 Linux 常用的编辑器，本文记录了 vi 的基本操作。</p>
<!--- more --->


<h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><ol>
<li><p>命令模式<br>用 vi 打开一个文件即进入命令模式</p>
</li>
<li><p>输入模式<br>a i o 进入输入模式</p>
</li>
</ol>
<ul>
<li>a 光标后输入</li>
<li>i 光标前输入</li>
<li>o 光标下一行输入</li>
<li>A 光标所在行的行尾输入</li>
<li>O 光标所在行的上一行新建一行</li>
<li>esc退回到命令模式</li>
</ul>
<ol start="3">
<li>末行模式</li>
</ol>
<ul>
<li>: 进入末行模式</li>
<li>esc返回命令模式</li>
</ul>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ol>
<li><p>行内跳转<br>home 或者 $ 跳转行首<br>end 或者 ^ 跳转行尾</p>
</li>
<li><p>行间跳转<br>末行模式输入 <code>set nu</code> 显示行数</p>
<ul>
<li><p>命令模式<br><code>#gg</code>     跳转到#行，#代表数字<br><code>G</code>       跳转到行尾<br><code>gg</code>      跳转到行首</p>
</li>
<li><p>末行模式<br><code>:#</code>      跳转到#行，#代表数字</p>
</li>
</ul>
</li>
</ol>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ul>
<li>命令模式<br><code>#yy</code>       从光标所在行开始，往下复制#行</li>
<li>末行模式<br><code>:#y</code>       复制第#行<br><code>:m,ny</code>     复制从第m行到第n行</li>
</ul>
<h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><ul>
<li><code>p</code> 光标后粘贴</li>
<li><code>P</code> 光标前粘贴</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li><p>命令模式<br><code>x或者del</code>     删除光标所在字符<br><code>#dd</code>         删除从光标所在行开始，往下数#行</p>
</li>
<li><p>末行模式<br><code>:#d </code>        删除第#行<br><code>:m,nd</code>       删除从第m行到第n行</p>
</li>
</ul>
<h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p>  删除 + 粘贴     </p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>命令模式<br>  <code>/word</code> 从上往下查找word，小写n，查找下一个匹配的<br>  <code>?word</code> 从下往上查找word，大写N，查找上一个匹配的</p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>末行模式<br>  <code>:s/old/new</code>   将光标所在行，满足的第一个old替换成new<br>  <code>:s#old#new</code>  </p>
<p>  <code>:s/old/new/g</code> 光标所在行的所有old替换成new<br>  <code>:s#old#new#g</code>  </p>
<p>  <code>:m,ns/old/new</code> 第m行到第n行，每行第一个满足的old替换成new</p>
<p>  <code>:%s/old/new/g</code>   全文替换<br>  <code>:%s#old#new#g</code></p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>末行模式<br>  <code>:r /root/test.txt</code> 在光标下一行写入文件/root/test.txt</p>
<h2 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h2><ul>
<li>末行模式<br>:wq<br>:x</li>
<li>命令模式<br>ZZ</li>
</ul>
<h2 id="其他退出"><a href="#其他退出" class="headerlink" title="其他退出"></a>其他退出</h2><ul>
<li>强制退出<br>:q!</li>
<li>强制保存退出<br>:wq!</li>
<li>正常退出<br>:q</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2018/12/06/%E5%AD%A6%E4%B9%A0Linux%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/06/%E5%AD%A6%E4%B9%A0Linux%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">学习Linux基本命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-06 13:34:03" itemprop="dateCreated datePublished" datetime="2018-12-06T13:34:03+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:52:28" itemprop="dateModified" datetime="2020-09-23T16:52:28+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍常用的 Linux 命令。</p>
<!--- more --->

<h1 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h1><ul>
<li><code>pwd</code> 打印当前工作目录</li>
<li><code>cd</code> 改变目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;bin  绝对路径从根目录出发，到达目标目录</span><br><span class="line">cd .&#x2F;usr 相对路径从工作目录出发，到达目标目录</span><br><span class="line">cd .. 到达父目录</span><br><span class="line">cd(cd ~) 到达家目录，如果未root用户，pwd会打印出 &#x2F;root，其上一层为 根目录&#x2F;</span><br><span class="line">cd &#x2F; (cd -) 回到根目录</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><code>ls</code> 列出目录内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls -l 使用长格式显示结果</span><br><span class="line">ls -t 按修改时间排序</span><br><span class="line">ls -r 以相反的顺序显示</span><br><span class="line">ls -S 按文件大小对结果进行排序</span><br><span class="line">ls -R [文件夹] 列出文件树</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
<li><code>file</code> 确定文件类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure></li>
<li><code>less</code> 查看文件内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure></li>
<li><code>touch</code> 新建文件</li>
</ul>
<h1 id="操作文件与目录"><a href="#操作文件与目录" class="headerlink" title="操作文件与目录"></a>操作文件与目录</h1><ul>
<li><code>mkdir</code> 创建目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir1              创建单个目录</span><br><span class="line">mkdir dir1 dir2 dir3    创建多个目录</span><br><span class="line">mkdir -p dir&#123;1..9&#125;      创建多个目录a1到a9</span><br><span class="line">mkdir -p a&#123;1..3&#125;&#x2F;b&#123;1..3&#125;创建多个目录a1到a3，并且在每个目录下创建b1到b3</span><br></pre></td></tr></table></figure></li>
<li><code>cp</code> 复制文件或目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2          将文件file1复制到file2中,file2内容将会被覆盖</span><br><span class="line">cp -r dir1 dir2         复制目录时一定要加 -r，如果dir2目录存在，则会复制到dir2目录下和mv是一样的道理</span><br><span class="line">cp file1 file2 dir1     将多个文件复制到一个目录下</span><br></pre></td></tr></table></figure>
<code>cp</code>命令选项</li>
</ul>
<p><code>cp</code>在覆盖已存在的文件时默认情况下是 <code>cp -i</code>，即需要用户确认，我们可以这样 <code>\cp</code> 即可无需确认</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-r          递归复制目录及其内容。复制目录时需要这个选项</span><br><span class="line">-u          将文件从一个目录复制到另一个目录时，只会复制目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          复制文件时显示信息性消息</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mv</code> 重命名或移动文件和目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv item1 item2              将文件或目录item1移动或重命名为item2</span><br><span class="line">mv item1 item2 item3 dir1   将多个条目移动到dir1目录下</span><br></pre></td></tr></table></figure>
<code>mv</code>命令选项与<code>cp</code>大致相同，<code>mv</code>没有<code>-r</code>选项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-u          将文件从一个目录移动到另一个目录时，只会移动目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          移动时显示信息性消息</span><br></pre></td></tr></table></figure></li>
<li><code>rm</code> 删除文件或目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r item1 item2 item3         删除item1,item2,item3,删除目录时需要-r</span><br><span class="line">rm *.html                       删除以.html结尾的文件</span><br></pre></td></tr></table></figure>
<code>rm</code>命令选项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-i          删除前提示用户确认</span><br><span class="line">-r          递归删除目录及其内容。删除目录时需要这个选项</span><br><span class="line">-f          忽略不存在的文件，并无需提示确认</span><br><span class="line">-v          删除时显示信息性消息</span><br></pre></td></tr></table></figure></li>
<li><code>ln</code> 创建硬链接和符号链接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln file hard-link-name      创建file文件的硬链接</span><br><span class="line">ln -s file sym-link-name    创建file文件的符号链接，符号链接指向源文件，与源文件内容保持一致</span><br></pre></td></tr></table></figure>
<code>file</code>为相对于<code>sym-link-name</code>的文件，即为相对路径，当然也可以是绝对路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ..&#x2F;file sym-link-name     file在当前目录的父目录中，即file相对于sym-link-name的位置</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;I am fine&quot;                        打印 I am fine</span><br><span class="line">echo &quot;I am fine&quot; &gt; &#x2F;root&#x2F;test.txt       将 I am fine写入&#x2F;root&#x2F;test.txt中</span><br><span class="line">echo &quot;I am fine&quot; &gt;&gt; &#x2F;root&#x2F;test.txt      将 I am fine追加到&#x2F;root&#x2F;test.txt末尾</span><br><span class="line">grep &quot;关键字&quot; test.txt                  在test.txt中查找含有关键字的行并打印</span><br><span class="line">grep -v &quot;关键字&quot; test.txt               在test.txt中查找不含有关键字的行并打印</span><br><span class="line">grep ^&quot;关键字&quot; test.txt                 在test.txt中查找以关键字开头的行并打印</span><br><span class="line">grep $&quot;关键字&quot; test.txt                 在test.txt中查找以关键字结尾的行并打印</span><br></pre></td></tr></table></figure>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep &quot;关键字&quot; &gt; &#x2F;root&#x2F;test.txt  列出当前目录文件信息并交给grep过滤，最后写入&#x2F;root&#x2F;test.txt</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%9B%BE/" class="post-title-link" itemprop="url">数据结构——图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-24 12:43:00" itemprop="dateCreated datePublished" datetime="2019-12-24T12:43:00+08:00">2019-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:50:32" itemprop="dateModified" datetime="2020-09-23T16:50:32+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>在树型结构中，结点间具有分支层次关系，每一层上的结点只能和上一层中的至多一个结点相关，但可能和下一层的多个节点相关。树的关系也叫一对多的关系，而在图状结构中，任意两个结点之间都可能相关，即结点的邻接关系可以是任意的。图的结构是<strong>任意两个数据对象之间都可能存在某种特定关系</strong>的数据结构，是一种多对多的关系。</p>
<!--- more --->

<h3 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h3><p>图（Graph）是由两个集合构成，一个是非空但有限的顶点集合 V，另一个是描述顶点之间关系——边的集合 E（可以是空集）。因此图可以表示为 G=(V,E)。每条边是一顶点对 (v,w) 且 v,w∈V。通常用 |V| 表示定点数量 |E| 表示边的数量。</p>
<p>关于图的定义，与以前的线性表和树比较，还有几点需要注意：</p>
<ul>
<li><p>在线性表中，一般叫数据对象为元素；在树中，将数据对象成为结点；而在图中，我们把数据对象称为顶点（Vertex）。</p>
</li>
<li><p>线性表中可以没有数据对象，此时叫空表；没有数据对象的树称为空树；而在图中，我们至少要求有一个顶点，但边集可以是空。</p>
</li>
</ul>
<h3 id="图的抽象数据类型"><a href="#图的抽象数据类型" class="headerlink" title="图的抽象数据类型"></a>图的抽象数据类型</h3><p>类型名称：图（Graph）。</p>
<p>数据对象集：一个非空顶点集合 Vertex 和一个边集合 Edge，每条边用对应的一对顶点表示。</p>
<p>操作集：对于任意的图 G∈Graph，顶点 V∈Vertex，边 E∈Edge，以及任一访问顶点的函数 Visit()，我们主要关心下列操作：</p>
<p>1.<code>Graph CreateGraph(int VertexNum)</code>：构造一个有 VertexNum 个顶点但没有边的图；</p>
<p>2.<code>void InsertEdge(Graph G, Edge E)</code>：在 G 中增加新边 E；</p>
<p>3.<code>void DeleteEdge(Graph G, Edge E)</code>：从 G 中删除边 E；</p>
<p>4.<code>bool IsEmpty(Graph G)</code>：判断图是否为空；</p>
<p>5.<code>void DFS(Graph G, Vertex V, (*Visit)(Vertex))</code>：在图 G 中，从顶点 V 出发进行深度优先遍历；</p>
<p>6.<code>void BFS(Graph G, Vertex V, (*Visit)(Vertex))</code>：在图 G 中，从顶点 V 出发进行广度优先遍历。</p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>所谓邻接矩阵的存储结构，就是用矩阵表示图中各顶点之间的邻接关系和权值。以下是一个无向图的临界矩阵表示：</p>


<p>从图的邻接矩阵存储方法容易看出这种表示具有以下特点:</p>
<p>1.无向图的邻接矩阵一定是个对称矩阵。因此在具体存放邻接矩阵时只需要存放上三角或者下三角的元素即可。所需要存储的元素个数是：|V|*(|V|-1)/2。</p>
<p>2.对于无向图，邻接矩阵的第 i 行（或第 i 列）非 0 元素的个数正好是第 i 个顶点的度（Degree）。</p>
<p>3.对于有向图，邻接矩阵第 i 行（或第 i 列）非 0 元素的个数正好是第 i 个顶点的出度（或入度）。</p>
<p>4.用临界矩阵方法存储图，很容易确定图中任意两点之间是否有边相连，只需要考察邻接矩阵对应的元素即可；确定一个顶点的所有邻接点，也只需要邻接矩阵对应的一行（或一列）；但是要确定图中有多少边，则必须按行（或按列）对每个元素进行检测，所花费的时间代价是 O(|V|^2)。这是用邻接矩阵来存储图的局限性。</p>
<p>以下是邻接矩阵的 C 语言描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100    <span class="comment">/* 最大顶点数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535      <span class="comment">/* 初始值设为双字节无符号整数的最大值 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;         <span class="comment">/* 用顶点下标表示顶点，为整形 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> WeightType;     <span class="comment">/* 边的权值 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;            <span class="comment">/* 顶点存储的数据类型设为字符型 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图的定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;     <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;     <span class="comment">/* 边数 */</span></span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum];   <span class="comment">/* 邻接矩阵 */</span></span><br><span class="line">    DataType Data[MaxVertexNum];                <span class="comment">/* 每个顶点的数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边的定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    Vertex V1, V2;      <span class="comment">/* 有向边&lt;V1,V2&gt; */</span></span><br><span class="line">    WeightType Weight;  <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br></pre></td></tr></table></figure>

<p>有了图的结构和类型定义之后，先创建一个包含全部顶点但是没有边的图，再逐条插入边，从而创建一个无向网图的数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span> </span>&#123;</span><br><span class="line">    MGraph Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化邻接矩阵 */</span></span><br><span class="line">    <span class="comment">/* 注意顶点默认从 0 编号 到 Graph-&gt;Nv - 1 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; Graph-&gt;Nv;j++) &#123;</span><br><span class="line">            Graph-&gt;G[i][j] = INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdeg</span><span class="params">(MGraph Graph, Edge E)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入边&lt;V1,V2&gt; */</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是无向图,还需要插入边&lt;V2,V1&gt; */</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    <span class="keyword">int</span> VertexNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入顶点数 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;VertexNum);</span><br><span class="line"></span><br><span class="line">    Graph = CreateGraph(VertexNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入边数 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Graph-&gt;Ne);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Edge E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode)); <span class="comment">/* 建立边结点 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*依次读入每一条边的数据 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph-&gt;Ne;i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将该边插入图中 */</span></span><br><span class="line">            InsertEdeg(Graph, E);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果顶点有数据，读入顶点数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;Graph-&gt;Data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>邻接矩阵是一种表示各类图的简洁的数据结构。但是我们发现，不论图中边的数量或多或少，我们都花费了 O(|V|^2) 的存储空间，这对于稠密图来说是一种高效的存储方法。但是如果面对的是一个稀疏图，则邻接矩阵中的大多数项为 0 或 无穷，形成了所谓的稀疏矩阵，就会浪费很多空间。因此对于稀疏图，我们考虑另一种存储方法。</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表是一种图的顺序存储与链式存储相结合的存储方法。</p>


<p>图的邻接表存储具有以下特点：</p>
<p>1.方便查找任一顶点的所有邻接点。</p>
<p>2.节约稀疏图的空间。需要 N 个头指针 + 2E 个结点（每个结点至少两个域）。</p>
<p>3.对于无向图来说方便计算任一顶点的度，对于有向图来说只能计算出度。</p>
<p>4.不方便检查任一对顶点间是否存在边。</p>
<p>以下是图的邻接表存储的代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100    <span class="comment">/* 最大顶点数设为100 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;         <span class="comment">/* 用顶点下标表示顶点，为整形 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> WeightType;     <span class="comment">/* 边的权值设为整形 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;      <span class="comment">/* 顶点存储的数据类型设为字符型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边的定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    Vertex V1,V2;       <span class="comment">/* 有向边&lt;V1,V2&gt; */</span></span><br><span class="line">    WeightType Weight;  <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接点的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span>* <span class="title">PtrToAdjVNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span> &#123;</span></span><br><span class="line">    Vertex AdjV;            <span class="comment">/* 邻接点的下标 */</span></span><br><span class="line">    WeightType Weight;      <span class="comment">/* 邻接点边的权重 */</span></span><br><span class="line">    PtrToAdjVNode Next;     <span class="comment">/* 下一个邻接点 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顶点表头节点的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span> &#123;</span></span><br><span class="line">    PtrToAdjVNode FirstEdge;    <span class="comment">/* 边表头节点指针 */</span></span><br><span class="line">    DataType Data;              <span class="comment">/* 头结点的值 */</span></span><br><span class="line">    <span class="comment">/* 很多情况下顶点无数据，此时Data不用出现 */</span></span><br><span class="line">&#125; AdjVList[MaxVertexNum];       <span class="comment">/* AdjVList是邻接表的类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;         <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;         <span class="comment">/* 边数 */</span></span><br><span class="line">    AdjVList G;     <span class="comment">/* 邻接表 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode LGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化一个有 VertexNum个顶点，但是没有边的图 */</span></span><br><span class="line"><span class="function">LGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将边&lt;V1,V2&gt;插入图中 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(LGraph Graph, Edge E)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据输入构建图 */</span></span><br><span class="line"><span class="function">LGraph <span class="title">BuildGraph</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span> </span>&#123;</span><br><span class="line">    LGraph Graph = (LGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化邻接表的表头指针 */</span></span><br><span class="line">    <span class="comment">/* 注意这里默认定点编号从 0 开始到 (Graph-&gt;Nv - 1) 结束 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        Graph-&gt;G[i].FirstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(LGraph Graph, Edge E)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 插入有向边 &lt;V1,V2&gt; */</span></span><br><span class="line">    PtrToAdjVNode NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建一个邻接点，并将该邻接点插入链表头部 */</span></span><br><span class="line">    NewNode = (PtrToAdjVNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">    NewNode-&gt;AdjV = E-&gt;V2;</span><br><span class="line">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是无向图还要插入&lt;V2,V1&gt; */</span></span><br><span class="line">    NewNode = (PtrToAdjVNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">    NewNode-&gt;AdjV = E-&gt;V1;</span><br><span class="line">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LGraph <span class="title">BuildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    <span class="keyword">int</span> VertexNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入顶点数 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;VertexNum);</span><br><span class="line">    Graph = CreateGraph(VertexNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入边数 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Graph-&gt;Ne);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 构建边并读入 */</span></span><br><span class="line">        Edge E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果顶点有数据，读入数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;(Graph-&gt;G[i].Data));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>图的遍历就是从图中任一顶点出发，对图中所有顶点访问一次且仅访问一次的次序序列。</p>
<h3 id="深度优先搜索（Depth-First-Search-DFS）"><a href="#深度优先搜索（Depth-First-Search-DFS）" class="headerlink" title="深度优先搜索（Depth First Search,DFS）"></a>深度优先搜索（Depth First Search,DFS）</h3><p>深度优先搜索类似于树的先序遍历，是树的先序遍历的推广。假设初始状态所有顶点都没被访问过，则深度优先搜索从图中的任一顶点出发，设为v0 ，访问此顶点，然后从v0的邻接点中的一个出发递归地进行同样的深度优先搜索，直至图中所有节点都被访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵存储的图 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Vertex V)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点 %d&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Visited[]已经为全局变量，且初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(LGraph Graph, Vertex V, <span class="keyword">void</span> (*Visit)(Vertex))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Visit(V);           <span class="comment">/* 访问第V个顶点 */</span></span><br><span class="line">    Visited[V] = <span class="literal">true</span>;  <span class="comment">/* 将V标记为已访问 */</span></span><br><span class="line"></span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    <span class="keyword">for</span>(W = Graph-&gt;G[V].FirstEdge;W;W = W-&gt;Next) &#123;  <span class="comment">/* 对V的每个邻接点W */</span></span><br><span class="line">        <span class="keyword">if</span>(! Visited[W-&gt;AdjV]) &#123;                    <span class="comment">/* 如果W未被访问 */</span></span><br><span class="line">            DFS(Graph, W-&gt;AdjV, Visit);             <span class="comment">/* 则递归访问之 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先搜索（Breadth-First-Search-BFS）"><a href="#广度优先搜索（Breadth-First-Search-BFS）" class="headerlink" title="广度优先搜索（Breadth First Search,BFS）"></a>广度优先搜索（Breadth First Search,BFS）</h3><p>广度优先搜索类似于树的层次遍历。从顶点v0出发，在访问了v0之后，依次访问v0各个未被访问的邻接点，然后分别从这些邻接点出发，访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。直至图中所有已被访问的顶点的邻接点都被访问到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵存储的图 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Vertex V)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点 %d&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span></span><br><span class="line"><span class="comment">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span></span><br><span class="line"><span class="comment">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEdge</span><span class="params">(MGraph Graph, Vertex V, Vertex W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Graph-&gt;G[V][W] &lt; INFINITY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Visited[]已经为全局变量，且初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MGraph Graph, Vertex S, <span class="keyword">void</span>(* Visit)(Vertex))</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 以S为出发点对邻接矩阵存储的图进行BFS搜索 */</span></span><br><span class="line">    Vertex V,W;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问 S 顶点 */</span></span><br><span class="line">    Visit(S);</span><br><span class="line">    Visited[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = CreateQueue(MaxSize);           <span class="comment">/* 创建一个空队列 */</span></span><br><span class="line"></span><br><span class="line">    AddQ(Q, S);         <span class="comment">/* 将S入队 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q)) &#123;</span><br><span class="line">        V = DeleteQ(Q);  <span class="comment">/* 弹出V */</span></span><br><span class="line">        <span class="keyword">for</span>(W = <span class="number">0</span>;W &lt; Graph-&gt;Nv;W++) &#123;              <span class="comment">/* 对图中的每一个顶点 W */</span></span><br><span class="line">            <span class="comment">/* 如果W没有访问过且是V的邻接点 */</span></span><br><span class="line">            <span class="keyword">if</span>(!Visited[W] &amp;&amp; IsEdge(Graph, V, W))</span><br><span class="line">                <span class="comment">/* 访问 W 顶点 */</span></span><br><span class="line">                Visit(W);</span><br><span class="line">                Visited[W] = <span class="literal">true</span>;  <span class="comment">/* 将 W 标记为已访问 */</span></span><br><span class="line">                AddQ(Q, W);         <span class="comment">/* 将 W 入队列 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若有 N 个顶点、E 条边，DFS 和 BFS 的时间复杂度为：</p>
<ul>
<li><p>用邻接表存储图，为 O(N+E);</p>
</li>
<li><p>用邻接矩阵存储图，为 O(N^2)。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/12/16/%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/16/%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">散列查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-16 19:58:21" itemprop="dateCreated datePublished" datetime="2019-12-16T19:58:21+08:00">2019-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:49:49" itemprop="dateModified" datetime="2020-09-23T16:49:49+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>问题：如何快速搜索到需要的关键词？</p>
<p>我们知道查找的本质是已知一个对象，找到该对象的位置。因此如果我们在安排位置时，通过一个”散列函数“来计算出对象的位置进行存放，当要查找这个对象时，再通过相同的”散列函数“即可直接计算出对象的位置。</p>
<p>因此其时间复杂度几乎是：O(1)，即查找时间与问题规模无关！</p>
<!--- more --->

<p>那么问题就来了，我们如何构造出一个比较好的散列函数，如果多个关键词通过某个散列函数计算出了相同的位置，我们如何解决这种冲突。</p>
<p>所以散列查找法的两项基本工作就是：</p>
<ul>
<li><p>计算位置：构造散列函数确定关键词的存储位置</p>
</li>
<li><p>解决冲突：应用某种策略解决多个关键字位置相同的问题</p>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>散列表（哈希表）</strong>：</p>
<p><strong>类型名称</strong>：符号表(SymbolTable)</p>
<p><strong>数据对象集</strong>：符号表是“名字(Name)—属性(Attribute)”对的集合</p>
<p><strong>操作集</strong>：对于一个具体的符号表Table∈SymbolTable，一个给定的名字Name∈NameType，属性Attr∈AttributeType，以及正整数TableSize，符号表的基本操作有：</p>
<p><code>SymbolTable CreateTable(int TableSize)</code>：创建空的符号表，其最大长度为TableSize；</p>
<p><code>bool IsIn(SymbolTable Table,NameType Name)</code>：查找指定 Name 是否在符号表 Table 中；</p>
<p><code>AttributeType Find(SymbolTable Table,NameType Name)</code>：获取符号表 Table 中指定名字 Name 对应的属性；</p>
<p><code>bool Modify(SymbolTable Table,NameType Name,AttributeType Attr)</code>：将Table 中指定名字 Name 的属性修改为 Attr；</p>
<p><code>bool Insert(SymbolTable Table,NameType Name,AttributeType Attr)</code>：向 Table 中插入一个新名字 Name 及其属性 Attr；</p>
<p><code>bool Delete(SymbolTable Table,NameType Name)</code>：从 Table 中删除一个名字 Name 及其属性。</p>
<p><strong>散列(Hashing)的基本思想是：</strong></p>
<p>1.以关键字key为自变量，通过一个确定的函数h（散列函数），计算出对应的函数值h(key)，作为数据对象的存储地址。</p>
<p>2.可能不同的关键字会映射到同一个散列地址上，即h(key_i )=h(key_j ),key_i≠key_j，称为冲突——因此需要某种冲突解决策略。</p>
<p>例：有 n=11 个对象的集合 {18,23,11,20,2,7,27,30,42,15,34}。符号表的大小 TableSize = 17（通常为素数），选取散列函数如下：</p>
<p>h(key) = key mod TableSize (求余)</p>
<p>用这个散列函数对 11 个对象建立查找表，如下所示：</p>


<ul>
<li><p>存放：<br>如果新插入35，h(35)=1，该位置已有对象，冲突</p>
</li>
<li><p>查找：<br>key = 22,h(22) = 5，该地址为空，不在表中<br>key = 30,h(30) = 13，该地址存放的是30，找到</p>
</li>
</ul>
<blockquote>
<p>定于 装填因子：设散列表空间大小为 m，填入表中的元素个数是 n，则称 a=n/m 为散列表的装填因子。</p>
</blockquote>
<h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><p>一个好的散列函数应该考虑以下两个因素：</p>
<p>1.计算简单，以便提高转换速度；</p>
<p>2.关键词对应的地址空间分布均匀，以尽量减少冲突。</p>
<h3 id="数字关键词的散列函数构造"><a href="#数字关键词的散列函数构造" class="headerlink" title="数字关键词的散列函数构造"></a>数字关键词的散列函数构造</h3><p>1.直接定址法</p>
<p>如果我们要统计人口的年龄分布情况（0——120），那么对于年龄这个关键词可以直接作为地址，即 h(key) = key。</p>
<p>如果要统计的是 1990 年以后出任的人口分布情况，那么对于出生年份这个关键词可以减去 1990 作为地址，即 h(key) = key-1990。</p>


<p>总之，取关键词的某个线性函数值为散列地址，即</p>
<p>h(key) = a X key + b   (a,b为常数)</p>
<p>2.除留余数法</p>
<p>现实生活中比较常用的方法是除留余数法。假设散列表长为 TableSize，选择一个正整数 p ≤ TableSize，散列函数构造为：</p>
<p>h(key) = key mod p</p>
<p>这里 p 一般取为小于等于散列表长 TableSize 的某个最大的素数比较好。</p>
<p>3.数字分析法</p>
<p>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址</p>
<p>比如：取手机号 key 的后 4 位作为地址：</p>
<p>散列函数位：h(key) = atoi(key+7)</p>
<h3 id="字符串关键词的散列函数构造"><a href="#字符串关键词的散列函数构造" class="headerlink" title="字符串关键词的散列函数构造"></a>字符串关键词的散列函数构造</h3><p>1.一个简单的散列函数——ASCII码加和法</p>


<p>2.简单的改进——前3个字符移位法</p>


<p>3.好的散列函数——移位法</p>


<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>在前面的散列函数构造过程中，我们努力使散列地址均匀分布在整个地址空间，但实际应用中，冲突只能尽量减少，而不能完全避免。接下来我们讨论在冲突发生时，如何有效地解决它。常用的处理冲突的方法有开放地址法（Open Addressing）和链地址法（Linear Probing）。</p>
<h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p>一旦产生了冲突（该地址已有其它元素），就按照某种规则去寻找另一空地址。</p>
<p>若发生了第 i 次冲突，试探的下一个地址将增加 di，基本公式是：</p>
<p>hi(key) = (h(key) + di) mod TableSize (1 &lt;= i &lt; TableSize)</p>
<p>di决定了不同的解决冲突方案：线性探测、平方探测、双散列。</p>
<p>1.线性探测</p>
<p><strong>以增量序列1,2,3…TableSize-1循环试探下一个存储地址。</strong></p>
<p>设关键词序列为 {47,7,29,11,9,84,54,20,30}</p>
<p>散列表长 TableSize=13（装填因子 9/13=0.69）；</p>
<p>散列函数为：h(key) = key mod 11。</p>
<p>用线性探测法处理冲突，列出一次插入后的散列表，并估算查找性能。</p>


<p>注意”聚集“现象。</p>
<p>散列表查找性能分析</p>
<ul>
<li><p>成功平均查找长度(ASLs)</p>
</li>
<li><p>不成功平均查找长度(ASLu)</p>
</li>
</ul>
<p>散列表如下：</p>


<p>分析：</p>
<p>ASLs：查找表中关键词的平均查找比较次数（其冲突次数加 1）</p>
<p>ASLs = (1+7+1+1+2+1+4+2+4)/9 = 2.56</p>
<p>ASLu：不在散列表中的关键词的平均查找次数（不成功）</p>
<p>一般方法：将不在散列表中的关键词分为若干类。如根据 h(key) 分类</p>
<p>ASLu = (3+2+1+2+1+1+1+9+8+7+6)/11 = 3.73</p>
<p>2.平方探测法——二次探测</p>
<p><strong>以增量序列 1，-1，4，-4，9，-9，…，q^2，-q^2，且 q &lt;= [TableSize/2] 循环试探下一个存储地址。</strong></p>
<p>设关键词序列为 {47,7,29,11,9,84,54,20,30}，散列表长度 TableSize = 11，散列函数为：h(key) = key mod 11。用平方探测法处理冲突，列出依次插入后的散列表，并估算ASLs。</p>


<p>ASLs = (1+1+2+1+1+3+1+4+4)/9 = 2</p>
<p><strong>是否有空间，平方探测（二次探测）就能找到？</strong></p>


<p><strong>有证明表明，如果散列表的长度 TableSize 是某个 4k+3（k是正整数）形式的素数时，平方探测法就可以检测到整个散列表空间。</strong>这一点很重要，使我们能够放心使用平方探测法的理论保证。</p>
<p>在开放地址的散列表中，不能进行标准的删除操作，因为相应的单元可能引起过冲突，数据对象绕过它存在了别处。为此开放地址散列表需要“惰性删除”，即需要增加一个“删除标记”，而并不是真正的删除它。这样可以不影响查找，但额外的存储负担增加了代码的复杂性。</p>
<p>以下是开放地址法的类型声明：</p>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTABLESIZE 100000     <span class="comment">/* 允许开辟的最大散列表长度 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;        <span class="comment">/* 关键词类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;              <span class="comment">/* 散列地址类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> Index Position;         <span class="comment">/* 数据所在位置与散列地址是同一类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列单元的状态，分别对应：有合法元素、空单元、有已删除元素 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; Legitimate, Empty, Deleted &#125; EntryType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span> <span class="title">Cell</span>;</span>  <span class="comment">/* 散列表单元类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span> &#123;</span></span><br><span class="line">    ElementType Data;   <span class="comment">/* 存放的元素 */</span></span><br><span class="line">    EntryType Info;     <span class="comment">/* 单元状态 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span>* <span class="title">HashTable</span>;</span>  <span class="comment">/* 散列表类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span> &#123;</span>        <span class="comment">/* 散列表节点定义 */</span></span><br><span class="line">    <span class="keyword">int</span> TableSize;      <span class="comment">/* 散列表的最大长度 */</span></span><br><span class="line">    Cell *Cells;        <span class="comment">/* 存放散列单元的数组 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如下代码给出了散列表的初始化函数。首先申请散列表需要的空间，再将每个单元的 info 设置为 Empty，表示为空。注意需要确定一个不下于 TableSize 的素数，用作真正的散列表的地址空间大小，这个功能由 NextPrime 实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextPrime</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 返回大于N且不超过MAXTABLESIZE的最小素数 */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> p = (N%<span class="number">2</span>) ? N+<span class="number">2</span> : N+<span class="number">1</span>;  <span class="comment">/* 从大于N的第一个奇数开始 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= MAXTABLESIZE) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(p); i&gt;<span class="number">2</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(!(p%i)) <span class="keyword">break</span>;   <span class="comment">/* p不是素数 */</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">/* for循环正常结束，说明p是素数 */</span></span><br><span class="line">        <span class="keyword">else</span> p+=<span class="number">2</span>;  <span class="comment">/* 否则试探下一个奇数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HashTable <span class="title">CreateTable</span><span class="params">(<span class="keyword">int</span> TableSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashTable H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TblNode));</span><br><span class="line">    <span class="comment">/* 保证散列表的最大长度是素数 */</span></span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">    <span class="comment">/* 声明单元数组 */</span></span><br><span class="line">    H-&gt;Cells = (Cell*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cell)*H-&gt;TableSize);</span><br><span class="line">    <span class="comment">/* 初始化单元数组为空单元 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; H-&gt;TableSize;i++) &#123;</span><br><span class="line">        H-&gt;Cells[i].Info = Empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是平方探测法的查找函数。首先调用 Hash 函数计算地址，以确定关键词所在的散列表地址。用 while 循环控制直至明确查找成功或者找到空位置表示查找失败，遇到冲突则继续查找。</p>
<p>注意关键词 key 的类型 ElementType 不一定为整形，也可能被定义为字符串，若是字符串，则 while 的判断条件要用 C 语言的 strcmp 函数来替换。若找到关键词，函数直接返回结点的地址，若找不到则返回一个空的单元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(HashTable H, ElementType Key)</span> </span>&#123;</span><br><span class="line">    Position CurrentPos,OldPos;</span><br><span class="line">    <span class="keyword">int</span> CNum = <span class="number">0</span>; <span class="comment">/* 记录冲突次数 */</span></span><br><span class="line">    CurrentPos = OldPos = Hash(Key, H-&gt;TableSize); <span class="comment">/* 计算出其位置 */</span></span><br><span class="line">    <span class="comment">/* 当该单元为非空并且不是要找的元素时，发生冲突 */</span></span><br><span class="line">    <span class="keyword">while</span>(H-&gt;Cells[CurrentPos].Info != Empty &amp;&amp; H-&gt;Cells[CurrentPos].Data != Key) &#123;</span><br><span class="line">        <span class="comment">/* 字符串类型需调用 strcmp 函数 */</span></span><br><span class="line">        <span class="comment">/* 统计冲突次数 */</span></span><br><span class="line">        <span class="keyword">if</span>((++CNum % <span class="number">2</span>)) &#123;  <span class="comment">/* 奇数次冲突 */</span></span><br><span class="line">            <span class="comment">/* 增量为 [(CNum+1)/2]^2 */</span></span><br><span class="line">            CurrentPos = OldPos + (CNum+<span class="number">1</span>) * (CNum+<span class="number">1</span>) /<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(CurrentPos &gt;= H-&gt;TableSize)</span><br><span class="line">                CurrentPos = CurrentPos%H-&gt;TableSize;   <span class="comment">/* 调整为合法地址 */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* 偶数次冲突 */</span></span><br><span class="line">            <span class="comment">/* 增量为 -(CNum/2)^2 */</span></span><br><span class="line">            CurrentPos = OldPos - CNum * CNum /<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(CurrentPos &lt; <span class="number">0</span>)   <span class="comment">/* 调整为合法地址 */</span></span><br><span class="line">                CurrentPos += H-&gt;TableSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CurrentPos;</span><br><span class="line">    <span class="comment">/* 此时 CurrentPos 或者是 Key 的位置，或者是一个空单元的地址（表示找不到） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是插入函数，先检查 Key 是否已经存在，该单元的状态只要不是合法的，就可以在此插入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(HashTable H, ElementType Key)</span> </span>&#123;</span><br><span class="line">    Position p = Find(H,Key);   <span class="comment">/* 首先检查Key值是否存在 */</span></span><br><span class="line">    <span class="keyword">if</span>(H-&gt;Cells[p].Info != Legitimate) &#123;    <span class="comment">/* 如果这个单元没有被占用，说明Key可以插入在此 */</span></span><br><span class="line">        H-&gt;Cells[p].Info = Legitimate;</span><br><span class="line">        H-&gt;Cells[p].Data = Key;</span><br><span class="line">        <span class="comment">/* 字符串类型需调用strcpy函数 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;键值已存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开放地址法的删除操作只需要该改变单元的状态 Info 即可。</p>
<p>3.双散列探测法</p>


<p>4.再散列（Rehashing）</p>
<p>当散列表元素太多时（即装填因子太大时），查找效率就会下降；实用的装填因子一般取<strong>0.5——0.85</strong>。</p>
<p>当装填因子过大时，解决的方法就是加倍扩大散列表，这个过程叫做**”再散列”**。</p>
<h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>分离链接法就是将相应位置上冲突的所有关键词存储在同一个单链表里面。</p>
<p>设关键字序列为{47,7,29,11,16,92,22,8,3,50,37,89,94,21}，散列函数取：h(key) = key mod 11；用分离链接法处理冲突，结果如下：</p>


<p>表中有 9 个结点只需查找 1 次，5 个结点需要查找 2 次，查找成功的平均查找次数：</p>
<p>ASLs = (9+5*2)/14 = 1.36</p>
<p>以下是分离链接法的代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYLENGTH 15    <span class="comment">/* 关键字符串的最大长度 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElementType[KEYLENGTH+<span class="number">1</span>];  <span class="comment">/* 关键词类型用字符串 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;  <span class="comment">/* 散列地址类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span>* <span class="title">HashTable</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> TableSize;</span><br><span class="line">    List Heads; <span class="comment">/* 指向链表头结点的数组 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>散列表结构包括一个 TableSize 记录表的最大长度以及一个节点数组对应的单链表，它们在初始化时动态分配空间，并设置相应的初值。</p>
<p>以下是散列表的初始化函数 CreateTable。首先申请散列表的头结点空间；然后确定一个不小于 TableSize 的素数，用作真正的散列表的地址空间大小；最后动态分配散列表的地址列表数组并初始化空的头结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HashTable <span class="title">CreateTable</span><span class="params">(<span class="keyword">int</span> TableSize)</span> </span>&#123;</span><br><span class="line">    HashTable H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TblNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保证散列的最大长度是素数 */</span></span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配链表表头节点数组 */</span></span><br><span class="line">    H-&gt;Heads = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode)*H-&gt;TableSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化表头节点 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;H-&gt;TableSize; i++) &#123;</span><br><span class="line">        H-&gt;Heads[<span class="number">0</span>].Data[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        H-&gt;Heads.Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是查找 Find 函数。首先调用 Hash 函数计算地址，得到关键字所在的 Heads 中单元的下标 Pos；P 则指向 Heads[Pos] 链表中真正的第一个元素。因为关键字是字符串，所以 while 循环条件判断要用 strcmp 函数来比较 Data 与 Key 的值。若找到了关键词，函数直接返回结点的地址，若找不到则返回空地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(HashTable H, ElementType Key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Position Pos = Hash(Key,H-&gt;TableSize);  <span class="comment">/* 找到该Key的位置 */</span></span><br><span class="line"></span><br><span class="line">    Index P = H-&gt;Heads[Pos].Next;   <span class="comment">/* 从该链表的第一个节点开始 */</span></span><br><span class="line">    <span class="comment">/* 当未到表尾，并且Key未找到时 */</span></span><br><span class="line">    <span class="keyword">while</span>(P &amp;&amp; <span class="built_in">strcmp</span>(P-&gt;Data,Key))</span><br><span class="line">        P=P-&gt;Next;</span><br><span class="line">    <span class="comment">/* 此时P指向找到的节点或者NULL */</span></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是插入函数 Insert。该函数首先调用 Find 函数，如果找到了关键词则不需要插入，返回插入不成功的信息；如果找不到关键词才需要插入。插入时，先申请一个新结点 NewCell，然后计算 Key 的地址 Pos，插入成为单链表 Heads[Pos] 的第一个结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(HashTable H, ElementType Key)</span> </span>&#123;</span><br><span class="line">    Position P = Find(H, Key);</span><br><span class="line">    <span class="keyword">if</span>(!P) &#123;</span><br><span class="line"></span><br><span class="line">        Position NewCell = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        <span class="built_in">strcpy</span>(NewCell-&gt;Data, Key);</span><br><span class="line">        Index Pos=Hash(Key,H-&gt;TableSize);</span><br><span class="line">        <span class="comment">/* 将NewCell插入为H-&gt;Heads[Pos]链表的第一个节点 */</span></span><br><span class="line">        NewCell-&gt;Next = H-&gt;Heads[Pos].Next;</span><br><span class="line">        H-&gt;Heads[Pos].Next =NewCell;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关键词已存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放 CreateTable 所占用的内存空间可以调用如下 DestroyTable 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryTable</span><span class="params">(HashTable H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Position P, temp;</span><br><span class="line">    <span class="comment">/* 释放链表的每个节点 */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;H-&gt;TableSize; i++) &#123;</span><br><span class="line">        P = H-&gt;Heads[i].Next;</span><br><span class="line">        <span class="keyword">while</span>(P) &#123;</span><br><span class="line">            temp = P-&gt;Next;</span><br><span class="line">            <span class="built_in">free</span>(P);</span><br><span class="line">            P = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(H-&gt;Heads); <span class="comment">/* 释放头结点数组 */</span></span><br><span class="line">    <span class="built_in">free</span>(H);    <span class="comment">/* 释放散列表节点 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分离链接法的删除操作与链表的删除操作相似。不过需要先通过 Hash 函数得到链表的头结点，再在该链表中进行删除即可。</p>
<h2 id="散列表的性能分析"><a href="#散列表的性能分析" class="headerlink" title="散列表的性能分析"></a>散列表的性能分析</h2><p>在上面的介绍中，我们已经用 ASL 来度量散列表的查找效率。查找过程中，关键词比较的次数，取决于产生冲突的多少。产生的冲突多，查找效率就高；产生的冲突多，查找效率就低.因此，影响产生冲突多少的因素，也就是影响查找效率的因素。主要有以下三个因素：</p>
<ul>
<li><p>散列函数是否均匀</p>
</li>
<li><p>处理冲突的方法</p>
</li>
<li><p>散列表的装填因子</p>
</li>
</ul>
<h3 id="线性探测法的查找性能"><a href="#线性探测法的查找性能" class="headerlink" title="线性探测法的查找性能"></a>线性探测法的查找性能</h3><p>可以证明，线性探测法的期望探测次数满足下列公式：</p>


<h3 id="平方探测法和双散列探测法的查找性能"><a href="#平方探测法和双散列探测法的查找性能" class="headerlink" title="平方探测法和双散列探测法的查找性能"></a>平方探测法和双散列探测法的查找性能</h3><p>可以证明，平方探测法和双散列探测法的期望探测次数满足下列公式：</p>


<p>下图表示了上面几种探测法的期望探测次数与装填因子之间的关系：</p>


<p>由图可知，当装填因子 &lt; 0.5 的时候，各种探测法的期望探测次数都不大，也比较接近。随着装填因子的增大，线性探测法的期望探测次数增加较快，不成功查找和插入操作的期望探测次数明显比成功查找的期望探测次数要大。合理的装填因子应该不超过0.85。</p>
<h3 id="分离链接法的查找性能"><a href="#分离链接法的查找性能" class="headerlink" title="分离链接法的查找性能"></a>分离链接法的查找性能</h3><p>我们把分离链接法中的每个链表的平均长度定义成装填因子，因此装填因子有可能超过 1。</p>
<p>不难证明，其期望探测次数为：</p>


<h2 id="散列的特点"><a href="#散列的特点" class="headerlink" title="散列的特点"></a>散列的特点</h2><p>1.选择合适的 h(key)，散列法的查找效率期望是常数 O(1)，它几乎与关键字的空间的大小 N 无关，也适合于关键字直接比较计算量大的问题；</p>
<p>2.它是以较小的装填因子为前提，因此，散列方法是一个以空间换时间；</p>
<p>3.散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找。</p>
<h3 id="开放地址法的特点"><a href="#开放地址法的特点" class="headerlink" title="开放地址法的特点"></a>开放地址法的特点</h3><p>1.散列表是一个数组，存储效率高，随即查找；</p>
<p>2.散列表有聚集现象</p>
<h3 id="分离链接法的特点"><a href="#分离链接法的特点" class="headerlink" title="分离链接法的特点"></a>分离链接法的特点</h3><p>1.散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低；</p>
<p>2.关键字删除不需要懒惰删除法，因此没有存储垃圾；</p>
<p>3.太小的装填因子可能导致空间浪费，大的装填因子又会付出更多的时间代价。不均匀的链表长度导致时间效率严重下降。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%913/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%913/" class="post-title-link" itemprop="url">数据结构——树（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-15 17:20:02" itemprop="dateCreated datePublished" datetime="2019-12-15T17:20:02+08:00">2019-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:50:24" itemprop="dateModified" datetime="2020-09-23T16:50:24+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>前面介绍过队列，它是一种先进先出的数据结构，队列中没有哪一个元素是有特权的，前面的元素未处理完，后面的只能等待。而本文章介绍的堆（Heap）正是考虑了适合于特权需求的数据结构，因此，堆也通常被称为“优先队列”（Priority Queue）。</p>
<!--- more --->

<h3 id="堆的定义和表示"><a href="#堆的定义和表示" class="headerlink" title="堆的定义和表示"></a>堆的定义和表示</h3><blockquote>
<p>堆是特殊的队列，从中取出元素是依照元素的优先级大小，而不是元素进入队列的先后顺序。</p>
</blockquote>
<p>那么我们应该如何组织优先队列的存储结构呢？</p>
<p>如采用数组或者链表实现优先队列</p>
<ul>
<li><p>数组<br>插入：元素总是插入尾部：O(1)<br>删除：查找最大或最小值：O(N)<br>从数组中删除需要移动元素：O(N)</p>
</li>
<li><p>链表<br>插入：元素总是插入在链表头部：O(1)<br>删除：查找最大或最小值：O(N)<br>删除结点：O(1)</p>
</li>
<li><p>有序数组<br>插入：找到合适的位置：O(N)或O(logN)<br>移动元素并插入：O(N)<br>删除：删除最后一个元素：O(1)</p>
</li>
<li><p>有序链表<br>插入：找到合适的位置：O(N)<br>插入元素：O(1)<br>删除：删除首元素或者最后一个元素：O(1)</p>
</li>
</ul>
<p>上面 4 种方式，其最坏时间复杂度都达到了 O(N)，而我们知道二叉搜索树的插入和删除操作代价为 O(logN)。因此我们可以利用树型结构来组织数据。</p>
<p><strong>堆最常用放入结构是用二叉树表示，不特指的话，它是一颗完全二叉树。</strong>由于完全二叉树的排列及其规则，因此我们可以使用数组来实现堆的存储。</p>


<p>堆中的元素是按照完全二叉树的层序存储的，还需要注意的是所用数组的起始单元为 1，这样做的目的是更容易从子结点找到父结点。根据完全二叉树的性质，对于下标为 i 的结点，其父结点的下标为 [i/2]。反过来，找结点 i 的左右子结点也非常方便，分别为 2i 和 2i + 1。</p>
<p>堆的两个特性：</p>
<ul>
<li><p>结构性：用数组表示的完全二叉树</p>
</li>
<li><p>有序性：任一结点的关键字是其子树所有结点的最大值或最小值<br>在最大堆（MaxHeap）中，任一结点的值大于或等于其子结点的值，那么根元素是整个堆中最大的；<br>在最小堆（MinHeap）中，任一结点的值小于或等于其子结点的值，那么根元素是整个堆中最小的。</p>
</li>
</ul>
<p>注意：从根节点到任意节点路径上结点序列的有序性！</p>


<h3 id="堆的抽象数据类型描述"><a href="#堆的抽象数据类型描述" class="headerlink" title="堆的抽象数据类型描述"></a>堆的抽象数据类型描述</h3><p>以最大堆为例介绍堆的抽象数据类型描述：</p>
<p>类型名称：最大堆（MaxHeap）</p>
<p>数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值</p>
<p>操作集：最大堆 H∈MaxHeap，元素 item∈ElementType，主要操作有：</p>
<ul>
<li><p><code>MaxHeap CreateHeap(int MaxSize)</code>：创建长度为 MaxSize 的空最大堆</p>
</li>
<li><p><code>bool IsFull(MaxHeap H)</code>：判断最大堆是否已满</p>
</li>
<li><p><code>bool Insert(MaxHeap H, ElementType X)</code>：将元素 X 插入最大堆</p>
</li>
<li><p><code>bool IsEmpty(MaxHeap H)</code>：判断堆是否为空</p>
</li>
<li><p><code>ElementType DeleteMax(MaxHeap H)</code>：删除并返回最大元素</p>
</li>
</ul>
<p>因此用 C 语言描述最大堆如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span>* <span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;      <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    <span class="keyword">int</span> Size;               <span class="comment">/* 堆中当前元素个数 */</span></span><br><span class="line">    <span class="keyword">int</span> Capacity;           <span class="comment">/* 堆的最大容量 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最大堆的创建"><a href="#最大堆的创建" class="headerlink" title="最大堆的创建"></a>最大堆的创建</h3><p>注意到根据用户的输入 MaxSize 创建最大堆时，数组应该有 MaxSize + 1 个元素，因为数组起始单元为 1，元素值存在第 1——MaxSize 个单元中。通常第 0 个单元是无用的，但是如果事先知道堆中所有元素的取值范围，也可以给第 0 个单元赋一个特殊的值 MAXDATA，这个值比堆中任何一个元素都要大。这人 MAXDATA 的“哨兵”作用会在插入操作中用到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">CreateHeap</span><span class="params">(<span class="keyword">int</span> MaxSize)</span> </span>&#123;</span><br><span class="line">    MaxHeap H = (MaxHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HNode));</span><br><span class="line">    H-&gt;Data = (ElementType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType)*(MaxSize+<span class="number">1</span>));</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Data[<span class="number">0</span>] = MAXDATA;  </span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大堆的插入"><a href="#最大堆的插入" class="headerlink" title="最大堆的插入"></a>最大堆的插入</h3><p>最大堆中插入一个新元素以后，新增结点既要保证最大堆仍是一个完全二叉树，结点之间的元素值大小也要满足最大堆的性质，因此需要移动元素。</p>
<p>完成一个元素的最大堆插入操作，只要从完全二叉树的新增结点开始，顺着其父结点到根结点的路径，将路径上各点依次与新元素值进行比较，当一结点的值小于新元素的值，就下移这个结点的元素，直到有结点的值大于新元素的值或者根结点也下移为止，空出的结点位置就是新元素插入点。</p>
<p>插入过程可以用一句话简单描述：从新增的最后一个结点的父结点开始，用要插入的元素向下过滤上层结点。实际上，由于堆元素之间的部分有序性，最大堆从根结点到任一叶结点的路径都是递降的有序序列。插入过程的调整就是继续保证这个序列的有序性。</p>
<p>如下给出了最大堆的插入操作算法。注意到如果新插入的 X 比原先堆中所有的元素都大，那么它将一直向上比较到根结点都不会停止。对于这种情况，我们可以加一个特殊判断，当 i 值取 1 时，直接跳出循环，但是这种程序不够优美。因此之前我们定义了一个“哨兵”，即事先知道堆中所有元素的取值范围，这样可以给 H-&gt;Data[0] 赋一个特殊的值 MAXDATA，这个值比堆中所有元素都要大，这样当 i 为 1 时 H-&gt;Data[i/2] &lt; X 这个条件肯定不满足，跳出循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(MaxHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> H-&gt;Size == H-&gt;Capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(MaxHeap H, ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ++(H-&gt;Size);        <span class="comment">/* i指向插入后堆中最后一个元素 */</span></span><br><span class="line">        <span class="keyword">for</span>( ; H-&gt;Data[i/<span class="number">2</span>] &lt; X; i/=<span class="number">2</span>)</span><br><span class="line">            H-&gt;Data[i] = H-&gt;Data[i/<span class="number">2</span>];  <span class="comment">/* 上滤 X */</span></span><br><span class="line">        H-&gt;Data[i] = X;     <span class="comment">/* 找到位置将 X 插入 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的时间复杂度为 O(logN)。</p>
<h3 id="最大堆的删除"><a href="#最大堆的删除" class="headerlink" title="最大堆的删除"></a>最大堆的删除</h3><p>最大堆的删除实际上是取出根结点的最大值元素，同时删除堆的一个结点。删除后仍要是一颗完全二叉树，结点元素的大小仍要满足最大堆的性质。因此删除的结点应该是数组的最后一个单元。即取走根结点之后，最后一个结点必须重新放置。确定最后一个结点放置在哪里是最大堆删除的关键。</p>
<p>因此我们可以将堆中的最后一个元素当成假设的根结点，依次与下层的子结点进行比较，如果小于子结点的值，从子结点中选择较大的元素上移一层，直到在某一点上，比较结果是大于两个子结点的值，此时的空结点就是元素要放置的位置。</p>
<p>删除过程可用一句简单的话描述：从根节点开始，用最大堆中最后一个元素向上过滤下层结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(MaxHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> H-&gt;Size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(MaxHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ElementType MaxItem = H-&gt;Data[<span class="number">1</span>];   <span class="comment">/* 取出根结点存放最大值 */</span></span><br><span class="line">    <span class="comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span></span><br><span class="line">    ElementType X = H-&gt;Data[(H-&gt;Size)--];  <span class="comment">/* 注意堆的规模要减1 */</span></span><br><span class="line">    <span class="keyword">int</span> Parent,Child;</span><br><span class="line">    <span class="keyword">for</span>(Parent=<span class="number">1</span>; <span class="number">2</span>*Parent &lt;= H-&gt;Size; Parent=Child) &#123;</span><br><span class="line">        Child = <span class="number">2</span>*Parent;   <span class="comment">/* 先将最大儿子设为左儿子 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果存在右儿子，并且右儿子的值大于左儿子，则将最大儿子设为右儿子 */</span></span><br><span class="line">        <span class="keyword">if</span>((Child+<span class="number">1</span>) &lt;= H-&gt;Size &amp;&amp; H-&gt;Data[Child+<span class="number">1</span>] &gt; H-&gt;Data[Child])</span><br><span class="line">            Child++;</span><br><span class="line">        <span class="keyword">if</span>(X &gt;= H-&gt;Data[Child]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其时间复杂度也为 O(logN)。</p>
<h3 id="最大堆的建立"><a href="#最大堆的建立" class="headerlink" title="最大堆的建立"></a>最大堆的建立</h3><p>建立最大堆是指如何将已经存在的 N 个元素按照最大堆的要求存放在一个一位数组里面。主要有如下两种方法：</p>
<ul>
<li><p>通过插入操作，将 N 个元素依次插入到一个初始为空的堆中去，其时间复杂度显然是 O(NlogN)。</p>
</li>
<li><p>在线性时间复杂度下建立最大堆。<br>将 N 个元素按照输入顺序存入二叉树中，这一步只需要满足完全二叉树的结构特性；接着调整各结点的位置，以满足最大堆的有序特性。</p>
</li>
</ul>
<p>我们主要介绍第二种方法：</p>
<p>首先将 N 个元素读入数组，接着从第 [N/2] 个结点（这是最后面一个有儿子的结点）开始，对包括此节点在内的其它前面各节点 [N/2]-1,[N-2]-2,…逐一向下进行过滤，直到根结点过滤完毕，最大堆也就建立起来了。</p>
<p>首先实现向下过滤的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">(MaxHeap H, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 对堆中的第 p 个结点向下过滤，与删除操作类似 */</span></span><br><span class="line">    ElementType X = H-&gt;Data[p];</span><br><span class="line">    <span class="keyword">int</span> Parent,Child;</span><br><span class="line">    <span class="keyword">for</span>(Parent = p; <span class="number">2</span>*Parent &lt;= H-&gt;Size; Parent=Child) &#123;</span><br><span class="line">        Child = <span class="number">2</span>*Parent;   <span class="comment">/* 先将最大儿子设为左儿子 */</span></span><br><span class="line">        <span class="comment">/* 如果存在右儿子，并且右儿子的值大于左儿子，则将最大儿子设为右儿子 */</span></span><br><span class="line">        <span class="keyword">if</span>((Child+<span class="number">1</span>) &lt;= H-&gt;Size &amp;&amp; H-&gt;Data[Child+<span class="number">1</span>] &gt; H-&gt;Data[Child])</span><br><span class="line">            Child++;</span><br><span class="line">        <span class="keyword">if</span>(X &gt;= H-&gt;Data[Child]) <span class="keyword">break</span>;  <span class="comment">/* 找到合适的位置 */</span></span><br><span class="line">        <span class="keyword">else</span> H-&gt;Data[Parent] = H-&gt;Data[Child];  <span class="comment">/* 下滤 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着从第 [N/2] 个结点（这是最后面一个有儿子的结点）开始，对包括此节点在内的其它前面各节点 [N/2]-1,[N-2]-2,…逐一向下进行过滤，直到根结点过滤完毕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(MaxHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 调整堆中的元素，使其满足有序性 */</span></span><br><span class="line">    <span class="comment">/* 这里假设所有 H-&gt;Size 个元素已经存在 H-&gt;Data[] 中 */</span></span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="comment">/* 从最后一个有孩子的父结点开始，到根结点1 */</span></span><br><span class="line">    <span class="keyword">for</span>(p = H-&gt;Size/<span class="number">2</span>; p&gt;=<span class="number">1</span>; p--) &#123;</span><br><span class="line">        PercDown(H,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度为 O(N)。证明如下：</p>


<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>首先看一个简单的例子，要求编写一个程序将百分制成绩转化成五分制成绩。首先给出一个简单的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &lt; <span class="number">60</span>) grade = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">70</span>) grade = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">80</span>) grade = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">90</span>) grade = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> grade = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>其判定树如下：</p>


<p>如果考虑学生的成绩分布概率：</p>


<p>则该判定树的查找效率为：0.05x1 + 0.15x2 + 0.4x3 + 0.3x4 + 0.1x4 = 3.15</p>
<p>如果根据概率修改判定树：</p>


<p>则查找效率变为：0.05x3 + 0.15x3 + 0.4x2 + 0.3x2 + 0.1x2 = 2.2</p>
<p>由此可见，同一问题采用不同的判定逻辑，计算效率是不一样的。那么是否能够找到最好的比较判定逻辑，使运算效率达到最高？即如何根据结点不同的查找频率构造更有效的搜索树？</p>
<h3 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h3><blockquote>
<p>带权路径长度：结点的带权路径长度是指从根结点到该结点之间的路径长度与该结点上所带权值的乘积。</p>
</blockquote>
<p>设一棵树有 n 个叶子结点，每个叶结点带有权值 Wk，从根结点到每个叶结点的长度为 lk，则每个叶结点的带权路径长度之和就是这棵树的带权路径长度（Weighted Path Length,WPL），它可以表示为：</p>
<p>WPL = W1xl1 + W2xl2 + W3xl3 + … + Wkxlk</p>
<blockquote>
<p>假设有 n 个权值构造了 n 个叶结点的二叉树，每个叶子的权重是 n 个权重之一，这样的二叉树可以构造出很多个，其中必有一个是带权路径长度最小的，这颗二叉树称为最优二叉树或哈夫曼树。</p>
</blockquote>
<h3 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h3><p>由哈夫曼树和带权路径长度的定义可知，一棵二叉树要使其 WPL 最小，必须使权值越大的叶结点越靠近根结点，而权值越小的叶结点越远离根结点。哈夫曼根据这一特点提出了一种方法，它是一种贪心算法。该算法在初始状态下将每个字符看成一颗独立的树，每一步执行两棵树的合并，而选择合并对象的原则是“贪心”的，即每次选择权最小的两个数进行合并。具体过程如下：</p>
<p>1.由给定的 n 个权值构造出 n 颗只有一个叶结点的二叉树，从而得到一个二叉树的集合 F；</p>
<p>2.从 F 中选取根结点的权值最小和次小的两颗二叉树作为左右子树构造出一颗新的二叉树，这棵新的二叉树根结点的权值为左右子树根结点权值之和；</p>
<p>3.在集合中删除上一步中作为左右子树的两颗二叉树，并将新构造的二叉树加入到集合 F 中；</p>
<p>4.重复2、3步，当 F 中只剩下一颗二叉树时，这颗二叉树就是所要建立的哈夫曼树。</p>
<p>需要注意的是：对于同一组给定权值叶结点所构造的哈夫曼树，树的形状可能不同。但无论形状如何，这些哈夫曼树的带权路径长度是相同的，并一定都是同一最小值。</p>
<p>为了便于抽取最小权值的子树，在构造树过程中使用最小堆的删除及插入操作。这里堆中的元素是一个加了权值的树结点的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span>* <span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Weight;         <span class="comment">/* 结点权值 */</span></span><br><span class="line">    HuffmanTree Left;   <span class="comment">/* 指向左子树 */</span></span><br><span class="line">    HuffmanTree Right;  <span class="comment">/* 指向右子树 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 定义最小堆，最小堆里面每一个元素都是一颗哈夫曼树 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span>* <span class="title">MinHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> &#123;</span></span><br><span class="line">    HuffmanTree *Data;</span><br><span class="line">    <span class="keyword">int</span> Size;</span><br><span class="line">    <span class="keyword">int</span> Capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 最小堆里面的元素类型都是 HuffmanTree</span></span><br><span class="line"><span class="comment">       假设 H-&gt;Size 个权值已经存在 H-&gt;Data[i]-&gt;Weight 里</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 H-&gt;Data[]按权值 Weight 调整为最小堆 */</span></span><br><span class="line">    BuildHeap(H);</span><br><span class="line">    <span class="keyword">int</span> N = H-&gt;Size;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123; <span class="comment">/* 做 H-&gt;Size - 1次合并 */</span></span><br><span class="line">        <span class="comment">/* 选取两个权值最小的构建新的哈夫曼树 */</span></span><br><span class="line">        T = (HuffmanTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HTNode)); <span class="comment">/* 新建一个新的根结点 */</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);                         <span class="comment">/* 从最小堆中删除一个结点，作为 T 的左子树 */</span></span><br><span class="line">        T-&gt;Right = DeleteMin(H);                        <span class="comment">/* 从最小堆中删除一个结点，作为 T 的右子树 */</span></span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;   <span class="comment">/* 新树的权值为两个子树权值之和 */</span></span><br><span class="line">        <span class="comment">/* 将 T 插入到堆中 */</span></span><br><span class="line">        Insert(H, T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DeleteMin(H); <span class="comment">/* 最小堆中最后一个元素即是指向哈夫曼树根结点的指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，Huffman 算法的时间复杂度为 O(NlogN)。</p>
<p>哈夫曼树的特点：</p>
<ul>
<li><p>没有度为 1 的结点；</p>
</li>
<li><p>n 个叶子结点的哈夫曼树共有 2n-1 个结点；</p>
</li>
<li><p>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树；</p>
</li>
<li><p>对于同一组权值，存在不同构的两颗哈夫曼树。<br>如权值{1,2,3,3}，不同构的两颗哈夫曼树如下：</p>


</li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>问题：给定一段字符串，如何对其中的字符进行编码，使得该字符串的编码存储空间最少？当然从存储空间取出的编码必须通过对应的解码才能还原出字符串。</p>
<p>上述问题的最优解决方法是哈夫曼提出的，按他给出的算法得到的编码就称为“哈夫曼编码”，是进行文件压缩的有效方法，其压缩比通常在 20% 到 90%。</p>
<p>可见的 ASCII 字符大约有一百个左右，加上部分不可见字符，可以用 7 位来识别它们，再加上 1 位校验码，所以一般用 8 位即一个字节来表示一个字符。但在一般的文本中每个字符出现的频率是不同的，且差异较大，通常只是少量不同字符在大量重复出现，用 8 位来存储每个字符是比较浪费的。</p>
<p>假设有一段文本，包含 58 个字符，并由以下 7 个字符构成：a,e,i,s,t,空格(sp),换行(nl)；这 7 个字符出现的次数不同。如何对这 7 个字符进行编码，使得总编码空间最少。</p>
<p>分析：</p>
<ul>
<li><p>采用等长 ASCII 编码：58x8 = 464 位；</p>
</li>
<li><p>仔细分析里面只有 7 个字符是不同的，因此我们完全可以用等长 3 位编码来识别它们。例如可令 a=000,e=001,i=010,s=011,t=100,sp=101,nl=110。这时空间为 58x3 = 174 位；</p>
</li>
<li><p>采用不等长编码：出现频率高的字符用的编码短些，出现频率低的字符则可以编码长些。</p>
</li>
</ul>
<p>因此我们需要解决两个问题：怎么进行不等长编码？如何避免编码的二义性？</p>
<p>不等长编码实际上就是根据字符出现的概率进行编码。</p>
<blockquote>
<p>定义 前缀码：任何字符的编码都不是另一个字符编码的前缀。</p>
</blockquote>
<p>为了避免二义性，所有字符都有应该在二叉树的叶结点上，哈夫曼编码也称为前缀编码。</p>
<p>因此采用哈夫曼树的生成方法可以满足以上要求。</p>


<h2 id="集合及其运算"><a href="#集合及其运算" class="headerlink" title="集合及其运算"></a>集合及其运算</h2><p>集合是一种常用的数据表示方法。集合的运算包括交、并、补、差以及判定一个数据是否是某一集合中的元素。</p>
<p>为了有效地对集合执行各种操作，可以用树结构表示集合，树的每个结点代表一个集合元素。</p>


<p>我们也可以采用数据形式存储集合，数组的每一项是一个结构体，结构体里面是元素值，以及其父元素对应的数组下标，负数代表根节点，非负数代表其父元素的数组下标。</p>


<p>因此可以定义如下结构体来表示集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000    <span class="comment">/* 集合的最大容量 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="keyword">int</span> Parent;</span><br><span class="line">&#125; SetType;</span><br></pre></td></tr></table></figure>

<p>1.查找元素所在集合（用根结点表示）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(SetType S[], ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 在数组 S 中查找值位 X 的元素所属集合</span></span><br><span class="line"><span class="comment">       MAXSIZE 为数组 S 的最大长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MAXSIZE &amp;&amp; S[i].Data!=X; i++);</span><br><span class="line">    <span class="keyword">if</span>(i==MAXSIZE)  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* 未找到 X，返回 -1 */</span></span><br><span class="line">    <span class="comment">/* 找到 X，则查找其父结点，直到父结点为负数 */</span></span><br><span class="line">    <span class="keyword">for</span>(; S[i].Parent&gt;=<span class="number">0</span>; i=S[i].Parent);</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">/* 找到 X 所属集合，返回根结点在数组 S 中的下标 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.集合的并运算</p>
<ul>
<li><p>分别找到 X1 和 X2 两个元素所在集合树的根结点</p>
</li>
<li><p>如果它们根结点不同，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[], ElementType X1, ElementType X2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Root1 = Find(S,X1);</span><br><span class="line">    <span class="keyword">int</span> Root2 = Find(S,X2);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2) S[Root1].Parent = Root2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们进行两个集合的合并时，我们希望合并后的集合树的深度尽可能小，这样才能提高查找效率。因此如果每次合并都能比较以下树的高矮，将矮树合并到高树上，这样就能有良好的查找效率。</p>
<p>当然要做到这一点，我们需要知道每个集合的树的高度，而这并不是很容易做到。比较容易获得的是集合当前的元素个数，用个数替换高度也可以起到比较好的作用。这种按照规模或者按照高度合并的算法，统称为按“秩”合并。</p>
<p>因此我们可以把对应集合的树的总结点数存在根结点单元里，同时在它前面加上符号。因此对上面的代码进行改写之后有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[], ElementType X1, ElementType X2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Root1 = Find(S,X1);</span><br><span class="line">    <span class="keyword">int</span> Root2 = Find(S,X2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)&#123;</span><br><span class="line">        <span class="comment">/* 将元素少的集合合并到元素多的集合中，集合中元素个数用的负数表示 */</span></span><br><span class="line">        <span class="keyword">if</span>(S[Root1].Data &gt; S[Root2].Data) &#123;</span><br><span class="line">            S[Root1].Parent = Root2;</span><br><span class="line">            S[Root2].Data += S[Root1].Data; <span class="comment">/* 更新集合中元素个数 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            S[Root2].Parent = Root1;</span><br><span class="line">            S[Root1].Data += S[Root2].Data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%912/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%912/" class="post-title-link" itemprop="url">数据结构——树（中）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-14 20:48:52" itemprop="dateCreated datePublished" datetime="2019-12-14T20:48:52+08:00">2019-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:50:18" itemprop="dateModified" datetime="2020-09-23T16:50:18+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>查找问题可分为静态查找和动态查找，静态查找可以用二分查找算法，针对动态查找，数据应该如何组织呢？</p>
<!--- more --->

<h3 id="二叉搜索树的定义"><a href="#二叉搜索树的定义" class="headerlink" title="二叉搜索树的定义"></a>二叉搜索树的定义</h3><p>二叉搜索树（Binary Search Tree）也叫二叉排序树或二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。一个二叉搜索树是一颗二叉树，它可以为空，如果不为空，它将满足以下性质：</p>
<ul>
<li><p>非空左子树的所有值小于其根节点的值</p>
</li>
<li><p>非空右子树的所有值大于其根节点的值</p>
</li>
<li><p>左、右子树都是二叉搜索树</p>
</li>
</ul>
<p>由于二叉搜索树具有左小右大的特点，因此对它进行中序遍历，将得到一个从小到大的输出序列。</p>
<h3 id="二叉搜索树的动态查找"><a href="#二叉搜索树的动态查找" class="headerlink" title="二叉搜索树的动态查找"></a>二叉搜索树的动态查找</h3><p>二叉搜索树的抽象数据结构定义与普通二叉树基本相同，只是多个以下几个特别的函数：</p>
<p>1.<code>Position Find(BinTree BST, ElementType X)</code>：从二叉搜索树 BST 中查找元素 X，并返回其地址；</p>
<p>2.<code>Position FindMin(BinTree BST)</code>：查找并返回最小值的地址；</p>
<p>3.<code>Position FindMax(BinTree BST)</code>：查找并返回最大值的地址。</p>
<h4 id="二叉搜索树的查找操作-Find"><a href="#二叉搜索树的查找操作-Find" class="headerlink" title="二叉搜索树的查找操作 Find"></a>二叉搜索树的查找操作 Find</h4><p>1.查找从根节点开始，如果树为空返回 NULL，表示未找到</p>
<p>2.如果不为空，则将根节点与 X 进行比较，根据比较结果进行不同的处理：</p>
<ul>
<li>若 X 大于根节点的值，则在右子树中查找</li>
<li>若 X 小于根节点的值，则在左子树中查找</li>
<li>相等表示找到了，返回此结点</li>
</ul>
<p>以下是找到的递归算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* 查找失败 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(BST-&gt;Right,X);  <span class="comment">/* 右子树中递归查找 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(BST-&gt;Left,X);   <span class="comment">/* 左子树中递归查找 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;                 <span class="comment">/* 查找成功 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是查找的非递归算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BinTree T = BST;</span><br><span class="line">    <span class="keyword">while</span>(T) &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; T-&gt;Data)</span><br><span class="line">            T = T-&gt;Right;       <span class="comment">/* 在右子树中查找 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;Data)</span><br><span class="line">            T = T-&gt;Left;        <span class="comment">/* 在左子树中查找 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找最大值和最小值"><a href="#查找最大值和最小值" class="headerlink" title="查找最大值和最小值"></a>查找最大值和最小值</h4><p>根据二叉搜索树的性质，最小值一定在二叉搜索树的最左分支的端点上，而最大值一定在最右分支的端点上。</p>
<p>以下是分别使用递归算法和非递归算法实现的查找最大值和最小值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(BinTree BST)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;               <span class="comment">/* 空二叉树返回NULL */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right) <span class="keyword">return</span> BST;    <span class="comment">/* 找到最右端点并返回 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> FindMax(BST-&gt;Right);    <span class="comment">/* 右子树递归查找 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(BinTree BST)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(BST-&gt;Left)</span><br><span class="line">        BST = BST-&gt;Left;    <span class="comment">/* 沿左分支一直向下，直到最左端点 */</span></span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><p>将元素 X 插入二叉搜索树 BST 中关键是找到元素插入的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">(BinTree BST,ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) &#123;</span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Insert(BST-&gt;Right,X);  <span class="comment">/* 递归插入右子树 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Insert(BST-&gt;Left,X);    <span class="comment">/* 递归插入左子树 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><p>考虑三种情况：</p>
<ul>
<li><p>要删除的是叶结点：直接删除，并修改其父节点指针——置为 NULL</p>

</li>
<li><p>要删除的结点只有一个孩子节点：将其父节点的指针指向要删除结点的孩子节点</p>

</li>
<li><p>要删除结点有左、右两颗子树：用另一结点替换被删除结点：右子树中最小元素 或 左子树中最大元素</p>


</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class="line">    Position tmp;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;Right,X);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Delete(BST-&gt;Left,X);</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">/* 找到了要删除的结点 */</span></span><br><span class="line">            <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;   <span class="comment">/* 被删除结点有左右两个儿子 */</span></span><br><span class="line">                <span class="comment">/* 两种方法1.左子树中找最大的替换该结点 2.右子树中找最小的替换该结点 */</span></span><br><span class="line">                tmp = FindMin(BST-&gt;Right)</span><br><span class="line">                BST-&gt;Data = tmp-&gt;Data;</span><br><span class="line">                BST-&gt;Right = Delete(BST-&gt;Right,BST-&gt;Data);  <span class="comment">/* 在删除结点的右子树中删除该最小元素 */</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* 被删除结点有一个或无子节点 */</span></span><br><span class="line">                tmp = BST;</span><br><span class="line">                <span class="keyword">if</span>(!BST-&gt;Left)          <span class="comment">/* 有右孩子或者无子节点 */</span></span><br><span class="line">                    BST = BST-&gt;Right;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)    <span class="comment">/* 有左孩子或者无子节点 */</span>  </span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>对于二叉搜索树进行查找的时间复杂度是由是由查找过程中的比较次数来衡量的，比较是从根结点到叶结点的路径进行的，它取决于树的深度。树深在最好情况下是 logN，所以二叉搜索树在最好情况的查找复杂度是 O(logN)。但这一结论是由完全二叉树导出的，事实上 N 个结点的二叉树深度取决于其树枝的分布情况。当二叉树退化为一颗单枝树的极端情况下，查找时间复杂度将是线性的 O(N)。</p>
<p>假定二叉树中每个结点的查找概率都是相同的，我们称查找所有结点的比较次数的平均值为树的“平均查找长度”(Average Search Length,ASL)。如下图所示，可以得到各二叉树的平均查找长度：</p>


<p>上述示例表明，一棵树的 ASL 值越小，它的结构越好，与完全二叉树越接近，对它的查找时间复杂度也越接近 O(logN)。因此为了保证二叉树查找的对数级查找时间效率。设计出了平衡二叉树这一数据结构。</p>
<h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><p>平衡二叉树又称 AVL 树，它也是一颗二叉搜索树。</p>
<blockquote>
<p>定义：AVL树是一颗空树或者是具有以下性质的非空二叉搜索树：<br>1.任一结点的左右子树均为 AVL 树；<br>2.根结点左右子树的高度差的绝对值不超过 1。</p>
</blockquote>


<blockquote>
<p>定义：对于二叉树中的任一结点 T，其平衡因子（Balance Factor，BF）定义为 BF(T) = hL - hR，其中 hL 和 hR 分别为左右子树的高度。</p>
</blockquote>
<p>因此根结点左右子树的高度差的绝对值不超过 1 可以量化为 |BF(T)| &lt;= 1。</p>
<p>设高度（边的长度）为 h 的平衡二叉树的最少结点数为 nh，则有：</p>
<p>h = 0,   n0 = 1<br>h = 1,   n1 = 2<br>h = 2,   n2 = 4<br>h = 3,   n3 = 7<br>…</p>
<p>依次类推可以得到：nh = n(h-1) + n(h-2) + 1；</p>
<p>求高度（边的长度）为 h 的平衡二叉树的最少结点数要么左边少一层要么右边少一层，因此高度（边的长度）为 h 的平衡二叉树的最少结点数 nh 等于高度（边的长度）为 h-1 的平衡二叉树的最少结点数 + 高度（边的长度）为 h-2 的平衡二叉树的最少结点数。</p>


<h3 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h3><p>1.右单旋</p>


<p>2.左单旋</p>


<p>3.左-右双旋</p>


<p>4.右-左双旋</p>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%91/" class="post-title-link" itemprop="url">数据结构——树（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-13 14:20:00" itemprop="dateCreated datePublished" datetime="2019-12-13T14:20:00+08:00">2019-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:50:09" itemprop="dateModified" datetime="2020-09-23T16:50:09+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树（Tree）是由 n 个结点构成的有限集合。当 n=0 时，称为空树；对于任意一颗非空树，它具备以下特征：</p>
<ul>
<li>树中有一个称为根的特殊节点，用 r 表示；</li>
<li>其余结点可分为 m 个互不相交的有限集 T1,T2,…,Tm，其中的每个集合本身又是一棵树，称为原来树的子树。</li>
</ul>
<!--- more --->

<p>树的特点：</p>
<ul>
<li>子树是不相交的；</li>
<li>除了根节点外，每个结点有且仅有一个父节点；</li>
<li>一颗 N 个结点的树有 N-1 条边。</li>
</ul>
<p>树的一些基本术语：</p>
<p>1.<strong>结点的度</strong>（Degree）：结点的子树个数<br>2.<strong>树的度</strong>：树的所有结点中最大的度数<br>3.<strong>叶结点</strong>（Leaf）：度为 0 的结点<br>4.<strong>父节点</strong>（Parent）：有子树的结点是其子树的根结点的父节点<br>5.<strong>子节点</strong>（Child）：若 A 结点是 B 结点的父节点，则称 B 结点是 A 结点的子节点；子节点也称孩子结点<br>6.<strong>兄弟节点</strong>（Sibling）：具有同一父节点的各节点彼此是兄弟节点<br>7.<strong>结点的层次</strong>（Level）：规定根节点在 1 层，其它任一结点的层次是其父节点层数加1<br>7.<strong>树的深度</strong>（Depth）：树中所有结点中的最大层次是这棵树的深度</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是一个有穷的结点集合。这个集合可以为空，若不为空，则它是由根节点和称为其左子树和右子树的两个互不相交的二叉树组成。一般来讲二叉树有以下 5 种基本形态：</p>


<p>需要注意的是二叉树的子树有左右顺序之分。</p>
<p>特殊的二叉树：</p>
<ul>
<li>斜二叉树</li>
<li>完美二叉树或满二叉树</li>
<li>完全二叉树</li>
</ul>


<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul>
<li>二叉树第 i 层的最大结点数为 2^(i-1), i&gt;= 1</li>
<li>深度为 k 的二叉树有最大结点数 2^k - 1, k&gt;=1</li>
<li>对任何非空的二叉树，若 n0 表示叶结点个数、n2 是度为 2 的非叶结点个数，则有 n0 = n2 + 1。<br>以下是证明：<br>设 n1 表示度为 1 的结点个数，则二叉树的总结点个数为 n0 + n1 + n2;<br>二叉树的边数为 2<em>n2 + n1，总结点数等于边数 + 1；<br>因此：n0 + n1 + n2 = 2</em>n2 + n1 + 1<br>所以 n0 = n2 + 1。</li>
</ul>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>1.顺序存储</p>
<p><strong>完全二叉树</strong>：按从上到下，从左到右顺序存储 n 个结点的完全二叉树的结点父子关系</p>
<ul>
<li>非根节点的父节点的序号是 [i/2];</li>
<li>结点为 i 的左孩子结点序号为 2i；</li>
<li>结点为 i 的右孩子结点序号为 2i+1;</li>
</ul>
 

<p>一般二叉树如果采用这种结构可能造成极大的空间浪费，因此可采用链式存储结构。</p>
<p>2.链式存储</p>
<p>以下是二叉树的链式存储结构示意图：</p>


<p>因此可以用以下代码来表示如上结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">BinTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><p>1.先序遍历</p>
<p>遍历过程为：</p>
<ul>
<li>访问根节点</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ul>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.中序遍历</p>
<p>遍历过程为：</p>
<ul>
<li>中序遍历其左子树</li>
<li>访问根节点</li>
<li>中序遍历其右子树</li>
</ul>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.后序遍历</p>
<p>遍历过程为：</p>
<ul>
<li>后序遍历其左子树</li>
<li>后序遍历其右子树</li>
<li>访问根节点</li>
</ul>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序、中序、后序遍历过程：遍历过程中经过结点的路线一样，只是访问各节点的时机不同。先序是第一次经过该结点就访问，中序是第二次经过该结点访问，后序是第三次经过该结点访问。</p>


<h3 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h3><p><strong>二叉树先序、中序、后序遍历的非递归算法实现的基本思路：使用堆栈。</strong></p>
<p>1.先序遍历的非递归算法</p>
<ul>
<li>遇到一个结点访问之，并将其压入堆栈，再去访问它的左子树</li>
<li>左子树遍历结束之后，从栈顶弹出一个结点</li>
<li>然后再去先序遍历弹出结点的右子树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MaxSize); <span class="comment">/* 初始化堆栈 */</span></span><br><span class="line">    <span class="keyword">while</span>(T || !Empty(S)) &#123; <span class="comment">/* 如果树不为空或者堆栈不为空 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(T) &#123;</span><br><span class="line">            <span class="comment">/* 遇到一个结点访问之，并将其压入堆栈，再去访问它的左子树 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;Data);</span><br><span class="line">            Push(S,T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!Empty(S)) &#123;</span><br><span class="line">            <span class="comment">/* 左子树遍历完之后，弹出栈顶元素，并遍历其右子树 */</span></span><br><span class="line">            T = Pop(S);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.中序遍历的非递归算法</p>
<ul>
<li>遇到一个结点将其压入堆栈，并去访问它的左子树</li>
<li>当左子树遍历结束之后，从栈顶弹出这个结点并访问它</li>
<li>然后再去中序遍历弹出结点的右子树。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MaxSize); <span class="comment">/* 初始化堆栈 */</span></span><br><span class="line">    <span class="keyword">while</span>(T || !Empty(S)) &#123; <span class="comment">/* 如果树不为空或者堆栈不为空 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(T) &#123;</span><br><span class="line">            <span class="comment">/* 遇到一个结点将其压入堆栈并去访问它的左子树 */</span></span><br><span class="line">            Push(S,T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!Empty(S)) &#123;</span><br><span class="line">            <span class="comment">/* 左子树遍历完之后，弹出栈顶元素，并访问其右子树 */</span></span><br><span class="line">            T = Pop(S);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;Data);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.后序遍历的非递归算法</p>
<ul>
<li>遇到一个节点将其压入堆栈，再访问它的左子树</li>
<li>左子树遍历结束之后，弹出栈顶结点<br>如果该结点有右节点且右节点还未被打印出栈，将该结点再次压入堆栈，后序遍历该结点的右子树<br>如果该结点没有右结点或者该结点的右结点被访问过了，则访问该结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(Bintree BT)</span> </span>&#123;</span><br><span class="line">    Bintree T = BT;</span><br><span class="line">    Bintree PrintedRT = <span class="literal">NULL</span>;<span class="comment">//上一个被打印出的右节点</span></span><br><span class="line">    Stack S = CreateStack(Maxsize);</span><br><span class="line">    <span class="keyword">while</span> (T || !IsEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (T) &#123;</span><br><span class="line">            Push(S, T);</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!IsEmpty(S)) &#123;</span><br><span class="line">            T = Pop(s);</span><br><span class="line">            <span class="keyword">if</span> ((T-&gt; Right== <span class="literal">NULL</span>)||(T-&gt;Right == PrintedRT)) &#123;    <span class="comment">//右节点为空 或 右节点已经出栈</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class="line">                PrintedRT = T; <span class="comment">//记录“上一个被打印出的右节点”</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//有右节点且右节点还未被打印出栈</span></span><br><span class="line">                Push(S, T);  <span class="comment">//因为当前节点已经出栈，但右儿子节点还未先出栈，所以先把他压进去</span></span><br><span class="line">                T = T-&gt;Right;  <span class="comment">//转向右子树，进入下一次循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.二叉树的层序遍历</p>
<p><strong>二叉树的层序遍历的关键是使用 队列。</strong></p>
<ul>
<li>根结点入队</li>
<li>如果队列不为空，从中取出一个元素，并访问之，将其左右儿子顺序入队</li>
<li>重复第二步</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Queue Q = CreateQueue(MaxSize);</span><br><span class="line"></span><br><span class="line">    AddQ(Q,T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Empty(Q)) &#123;</span><br><span class="line">        T = DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left) AddQ(Q,T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right) AddQ(Q,T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历二叉树的应用"><a href="#遍历二叉树的应用" class="headerlink" title="遍历二叉树的应用"></a>遍历二叉树的应用</h3><p>1.输出所有叶子结点</p>
<p>核心：叶子节点的左右儿子都为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="keyword">if</span>(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.求二叉树的高度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> HL,HR,MaxH;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        HL = getHeight(BT-&gt;Left);</span><br><span class="line">        HR = getHeight(BT-&gt;Right);</span><br><span class="line">        MaxH = HL &gt; HR ? HL : HR;</span><br><span class="line">        <span class="keyword">return</span> MaxH + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.由两种遍历确定一颗二叉树</p>
<p><strong>由先序和中序遍历序列、后序和中序遍历序列可以唯一确定一棵二叉树。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构——线性结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-11 15:11:34" itemprop="dateCreated datePublished" datetime="2019-12-11T15:11:34+08:00">2019-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:50:42" itemprop="dateModified" datetime="2020-09-23T16:50:42+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线性结构介绍线性表的抽象定义，并分别讨论基于顺序存储和链式存储的线性表的实现方法。同时将介绍两种典型且应用广泛的线性表：堆栈和队列。</p>
<p>线性表的基本操作是插入和删除，堆栈是插入和删除只发生在同一端的线性表，而队列的插入和删除则分别发生在有序序列的两端，即一端只做插入，一端只做删除。</p>
<!--- more --->

<h2 id="线性表的定义与实现"><a href="#线性表的定义与实现" class="headerlink" title="线性表的定义与实现"></a>线性表的定义与实现</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表(Linear List)是由同一类型的元素构成的有序序列的线性结构。线性表的抽象数据描述为：</p>
<p><strong>类型名称</strong>：线性表(List)</p>
<p><strong>数据对象集</strong>: 线性表是由 n 个元素构成的有序序列。</p>
<p><strong>操作集</strong>： 线性表 L∈List，整数 i 表示位置，元素 X∈ElementType，线性表的主要操作有：</p>
<ol>
<li><p><code>List MakeEmpty()</code>：初始化一个空的线性表；</p>
</li>
<li><p><code>ElementType FindKth(List L,int i)</code>：根据位序 i 返回相应元素；</p>
</li>
<li><p><code>Position Find(List L,ElementType X)</code>：在线性表 L 中查找 X 第一次出现的位置；</p>
</li>
<li><p><code>bool Insert(List L,ElementType X,int i)</code>：在 L 的指定位序 i 之前插入一个新元素 X；</p>
</li>
<li><p><code>bool Delete(List L, int i)</code>：从 L 中删除指定位序 i 的元素；</p>
</li>
<li><p><code>int Length(List L)</code>：返回线性表 L 的长度。</p>
</li>
</ol>
<h3 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h3><p>线性表的顺序存储是指在内存中用地址连续的一块存储空间顺序存放线性表的各元素。因此可以用一维数组来表示顺序存储的数据区域。</p>
<p>考虑到线性表的运算有插入、删除操作，即表的长度是动态变化的，因此数组的容量需要设计得足够大，可以根据实际情况来定义一个 MAXSIZE 表示数组的最大容量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000            <span class="comment">/* 线性表的最大容量 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;        <span class="comment">/* 线性表中数据类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;           <span class="comment">/* 线性表中每个位置类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">PtrToLNode</span>;</span>   <span class="comment">/* 定义指向线性表每个结点的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;            <span class="comment">/* 定义线性表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    L-&gt;Last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">(List L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; L-&gt;Last || i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无该元素&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> L-&gt;Data[i];</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L,ElementType X)</span> </span>&#123;</span><br><span class="line">    Position i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; L-&gt;Last) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L,ElementType X, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 在 L 的指定位序 i 前插入一个元素，位序 i 的元素数组下标为 i ，需要把i之后的元素全部后移一位*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last == MAXSIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线性表已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L-&gt;Last + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Position j;</span><br><span class="line">    <span class="keyword">for</span>(j = L-&gt;Last+<span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">        L-&gt;Data[j] = L-&gt;Data[j<span class="number">-1</span>];</span><br><span class="line">    L-&gt;Data[j] = X;</span><br><span class="line">    L-&gt;Last ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除位序为i的元素，对应数组下标为i ，需要把i之后的元素全部前移一位*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线性表为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; L-&gt;Last) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Position j;</span><br><span class="line">    <span class="keyword">for</span>(j=i; j&lt;L-&gt;Last; j++)</span><br><span class="line">        L-&gt;Data[j] = L-&gt;Data[j+<span class="number">1</span>];</span><br><span class="line">    L-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;Last + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知顺序表的删除或插入操作的时间复杂度为 O(N)，查找第 i 个元素的时间复杂度为 O(1)。</p>
<h3 id="线性表的链式存储实现"><a href="#线性表的链式存储实现" class="headerlink" title="线性表的链式存储实现"></a>线性表的链式存储实现</h3><p>为提高线性表的插入或删除效率，可以使用链式存储结构即链表，它不需要用连续的地址来存储单元，它是通过”链”建立起数据元素之间的逻辑关系，因此对链表的插入或删除操作不需要移动元素，只需要修改”链”。</p>


<p>因此链表的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR NULL;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;   <span class="comment">/* 链表每个结点的数据项 */</span></span><br><span class="line">    PtrToLNode Next;    <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br></pre></td></tr></table></figure>

<p>链表名即链表第一个结点的指针。</p>
<p>1.求表长<br>在顺序表中求表长是一件很容易的事，但是在链表里面，我们需要将整个链表遍历一遍，使用一个指向链表头的指针，从前往后移动，再使用计数器count记录移动次数，直到链表结束为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">    PtrToLNode p = L;   <span class="comment">/* 指向链表头 */</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PtrToLNode <span class="title">FindKth</span><span class="params">(List L, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 查找位序为 k 的元素 */</span></span><br><span class="line">    PtrToLNode p = L;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">/* 位序从0开始 */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count &lt; K) &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p &amp;&amp; (count == K))</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L, ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 查找X在链表中的位置 */</span></span><br><span class="line">    Position p = L;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;Data != X)</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找的时间复杂度为 O(N)。</p>
<p>3.插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L, ElementType X, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 在第i个结点前插入一个结点 */</span></span><br><span class="line">    PtrToLNode p ,s;</span><br><span class="line">    <span class="comment">// 如果插入结点在表头</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        s = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则找到第 i 个结点的前一个结点</span></span><br><span class="line">    p = FindKth(L,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在上述的实现中我们将表头插入作为一种特殊的情况处理，为避免这种情况我们一般为链表增加一个空的“头结点”，真正的元素链接在这个空结点之后。这样做的好处是无论在哪里删除，L 的值一直指向固定的空结点。</p>
<p>因此需要理解以下三个概念：</p>
<ul>
<li>头结点：链表首元结点前的一个空结点。</li>
<li>首元结点：链表中存储线性表中第一个数据元素的结点。</li>
<li>头指针：指向链表中第一个结点（或为头结点或为首元结点）的指针。</li>
</ul>
<p>假设链表有头结点，则插入操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L, ElementType X, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 假设链表有头结点，在第i个结点前插入一个结点 */</span></span><br><span class="line">    PtrToLNode p ,s;</span><br><span class="line">    <span class="comment">// 找到第 i 个结点的前一个结点</span></span><br><span class="line">    p = FindKth(L,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.删除<br>这里假设链表有头结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除第i个结点 */</span></span><br><span class="line">    PtrToLNode p,tmp;</span><br><span class="line">    p = FindKth(L,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p-&gt;Next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除位置参数错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = tmp-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表的插入和删除操作其时间复杂度也为 O(N)。</p>
<h2 id="堆栈的定义与实现"><a href="#堆栈的定义与实现" class="headerlink" title="堆栈的定义与实现"></a>堆栈的定义与实现</h2><p>思考：计算机如何进行表达式求值？</p>
<ul>
<li>中缀表达式：运算符号位于两个运算数之间，如 a + b*c - d/e</li>
<li>后缀表达式：运算符位于两个运算数之后，如 a b c * + d e / -</li>
</ul>
<p>计算机首先将中缀表达式转换成对应的后缀表达式，然后对后缀表达式进行求值，因此这里有两个问题，如何将中缀表达式转换成后缀表达式？如何对后缀表达式进行求值？</p>
<p>例如：求后缀表达式 6 2 / 3 - 4 2 * + 的值。</p>
<p>策略：从左向右扫描，遇到运算数，先存放起来，遇到运算符计算刚刚存放的两个元素的值（即后进先出），再将值存放起来。</p>
<p>因此这就要利用堆栈进行求值。</p>
<h3 id="堆栈的定义"><a href="#堆栈的定义" class="headerlink" title="堆栈的定义"></a>堆栈的定义</h3><p>堆栈(Stack)可以认为是具有一定约束的线性表，插入和删除操作作用在一个称为栈顶(Top)的端点位置。正是堆栈所具有的这种特性，通常把数据插入称为入栈(Push)，数据删除操作称为出栈(Pop)。</p>
<p>也正是由于这一特性，最后入栈的数据将会被最先弹出，所以堆栈也叫后入先出(Last In First Out,LIFO)表。</p>
<p>堆栈的抽象数据定义为：</p>
<p><strong>类型名称</strong>：堆栈(Stack)。</p>
<p><strong>数据对象集</strong>：一个有0个或多个元素的有穷线性表。</p>
<p><strong>操作集</strong>：对于一个具体长度为正整数 MaxSize 的堆栈 S∈Stack，记栈中的任一元素 X∈ElementType，堆栈的基本操作有：</p>
<ol>
<li><p><code>Stack CreateStack(int MaxSize)</code>：创建一个最大长度为 MaxSize 的堆栈；</p>
</li>
<li><p><code>bool IsFull(Stack S)</code>：检查堆栈是否已满；</p>
</li>
<li><p><code>bool Push(Stack S, ElementType X)</code>：将 X 入栈；</p>
</li>
<li><p><code>bool IsEmpty(Stack S)</code>：检查堆栈是否为空；</p>
</li>
<li><p><code>ElementType Pop(Stack S)</code>：弹出栈顶元素。</p>
</li>
</ol>


<h3 id="堆栈的顺序存储实现"><a href="#堆栈的顺序存储实现" class="headerlink" title="堆栈的顺序存储实现"></a>堆栈的顺序存储实现</h3><p>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成，另外我们还需要知道栈的最大容量，这样方便我们判断栈什么时候是满的。因此栈的顺序存储结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>* <span class="title">PtrToSNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;  <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    Position Top;            <span class="comment">/* 栈顶指针 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;        <span class="comment">/* 栈的最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br></pre></td></tr></table></figure>

<p>以下是创建一个空堆栈的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="keyword">int</span> MaxSize)</span> </span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    S-&gt;Data = (ElementType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType)*MaxSize);</span><br><span class="line">    S-&gt;MaxSize = MaxSize;</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Top == S-&gt;MaxSize<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(S))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        S-&gt;Data[++(S-&gt;Top)] = X;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;       <span class="comment">/* 特殊值，标记错误 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> S-&gt;Data[(S-&gt;Top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆栈的链式存储实现"><a href="#堆栈的链式存储实现" class="headerlink" title="堆栈的链式存储实现"></a>堆栈的链式存储实现</h3><p>栈的链式存储结构实际上就是一个单链表，插入和删除只能在链栈的栈顶进行。栈顶指针 Top 指向链表头，删除和插入操作都在链表头部进行，因为在尾部无法进行删除操作。</p>
<p>因此为了简便算法，<strong>为链栈增加一个空的头结点</strong>。因此其实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PtrToSNode node = (PtrToSNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    node-&gt;Data = X;</span><br><span class="line">    node -&gt; Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PtrToSNode temp = S-&gt;Next;</span><br><span class="line">        X = temp-&gt;Data;</span><br><span class="line">        S-&gt;Next = temp-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆栈的应用"><a href="#堆栈的应用" class="headerlink" title="堆栈的应用"></a>堆栈的应用</h3><p>前面提到的问题我们解决了后一部分，接下来解决如何将中缀表达式转为后缀表达式？</p>
<p>算法描述：</p>
<p>从头到尾读取中缀表达式的每个元素，对不同元素按照不同情况进行处理：</p>
<p>1.运算数： 直接输出</p>
<p>2.左括号： 入栈</p>
<p>3.右括号： 将栈顶元素弹出并输出，直到遇见左括号（出栈，不输出）</p>
<p>4.运算符： 若运算符的优先级大于栈顶符号优先级，则入栈；</p>
<p>若运算符号优先级小于栈顶符号优先级，则将栈顶符号出栈并输出；再比较新的栈顶符号，直到新的栈顶符号优先级小于该运算符优先级为止，然后将该运算符入栈</p>
<p>5.所有元素处理完毕，则把堆栈中存留的运算符一并输出。</p>
<h2 id="队列的定义与实现"><a href="#队列的定义与实现" class="headerlink" title="队列的定义与实现"></a>队列的定义与实现</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>多个数据构成一个有序序列，而对这个序列的操作有一定要求：只能在一端插入，另一端删除，这样的数据组织方式就是“队列”，队列具有先进先出（First In First Out,FIFO）的特点队列(Queue)也是一个有序线性表。</p>
<p>队列的抽象数据类型定义为：</p>
<p><strong>类型名称</strong>：队列(Queue)。</p>
<p><strong>数据对象集</strong>：有一个或多个元素的有穷线性表。</p>
<p><strong>操作集</strong>：对于一个长度为正整数 MaxSize 的队列 Q∈Queue，记队列中的任一元素 X∈ElementType，队列的基本操作有：</p>
<p>1.<code>Queue CreateQueue(int MaxSize)</code>：生成最大长度为 MaxSize 的空队列；</p>
<p>2.<code>bool IsFull(Queue Q)</code>：判断队列是否已满；</p>
<p>3.<code>bool AddQ(Queue Q, ElementType X)</code>：将元素 X 压入队列；</p>
<p>4.<code>bool IsEmpty(Queue Q)</code>：判断队列是否为空；</p>
<p>5.<code>ElementType DeleteQ(Queue Q)</code>：删除并返回队列头元素。</p>
<h3 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h3><p>为了充分利用数组空间，一般在队列的顺序存储结构中采用循环队列的方式。</p>
<p>当队列头 Front 和 队列尾 Rear 相等时，我们无法判断队列是空的还是满的。其根本原因是 Rear 和 Front 的差值最多有 n 种情况（n为数组的大小），而队列元素的个数却又 n+1 种（0,1,2,…,n），所以仅依靠 Front 和 Raer 是无法区分这 n+1 种情况的。</p>
<p>因此我们有两种解决方法：</p>
<p>1.设置一个从额外标记记录最后一次操作是入队还是出队。如果是入队导致 Front==Rear 说明队列满，如果是出队导致 Front==Rear 说明队列空<br>2.仅使用 n-1 个数组空间，如下图所示表示队列满，因此队列满的条件是 (Rear+1)%数组长度等于Front 。队列空的条件依然是 Front== Rear。</p>


<p>使用第二种方法来实现循环队列，因此队列的顺序存储实现结构可以是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">PtrToQNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    ElementType* Data;      <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    Position Front,Rear;    <span class="comment">/* 队列的头尾指针 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;            <span class="comment">/* 队列的最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToQNode Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">(<span class="keyword">int</span> MaxSize)</span> </span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType)*MaxSize);</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="number">-1</span>;</span><br><span class="line">    Q-&gt;MaxSize = MaxSize;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q-&gt;Rear+<span class="number">1</span>)%(Q-&gt;MaxSize) == Q-&gt;Front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddQ</span><span class="params">(Queue Q, ElementType X)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(IsFull(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;Rear = (Q-&gt;Rear+<span class="number">1</span>)%(Q-&gt;MaxSize);</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;Front == Q-&gt;Rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(Q)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;Front = (Q-&gt;Front+<span class="number">1</span>)%Q-&gt;MaxSize;</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h3><p>队列的链式存储结构也可以用一个单链表来实现。插入和删除操作分别在链表的两头进行：<strong>队列的 front 和 rear 应该分别指向链表的哪一头？</strong></p>
<p>由于在链表尾部无法进行删除操作，因此删除操作在链表头部，插入操作在链表尾部，所以 front 指向链表头部，rear 指向链表尾部。</p>


<p>因此其不带头结点的链式队列可以定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    Position rear;</span><br><span class="line">    Position front;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">Queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddQ</span><span class="params">(Queue Q, ElementType X)</span> </span>&#123;</span><br><span class="line">    PtrToNode node = (PtrToNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    node-&gt;Data = X;</span><br><span class="line">    node-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;Next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PtrToNode node = Q-&gt;front;</span><br><span class="line">        ElementType temp = node-&gt;Data;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear) <span class="comment">/* 如果队列只有一个元素 */</span></span><br><span class="line">            Q-&gt;front = Q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Q-&gt;front = Q-&gt;front-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/11/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-6/" class="post-title-link" itemprop="url">Java 多态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 18:56:24" itemprop="dateCreated datePublished" datetime="2019-11-23T18:56:24+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:54:29" itemprop="dateModified" datetime="2020-09-23T16:54:29+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一个变量对象可以指示多种实际类型的现象称为多态。在运行时能够自动选择调用哪个方法的现象称为自动绑定。</p>
<p>以下我们定义两个类 Employee 类和其子类 Manager 类。</p>
<!--- more --->

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Employee类为员工类，其含有姓名，薪水，雇佣日期这些成员变量</span></span><br><span class="line"><span class="comment">    * 有获取姓名、薪水、雇佣日期的方法</span></span><br><span class="line"><span class="comment">    * 同时还有涨工资的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Manager类为经理类，其继承员工类，除了员工的基本工资以外，经理还有奖金</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, month, day);</span><br><span class="line">        <span class="keyword">this</span>.bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Manager boss = <span class="keyword">new</span> Manager(<span class="string">&quot;Sillywa&quot;</span>, <span class="number">6000</span>, <span class="number">2009</span>, <span class="number">12</span>, <span class="number">5</span>);</span><br><span class="line">        boss.setBonus(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">        staff[<span class="number">0</span>] = boss;</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;xin&quot;</span>, <span class="number">3000</span>, <span class="number">2012</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;yuan&quot;</span>, <span class="number">3000</span>, <span class="number">2012</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Employee e:staff) &#123;</span><br><span class="line">            System.out.println(e.getName() + <span class="string">&quot;:&quot;</span> + e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个 Employee 类型的数组，并且把 staff[0] 的类型设置为 Manager 类型，此时并没有报错。因为 Manager 类继承于 Employee 类，所以一个 Manager 类也是一个 Employee 类，这就是多态的典型例子。</p>
<p>换句话说，一个 Employee 变量既可以引用一个 Employee 类对象，也可以引用一个 Employee 类的任何一个子类的对象，如 Manager 对象。</p>
<p>在最后的遍历中，当 e 引用 Employee 类的对象时，e.getSalary() 调用的是 Employee 类中的 getSalary 方法；当 e 引用 Manager 对象时，e.getSalary() 调用的是 Manager 类中的 getSalary 方法。虚拟机知道 e 的实际引用的对象类型，因此能够正确调用相应的方法。</p>
<p>在上面例子中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manager boss = <span class="keyword">new</span> Manager(...);</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 staff[0] 与 boss 引用的同一个对象。但是编译器将 staff[0] 看成 Employee 对象。</p>
<p>这意味着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boss.setBonus(<span class="number">1000</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>但是不能这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">1000</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>这是因为 staff[0] 声明的类型是 Employee，而 setBonus 不是 Employee 类的方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sillywa.com/2019/11/21/K-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%94%B9%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Sillywa">
      <meta itemprop="description" content="个人学习记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sillywa's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/21/K-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%94%B9%E8%BF%9B/" class="post-title-link" itemprop="url">K-means算法的实现与改进</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-21 14:49:25" itemprop="dateCreated datePublished" datetime="2019-11-21T14:49:25+08:00">2019-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 16:54:35" itemprop="dateModified" datetime="2020-09-23T16:54:35+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文主要介绍了 K-means 算法的原理以及如何利用 python 去实现简单的 K-means 算法，然后对于 K-means 算法存在的一些问题进行了适当的改进。</p>
<!--- more --->

<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><h3 id="聚类的定义"><a href="#聚类的定义" class="headerlink" title="聚类的定义"></a>聚类的定义</h3><p>聚类就是对大量未标记的数据集，按照数据的内在相似性将数据集划分为多个类别，使同一类别内的数据相似性大而不同类别间的数据相似性小。聚类是典型的无监督学习。</p>
<h3 id="聚类的一般方法"><a href="#聚类的一般方法" class="headerlink" title="聚类的一般方法"></a>聚类的一般方法</h3><p>给定 N 个对象的数据集，将数据集划分为 k 个簇，k≤N，且满足：</p>
<ol>
<li><p>每个簇至少有一个对象</p>
</li>
<li><p>每个对象只能属于一个簇</p>
</li>
</ol>
<p>聚类既能作为一个单独过程，用于找寻数据的内在分布结构，也可以作为分类等其他任务的前驱过程。</p>
<h3 id="不同类型的聚类"><a href="#不同类型的聚类" class="headerlink" title="不同类型的聚类"></a>不同类型的聚类</h3><ol>
<li><p>原型聚类</p>
<p> 原型聚类也叫基于原型的聚类，此类算法假设聚类结构能够通过一组原型刻画，在现实聚类中极为常用。通常情况下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式将产生不同的算法。其中比较典型的就是k均值算法，也叫 K-menas 算法。</p>
</li>
<li><p>密度聚类</p>
<p> 密度聚类也叫基于密度的聚类，此类算法假设聚类结构能够通过样本的紧密程度确定。通常情况下，密度聚类算法从样本密度的角度来考察样本之间的可连接性，并基于可连接样本不断扩展聚类簇以获得最终的聚类结果。其中比较著名就是 DBSCAN 算法。</p>
</li>
<li><p>层次聚类</p>
<p> 层次聚类试图在不同层次对数据集进行划分，从而形成树型的聚类结构。数据集的划分可以采用“自底向上”的聚合策略，也可以采用“自顶向下”的分拆策略。</p>
</li>
<li><p>谱聚类</p>
<p> 谱聚类是一种基于图论的聚类方法，通过对样本数据的拉普拉斯矩阵的特征向量进行聚类，从而达到对样本数据聚类的目的。</p>
</li>
</ol>
<h2 id="K-means-算法原理"><a href="#K-means-算法原理" class="headerlink" title="K-means 算法原理"></a>K-means 算法原理</h2><p>首先随机选取 k 个对象，每个对象初始地代表了一个簇的平均值或中心，称为初始均值向量。对剩余的每个对象根据其与各个簇中心的距离，将它赋给最近的簇。然后重新计算每个簇的平均值得到新的均值向量。这个过程不断重复直到当前均值向量均保持不变。</p>
<p>算法描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">从 D 中随机选择 k 个样本作为初始均值向量</span><br><span class="line">repeat</span><br><span class="line">    for j&#x3D;1,2,…,m do</span><br><span class="line">        计算样本与各均值向量的距离</span><br><span class="line">        根据距离最近的均值向量确定样本的簇标记</span><br><span class="line">        将样本划入相应的簇</span><br><span class="line">    end for </span><br><span class="line">    for i&#x3D;1,2,…,k do</span><br><span class="line">        计算新的均值向量</span><br><span class="line">        if 两个均值向量不相同  then</span><br><span class="line">            更新均值向量</span><br><span class="line">        else</span><br><span class="line">            保持当前均值向量不变</span><br><span class="line">        end if</span><br><span class="line">    end for</span><br><span class="line">until 当前均值向量均未更新</span><br></pre></td></tr></table></figure>

<h2 id="K-means-算法实现"><a href="#K-means-算法实现" class="headerlink" title="K-means 算法实现"></a>K-means 算法实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmeans</span>:</span></span><br><span class="line">    __dataList = []</span><br><span class="line">    __k = <span class="number">1</span></span><br><span class="line">    __kSample = []</span><br><span class="line">    __count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,fileName,k</span>):</span></span><br><span class="line">        self.__dataList = self.__readData(fileName)</span><br><span class="line">        self.__kSample = self.__getKSample(self.__dataList,k)</span><br><span class="line">        self.__k = k</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始聚类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="comment">#计算每一个点与均值向量之间的距离,确定每一个点的类别</span></span><br><span class="line">            <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(self.__dataList):</span><br><span class="line">                self.__caculateType(self.__dataList[index],self.__kSample)</span><br><span class="line">            <span class="comment"># 保存均值向量的副本</span></span><br><span class="line">            copiedKSample = copy.deepcopy(self.__kSample)</span><br><span class="line">            <span class="comment"># 重新计算均值向量</span></span><br><span class="line">            self.__caculateKSampleByAverge(self.__kSample)</span><br><span class="line">            <span class="comment"># 如果两个均值向量相等，则循环停止</span></span><br><span class="line">            <span class="keyword">if</span> copiedKSample == self.__kSample:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.__count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 绘制散点图</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drawPic</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 由于是二维坐标，因此只需x，y即可</span></span><br><span class="line">        x = []</span><br><span class="line">        y = []</span><br><span class="line">        c = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.__dataList)):</span><br><span class="line">            x.append(self.__dataList[i][<span class="number">0</span>])</span><br><span class="line">            y.append(self.__dataList[i][<span class="number">1</span>])</span><br><span class="line">            c.append(self.__dataList[i][<span class="number">2</span>])</span><br><span class="line">        plt.title(<span class="string">&quot;dataset k=&quot;</span> + str(self.__k))</span><br><span class="line">        plt.scatter(x, y,c=c)</span><br><span class="line">        plt.show()</span><br><span class="line">    <span class="comment"># 获取迭代次数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCount</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__count</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从文件中读取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__readData</span>(<span class="params">self,fileName</span>):</span></span><br><span class="line">        <span class="comment"># 用存放数据的列表</span></span><br><span class="line">        dataList = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fp = open(fileName,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">            fpList = fp.read().splitlines()</span><br><span class="line">            <span class="comment"># 将数据分割成二维列表</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> fpList:</span><br><span class="line">                dataList.append(item.split(<span class="string">&quot;\t&quot;</span>))</span><br><span class="line">            <span class="comment"># 将字符数据转化成浮点数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dataList)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dataList[i])):</span><br><span class="line">                    dataList[i][j] = float(dataList[i][j])</span><br><span class="line">            <span class="comment"># 如果数据不包含类别信息</span></span><br><span class="line">            <span class="comment"># for i in range(len(dataList)):</span></span><br><span class="line">            <span class="comment">#     dataList[i].append(0)</span></span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            print(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">        <span class="comment">#返回数据</span></span><br><span class="line">        <span class="keyword">return</span> dataList</span><br><span class="line">    <span class="comment"># 获取初始k个点，也就是初始均值向量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getKSample</span>(<span class="params">self,dataList, k</span>):</span></span><br><span class="line">        kSample = []    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="comment">#从所有数据集中随机选取k个数据</span></span><br><span class="line">            num = random.randint(<span class="number">0</span>,len(dataList)<span class="number">-1</span>)</span><br><span class="line">            kSample.append(copy.deepcopy(dataList[num]))</span><br><span class="line">        <span class="keyword">return</span> kSample</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算两个点之间的距离</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getDistance</span>(<span class="params">self,dataPoint1,dataPoint2</span>):</span></span><br><span class="line">            </span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 因为每一项数据的最后一位为类别，所以不参与计算距离</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dataPoint1)<span class="number">-1</span>):</span><br><span class="line">            distance = distance + pow(dataPoint1[i]-dataPoint2[i],<span class="number">2</span>)		</span><br><span class="line">        distance = math.sqrt(distance)</span><br><span class="line">        <span class="keyword">return</span> distance</span><br><span class="line">    <span class="comment"># 根据每个样本距离均值向量的长短，计算每个样本所属的类别</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__caculateType</span>(<span class="params">self,dataPoint,kSample</span>):</span></span><br><span class="line">        <span class="comment"># 首先假设该样本距离第一个均值向量最近,即该样本属于第一类</span></span><br><span class="line">        minDistance = self.__getDistance(dataPoint,kSample[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 记录该样本所属的类别</span></span><br><span class="line">        type = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算该样本与每一个均值向量之间的距离</span></span><br><span class="line">        <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(kSample):</span><br><span class="line">            distance = self.__getDistance(dataPoint,item)</span><br><span class="line">            <span class="comment"># 如果该数据点距离该类别较小</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; minDistance:</span><br><span class="line">                minDistance = distance  <span class="comment"># 更新最短距离</span></span><br><span class="line">                type = index    <span class="comment"># 更新样本点所属类别</span></span><br><span class="line">        <span class="comment"># 修改数据点的类别</span></span><br><span class="line">        dataPoint[len(dataPoint)<span class="number">-1</span>] = type</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新计算均值向量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__caculateKSampleByAverge</span>(<span class="params">self,kSample</span>):</span></span><br><span class="line">         <span class="comment"># 对于每个均值向量，其下标为类别</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(kSample)):</span><br><span class="line">            typeI = []</span><br><span class="line">            <span class="comment"># 遍历所有数据找到与其类别一致的数据点</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> self.__dataList:</span><br><span class="line">                <span class="keyword">if</span> item[(len(item)<span class="number">-1</span>)] == i:</span><br><span class="line">                    typeI.append(copy.deepcopy(item))</span><br><span class="line">            <span class="comment">#求和</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(typeI)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(typeI[j])):</span><br><span class="line">                    typeI[j][k] += typeI[j<span class="number">-1</span>][k]</span><br><span class="line">            <span class="comment"># 求均值并更改每一类的聚类中心</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(kSample[i])):</span><br><span class="line">                kSample[i][j] = typeI[len(typeI)<span class="number">-1</span>][j]/len(typeI)</span><br><span class="line"></span><br><span class="line">a = Kmeans(<span class="string">&quot;f://machine_learning/shape_sets/D31.txt&quot;</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">a.start()</span><br><span class="line">print(a.getCount())</span><br><span class="line"><span class="comment">#二维坐标才可以画散点图</span></span><br><span class="line">a.drawPic()</span><br></pre></td></tr></table></figure>

<h2 id="K-means-算法的改进"><a href="#K-means-算法的改进" class="headerlink" title="K-means 算法的改进"></a>K-means 算法的改进</h2><p>K-means 是随机选取的初始点，因此不同的初始点对聚类结果有较大的影响。为解决这一问题我们可采用概率的方式来选择初始点，即 K-means++。</p>
<p>基本思想：</p>
<ol>
<li><p>从输入的集合中随机选取一个点作为聚类的中心</p>
</li>
<li><p>对于数据集中的每一个点，计算它与最近的聚类中心（指已选择的聚类中心）的距离 D(x)</p>
</li>
<li><p>选择一个新的数据点作为新的聚类中心，选择的原则是：D(x) 较大的点，被选取作为聚类中心的概率较大</p>
</li>
<li><p>重复2、3步骤直到 k 个初始聚类中心被选出</p>
</li>
<li><p>利用选出的 k 个初始的聚类中心来运行标准的 K-means 算法</p>
</li>
</ol>
<p>从上面可以看出，此算法的关键是如何将 D(x) 反映到点被选择的概率上，其方法如下：</p>
<ol>
<li><p>对于每个点都会计算与它最近的聚类中心的距离 D(x)，将每个点的 D(x)^2 保存在一个列表 List 中，然后把这些距离加起来，即对 List 中所有元素求和得到 SumList。</p>
</li>
<li><p>对于 List 中的每个点计算 List[i]/SumList ，即每个点概率 P(x)</p>
</li>
<li><p>将 P(x) 累加得到概率区间</p>
</li>
<li><p>产生一个 0-1 的随机数，该数落在哪个区间内就选择哪个点作为新的聚类中心</p>
</li>
</ol>
<p>具体示例如下：</p>
<p>8个点：(1,2),(1,2),(2,1),(2,2),(5,5),(5,6),(6,5),(6,6)</p>
<ol>
<li><p>随机选取一个点作为聚类中心，如3号点 (2,1)</p>
</li>
<li><p>计算 D(x)^2,P(x)</p>
</li>
</ol>


<ol start="3">
<li>产生 0-1 之间的随机数，如果该随机数落在 [0-0.007] 则选取1号点，[0.007-0.021] 则选取2号点，[0.021-0.028] 则选取3号点以此类推，很明显5，6，7，8号点被选取的概率较大，其距离3号点的距离较远。</li>
</ol>
<p>基于以上方法，我们改写选择初始点的函数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKSample</span>(<span class="params">dataList, k</span>):</span></span><br><span class="line">    kSample = []   </span><br><span class="line">    <span class="comment"># 首先随机选取一个数字为种子点 </span></span><br><span class="line">    num = random.randint(<span class="number">0</span>,len(dataList)<span class="number">-1</span>)</span><br><span class="line">    kSample.append(copy.deepcopy(dataList[num]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 用于保存距离的列表</span></span><br><span class="line">        D = []</span><br><span class="line">        <span class="comment"># 用于存储概率的数组</span></span><br><span class="line">        P = []</span><br><span class="line">        <span class="comment"># 对于每个点，我们都计算其和最近的一个“种子点”的距离D(x)^2并保存在一个数组里</span></span><br><span class="line">        <span class="keyword">for</span> item1 <span class="keyword">in</span> dataList:</span><br><span class="line">            minDistance = getDistance(item1,kSample[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> item2 <span class="keyword">in</span> kSample:</span><br><span class="line">                distance = getDistance(item1,item2)</span><br><span class="line">                <span class="keyword">if</span> distance &lt; minDistance:</span><br><span class="line">                    minDistance = distance</span><br><span class="line"></span><br><span class="line">            D.append(pow(minDistance,<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 循环结束之后得到储存距离的数组</span></span><br><span class="line">        sumD = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 然后把距离加起来</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> D:</span><br><span class="line">            sumD = sumD + item</span><br><span class="line">        <span class="comment"># 计算每个样本被选为下一个聚类中心的概率</span></span><br><span class="line">        sumP = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> D:</span><br><span class="line">            itemP = item/sumD</span><br><span class="line">            sumP = sumP + itemP</span><br><span class="line">            P.append(sumP)</span><br><span class="line">        <span class="comment">#随机产生0-1之间的数</span></span><br><span class="line">        rand = random.random()</span><br><span class="line">        <span class="comment"># 计算该数落在哪个区间</span></span><br><span class="line">        <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(P):</span><br><span class="line">            <span class="keyword">if</span> rand &lt; item:</span><br><span class="line">                kSample.append(copy.deepcopy(dataList[index]))</span><br><span class="line">                <span class="keyword">break</span>       </span><br><span class="line">    <span class="keyword">return</span> kSample</span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sillywa"
      src="/images/logo.png">
  <p class="site-author-name" itemprop="name">Sillywa</p>
  <div class="site-description" itemprop="description">个人学习记录博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sillywa" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sillywa" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sillywa</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
<div>
<span id="timeDate"></span><span id="times"></span>
</div>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("12/03/2018 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "Running for "+dnum+" Days ";
        document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s";
    }
    setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
