<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vi基本操作</title>
    <url>/2019/03/06/vi%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>vi 是 Linux 常用的编辑器，本文记录了 vi 的基本操作。</p>
<a id="more"></a>


<h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><ol>
<li><p>命令模式<br>用 vi 打开一个文件即进入命令模式</p>
</li>
<li><p>输入模式<br>a i o 进入输入模式</p>
</li>
</ol>
<ul>
<li>a 光标后输入</li>
<li>i 光标前输入</li>
<li>o 光标下一行输入</li>
<li>A 光标所在行的行尾输入</li>
<li>O 光标所在行的上一行新建一行</li>
<li>esc退回到命令模式</li>
</ul>
<ol start="3">
<li>末行模式</li>
</ol>
<ul>
<li>: 进入末行模式</li>
<li>esc返回命令模式</li>
</ul>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ol>
<li><p>行内跳转<br>home 或者 $ 跳转行首<br>end 或者 ^ 跳转行尾</p>
</li>
<li><p>行间跳转<br>末行模式输入 <code>set nu</code> 显示行数</p>
<ul>
<li><p>命令模式<br><code>#gg</code>     跳转到#行，#代表数字<br><code>G</code>       跳转到行尾<br><code>gg</code>      跳转到行首</p>
</li>
<li><p>末行模式<br><code>:#</code>      跳转到#行，#代表数字</p>
</li>
</ul>
</li>
</ol>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ul>
<li>命令模式<br><code>#yy</code>       从光标所在行开始，往下复制#行</li>
<li>末行模式<br><code>:#y</code>       复制第#行<br><code>:m,ny</code>     复制从第m行到第n行</li>
</ul>
<h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><ul>
<li><code>p</code> 光标后粘贴</li>
<li><code>P</code> 光标前粘贴</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li><p>命令模式<br><code>x或者del</code>     删除光标所在字符<br><code>#dd</code>         删除从光标所在行开始，往下数#行</p>
</li>
<li><p>末行模式<br><code>:#d </code>        删除第#行<br><code>:m,nd</code>       删除从第m行到第n行</p>
</li>
</ul>
<h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p>  删除 + 粘贴     </p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>命令模式<br>  <code>/word</code> 从上往下查找word，小写n，查找下一个匹配的<br>  <code>?word</code> 从下往上查找word，大写N，查找上一个匹配的</p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>末行模式<br>  <code>:s/old/new</code>   将光标所在行，满足的第一个old替换成new<br>  <code>:s#old#new</code>  </p>
<p>  <code>:s/old/new/g</code> 光标所在行的所有old替换成new<br>  <code>:s#old#new#g</code>  </p>
<p>  <code>:m,ns/old/new</code> 第m行到第n行，每行第一个满足的old替换成new</p>
<p>  <code>:%s/old/new/g</code>   全文替换<br>  <code>:%s#old#new#g</code></p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>末行模式<br>  <code>:r /root/test.txt</code> 在光标下一行写入文件/root/test.txt</p>
<h2 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h2><ul>
<li>末行模式<br>:wq<br>:x</li>
<li>命令模式<br>ZZ</li>
</ul>
<h2 id="其他退出"><a href="#其他退出" class="headerlink" title="其他退出"></a>其他退出</h2><ul>
<li>强制退出<br>:q!</li>
<li>强制保存退出<br>:wq!</li>
<li>正常退出<br>:q</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Linux基本命令</title>
    <url>/2018/12/06/%E5%AD%A6%E4%B9%A0Linux%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍常用的 Linux 命令。</p>
<a id="more"></a>

<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><ul>
<li><code>pwd</code> 打印当前工作目录</li>
<li><code>cd</code> 改变目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/bin  绝对路径从根目录出发，到达目标目录</span><br><span class="line">cd ./usr 相对路径从工作目录出发，到达目标目录</span><br><span class="line">cd .. 到达父目录</span><br><span class="line">cd(cd ~) 到达家目录，如果未root用户，pwd会打印出 /root，其上一层为 根目录/</span><br><span class="line">cd / (cd -) 回到根目录</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ls</code> 列出目录内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l 使用长格式显示结果</span><br><span class="line">ls -t 按修改时间排序</span><br><span class="line">ls -r 以相反的顺序显示</span><br><span class="line">ls -S 按文件大小对结果进行排序</span><br><span class="line">ls -R [文件夹] 列出文件树</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li><code>file</code> 确定文件类型</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure>

<ul>
<li><code>less</code> 查看文件内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">less /etc/passwd</span><br></pre></td></tr></table></figure>

<ul>
<li><code>touch</code> 新建文件</li>
</ul>
<h2 id="操作文件与目录"><a href="#操作文件与目录" class="headerlink" title="操作文件与目录"></a>操作文件与目录</h2><ul>
<li><code>mkdir</code> 创建目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir dir1              创建单个目录</span><br><span class="line">mkdir dir1 dir2 dir3    创建多个目录</span><br><span class="line">mkdir -p dir&#123;1..9&#125;      创建多个目录a1到a9</span><br><span class="line">mkdir -p a&#123;1..3&#125;/b&#123;1..3&#125;创建多个目录a1到a3，并且在每个目录下创建b1到b3</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cp</code> 复制文件或目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp file1 file2          将文件file1复制到file2中,file2内容将会被覆盖</span><br><span class="line">cp -r dir1 dir2         复制目录时一定要加 -r，如果dir2目录存在，则会复制到dir2目录下和mv是一样的道理</span><br><span class="line">cp file1 file2 dir1     将多个文件复制到一个目录下</span><br></pre></td></tr></table></figure>

<p><code>cp</code>命令选项</p>
<p><code>cp</code>在覆盖已存在的文件时默认情况下是 <code>cp -i</code>，即需要用户确认，我们可以这样 <code>\cp</code> 即可无需确认</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-r          递归复制目录及其内容。复制目录时需要这个选项</span><br><span class="line">-u          将文件从一个目录复制到另一个目录时，只会复制目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          复制文件时显示信息性消息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mv</code> 重命名或移动文件和目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv item1 item2              将文件或目录item1移动或重命名为item2</span><br><span class="line">mv item1 item2 item3 dir1   将多个条目移动到dir1目录下</span><br></pre></td></tr></table></figure>

<p><code>mv</code>命令选项与<code>cp</code>大致相同，<code>mv</code>没有<code>-r</code>选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-u          将文件从一个目录移动到另一个目录时，只会移动目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          移动时显示信息性消息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rm</code> 删除文件或目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -r item1 item2 item3         删除item1,item2,item3,删除目录时需要-r</span><br><span class="line">rm *.html                       删除以.html结尾的文件</span><br></pre></td></tr></table></figure>

<p><code>rm</code>命令选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-i          删除前提示用户确认</span><br><span class="line">-r          递归删除目录及其内容。删除目录时需要这个选项</span><br><span class="line">-f          忽略不存在的文件，并无需提示确认</span><br><span class="line">-v          删除时显示信息性消息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ln</code> 创建硬链接和符号链接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln file hard-link-name      创建file文件的硬链接</span><br><span class="line">ln -s file sym-link-name    创建file文件的符号链接，符号链接指向源文件，与源文件内容保持一致</span><br></pre></td></tr></table></figure>

<p><code>file</code>为相对于<code>sym-link-name</code>的文件，即为相对路径，当然也可以是绝对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s ../file sym-link-name     file在当前目录的父目录中，即file相对于sym-link-name的位置</span><br></pre></td></tr></table></figure>

<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;I am fine&quot;                        打印 I am fine</span><br><span class="line">echo &quot;I am fine&quot; &gt; /root/test.txt       将 I am fine写入/root/test.txt中</span><br><span class="line">echo &quot;I am fine&quot; &gt;&gt; /root/test.txt      将 I am fine追加到/root/test.txt末尾</span><br><span class="line">grep &quot;关键字&quot; test.txt                  在test.txt中查找含有关键字的行并打印</span><br><span class="line">grep -v &quot;关键字&quot; test.txt               在test.txt中查找不含有关键字的行并打印</span><br><span class="line">grep ^&quot;关键字&quot; test.txt                 在test.txt中查找以关键字开头的行并打印</span><br><span class="line">grep $&quot;关键字&quot; test.txt                 在test.txt中查找以关键字结尾的行并打印</span><br></pre></td></tr></table></figure>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l | grep &quot;关键字&quot; &gt; /root/test.txt  列出当前目录文件信息并交给grep过滤，最后写入/root/test.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>图的结构及遍历</title>
    <url>/2019/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>在树型结构中，结点间具有分支层次关系，每一层上的结点只能和上一层中的至多一个结点相关，但可能和下一层的多个节点相关。树的关系也叫一对多的关系，而在图状结构中，任意两个结点之间都可能相关，即结点的邻接关系可以是任意的。图的结构是<strong>任意两个数据对象之间都可能存在某种特定关系</strong>的数据结构，是一种多对多的关系。</p>
<a id="more"></a>

<h3 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h3><p>图（Graph）是由两个集合构成，一个是非空但有限的顶点集合 V，另一个是描述顶点之间关系——边的集合 E（可以是空集）。因此图可以表示为 G=(V,E)。每条边是一顶点对 (v,w) 且 v,w∈V。通常用 |V| 表示定点数量 |E| 表示边的数量。</p>
<p>关于图的定义，与以前的线性表和树比较，还有几点需要注意：</p>
<ul>
<li><p>在线性表中，一般叫数据对象为元素；在树中，将数据对象成为结点；而在图中，我们把数据对象称为顶点（Vertex）。</p>
</li>
<li><p>线性表中可以没有数据对象，此时叫空表；没有数据对象的树称为空树；而在图中，我们至少要求有一个顶点，但边集可以是空。</p>
</li>
</ul>
<h3 id="图的抽象数据类型"><a href="#图的抽象数据类型" class="headerlink" title="图的抽象数据类型"></a>图的抽象数据类型</h3><p>类型名称：图（Graph）。</p>
<p>数据对象集：一个非空顶点集合 Vertex 和一个边集合 Edge，每条边用对应的一对顶点表示。</p>
<p>操作集：对于任意的图 G∈Graph，顶点 V∈Vertex，边 E∈Edge，以及任一访问顶点的函数 Visit()，我们主要关心下列操作：</p>
<p>1.<code>Graph CreateGraph(int VertexNum)</code>：构造一个有 VertexNum 个顶点但没有边的图；</p>
<p>2.<code>void InsertEdge(Graph G, Edge E)</code>：在 G 中增加新边 E；</p>
<p>3.<code>void DeleteEdge(Graph G, Edge E)</code>：从 G 中删除边 E；</p>
<p>4.<code>bool IsEmpty(Graph G)</code>：判断图是否为空；</p>
<p>5.<code>void DFS(Graph G, Vertex V, (*Visit)(Vertex))</code>：在图 G 中，从顶点 V 出发进行深度优先遍历；</p>
<p>6.<code>void BFS(Graph G, Vertex V, (*Visit)(Vertex))</code>：在图 G 中，从顶点 V 出发进行广度优先遍历。</p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>所谓邻接矩阵的存储结构，就是用矩阵表示图中各顶点之间的邻接关系和权值。以下是一个无向图的临界矩阵表示：</p>


<p>从图的邻接矩阵存储方法容易看出这种表示具有以下特点:</p>
<p>1.无向图的邻接矩阵一定是个对称矩阵。因此在具体存放邻接矩阵时只需要存放上三角或者下三角的元素即可。所需要存储的元素个数是：|V|*(|V|-1)/2。</p>
<p>2.对于无向图，邻接矩阵的第 i 行（或第 i 列）非 0 元素的个数正好是第 i 个顶点的度（Degree）。</p>
<p>3.对于有向图，邻接矩阵第 i 行（或第 i 列）非 0 元素的个数正好是第 i 个顶点的出度（或入度）。</p>
<p>4.用临界矩阵方法存储图，很容易确定图中任意两点之间是否有边相连，只需要考察邻接矩阵对应的元素即可；确定一个顶点的所有邻接点，也只需要邻接矩阵对应的一行（或一列）；但是要确定图中有多少边，则必须按行（或按列）对每个元素进行检测，所花费的时间代价是 O(|V|^2)。这是用邻接矩阵来存储图的局限性。</p>
<p>以下是邻接矩阵的 C 语言描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100    <span class="comment">/* 最大顶点数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535      <span class="comment">/* 初始值设为双字节无符号整数的最大值 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;         <span class="comment">/* 用顶点下标表示顶点，为整形 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> WeightType;     <span class="comment">/* 边的权值 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;            <span class="comment">/* 顶点存储的数据类型设为字符型 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图的定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;     <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;     <span class="comment">/* 边数 */</span></span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum];   <span class="comment">/* 邻接矩阵 */</span></span><br><span class="line">    DataType Data[MaxVertexNum];                <span class="comment">/* 每个顶点的数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边的定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    Vertex V1, V2;      <span class="comment">/* 有向边&lt;V1,V2&gt; */</span></span><br><span class="line">    WeightType Weight;  <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br></pre></td></tr></table></figure>

<p>有了图的结构和类型定义之后，先创建一个包含全部顶点但是没有边的图，再逐条插入边，从而创建一个无向网图的数据结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span> </span>&#123;</span><br><span class="line">    MGraph Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化邻接矩阵 */</span></span><br><span class="line">    <span class="comment">/* 注意顶点默认从 0 编号 到 Graph-&gt;Nv - 1 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; Graph-&gt;Nv;j++) &#123;</span><br><span class="line">            Graph-&gt;G[i][j] = INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdeg</span><span class="params">(MGraph Graph, Edge E)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入边&lt;V1,V2&gt; */</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是无向图,还需要插入边&lt;V2,V1&gt; */</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    <span class="keyword">int</span> VertexNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入顶点数 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;VertexNum);</span><br><span class="line"></span><br><span class="line">    Graph = CreateGraph(VertexNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入边数 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Graph-&gt;Ne);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Edge E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode)); <span class="comment">/* 建立边结点 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*依次读入每一条边的数据 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph-&gt;Ne;i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将该边插入图中 */</span></span><br><span class="line">            InsertEdeg(Graph, E);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果顶点有数据，读入顶点数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;Graph-&gt;Data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>邻接矩阵是一种表示各类图的简洁的数据结构。但是我们发现，不论图中边的数量或多或少，我们都花费了 O(|V|^2) 的存储空间，这对于稠密图来说是一种高效的存储方法。但是如果面对的是一个稀疏图，则邻接矩阵中的大多数项为 0 或 无穷，形成了所谓的稀疏矩阵，就会浪费很多空间。因此对于稀疏图，我们考虑另一种存储方法。</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表是一种图的顺序存储与链式存储相结合的存储方法。</p>


<p>图的邻接表存储具有以下特点：</p>
<p>1.方便查找任一顶点的所有邻接点。</p>
<p>2.节约稀疏图的空间。需要 N 个头指针 + 2E 个结点（每个结点至少两个域）。</p>
<p>3.对于无向图来说方便计算任一顶点的度，对于有向图来说只能计算出度。</p>
<p>4.不方便检查任一对顶点间是否存在边。</p>
<p>以下是图的邻接表存储的代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100    <span class="comment">/* 最大顶点数设为100 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;         <span class="comment">/* 用顶点下标表示顶点，为整形 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> WeightType;     <span class="comment">/* 边的权值设为整形 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;      <span class="comment">/* 顶点存储的数据类型设为字符型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边的定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    Vertex V1,V2;       <span class="comment">/* 有向边&lt;V1,V2&gt; */</span></span><br><span class="line">    WeightType Weight;  <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接点的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span>* <span class="title">PtrToAdjVNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span> &#123;</span></span><br><span class="line">    Vertex AdjV;            <span class="comment">/* 邻接点的下标 */</span></span><br><span class="line">    WeightType Weight;      <span class="comment">/* 邻接点边的权重 */</span></span><br><span class="line">    PtrToAdjVNode Next;     <span class="comment">/* 下一个邻接点 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顶点表头节点的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span> &#123;</span></span><br><span class="line">    PtrToAdjVNode FirstEdge;    <span class="comment">/* 边表头节点指针 */</span></span><br><span class="line">    DataType Data;              <span class="comment">/* 头结点的值 */</span></span><br><span class="line">    <span class="comment">/* 很多情况下顶点无数据，此时Data不用出现 */</span></span><br><span class="line">&#125; AdjVList[MaxVertexNum];       <span class="comment">/* AdjVList是邻接表的类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;         <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;         <span class="comment">/* 边数 */</span></span><br><span class="line">    AdjVList G;     <span class="comment">/* 邻接表 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode LGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化一个有 VertexNum个顶点，但是没有边的图 */</span></span><br><span class="line"><span class="function">LGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将边&lt;V1,V2&gt;插入图中 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(LGraph Graph, Edge E)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据输入构建图 */</span></span><br><span class="line"><span class="function">LGraph <span class="title">BuildGraph</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span> </span>&#123;</span><br><span class="line">    LGraph Graph = (LGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化邻接表的表头指针 */</span></span><br><span class="line">    <span class="comment">/* 注意这里默认定点编号从 0 开始到 (Graph-&gt;Nv - 1) 结束 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        Graph-&gt;G[i].FirstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(LGraph Graph, Edge E)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 插入有向边 &lt;V1,V2&gt; */</span></span><br><span class="line">    PtrToAdjVNode NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建一个邻接点，并将该邻接点插入链表头部 */</span></span><br><span class="line">    NewNode = (PtrToAdjVNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">    NewNode-&gt;AdjV = E-&gt;V2;</span><br><span class="line">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是无向图还要插入&lt;V2,V1&gt; */</span></span><br><span class="line">    NewNode = (PtrToAdjVNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">    NewNode-&gt;AdjV = E-&gt;V1;</span><br><span class="line">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LGraph <span class="title">BuildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    <span class="keyword">int</span> VertexNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入顶点数 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;VertexNum);</span><br><span class="line">    Graph = CreateGraph(VertexNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入边数 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Graph-&gt;Ne);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 构建边并读入 */</span></span><br><span class="line">        Edge E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果顶点有数据，读入数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;(Graph-&gt;G[i].Data));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>图的遍历就是从图中任一顶点出发，对图中所有顶点访问一次且仅访问一次的次序序列。</p>
<h3 id="深度优先搜索（Depth-First-Search-DFS）"><a href="#深度优先搜索（Depth-First-Search-DFS）" class="headerlink" title="深度优先搜索（Depth First Search,DFS）"></a>深度优先搜索（Depth First Search,DFS）</h3><p>深度优先搜索类似于树的先序遍历，是树的先序遍历的推广。假设初始状态所有顶点都没被访问过，则深度优先搜索从图中的任一顶点出发，设为v0 ，访问此顶点，然后从v0的邻接点中的一个出发递归地进行同样的深度优先搜索，直至图中所有节点都被访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵存储的图 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Vertex V)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点 %d&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Visited[]已经为全局变量，且初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(LGraph Graph, Vertex V, <span class="keyword">void</span> (*Visit)(Vertex))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Visit(V);           <span class="comment">/* 访问第V个顶点 */</span></span><br><span class="line">    Visited[V] = <span class="literal">true</span>;  <span class="comment">/* 将V标记为已访问 */</span></span><br><span class="line"></span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    <span class="keyword">for</span>(W = Graph-&gt;G[V].FirstEdge;W;W = W-&gt;Next) &#123;  <span class="comment">/* 对V的每个邻接点W */</span></span><br><span class="line">        <span class="keyword">if</span>(! Visited[W-&gt;AdjV]) &#123;                    <span class="comment">/* 如果W未被访问 */</span></span><br><span class="line">            DFS(Graph, W-&gt;AdjV, Visit);             <span class="comment">/* 则递归访问之 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先搜索（Breadth-First-Search-BFS）"><a href="#广度优先搜索（Breadth-First-Search-BFS）" class="headerlink" title="广度优先搜索（Breadth First Search,BFS）"></a>广度优先搜索（Breadth First Search,BFS）</h3><p>广度优先搜索类似于树的层次遍历。从顶点v0出发，在访问了v0之后，依次访问v0各个未被访问的邻接点，然后分别从这些邻接点出发，访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。直至图中所有已被访问的顶点的邻接点都被访问到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵存储的图 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Vertex V)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点 %d&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span></span><br><span class="line"><span class="comment">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span></span><br><span class="line"><span class="comment">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEdge</span><span class="params">(MGraph Graph, Vertex V, Vertex W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Graph-&gt;G[V][W] &lt; INFINITY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Visited[]已经为全局变量，且初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MGraph Graph, Vertex S, <span class="keyword">void</span>(* Visit)(Vertex))</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 以S为出发点对邻接矩阵存储的图进行BFS搜索 */</span></span><br><span class="line">    Vertex V,W;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问 S 顶点 */</span></span><br><span class="line">    Visit(S);</span><br><span class="line">    Visited[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = CreateQueue(MaxSize);           <span class="comment">/* 创建一个空队列 */</span></span><br><span class="line"></span><br><span class="line">    AddQ(Q, S);         <span class="comment">/* 将S入队 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q)) &#123;</span><br><span class="line">        V = DeleteQ(Q);  <span class="comment">/* 弹出V */</span></span><br><span class="line">        <span class="keyword">for</span>(W = <span class="number">0</span>;W &lt; Graph-&gt;Nv;W++) &#123;              <span class="comment">/* 对图中的每一个顶点 W */</span></span><br><span class="line">            <span class="comment">/* 如果W没有访问过且是V的邻接点 */</span></span><br><span class="line">            <span class="keyword">if</span>(!Visited[W] &amp;&amp; IsEdge(Graph, V, W))</span><br><span class="line">                <span class="comment">/* 访问 W 顶点 */</span></span><br><span class="line">                Visit(W);</span><br><span class="line">                Visited[W] = <span class="literal">true</span>;  <span class="comment">/* 将 W 标记为已访问 */</span></span><br><span class="line">                AddQ(Q, W);         <span class="comment">/* 将 W 入队列 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若有 N 个顶点、E 条边，DFS 和 BFS 的时间复杂度为：</p>
<ul>
<li><p>用邻接表存储图，为 O(N+E);</p>
</li>
<li><p>用邻接矩阵存储图，为 O(N^2)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>散列查找</title>
    <url>/2019/12/16/%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>散列查找解决的一个基本问题是：如何快速搜索到需要的关键词？</p>
<p>我们知道查找的本质是已知一个对象，找到该对象的位置。因此如果我们在安排位置时，通过一个”散列函数“来计算出对象的位置进行存放，当要查找这个对象时，再通过相同的”散列函数“即可直接计算出对象的位置。</p>
<p>因此其时间复杂度几乎是：O(1)，即查找时间与问题规模无关！</p>
<a id="more"></a>

<p>那么问题就来了，我们如何构造出一个比较好的散列函数，如果多个关键词通过某个散列函数计算出了相同的位置，我们如何解决这种冲突。</p>
<p>所以散列查找法的两项基本工作就是：</p>
<ul>
<li><p>计算位置：构造散列函数确定关键词的存储位置</p>
</li>
<li><p>解决冲突：应用某种策略解决多个关键字位置相同的问题</p>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>散列表（哈希表）</strong>：</p>
<p><strong>类型名称</strong>：符号表(SymbolTable)</p>
<p><strong>数据对象集</strong>：符号表是“名字(Name)—属性(Attribute)”对的集合</p>
<p><strong>操作集</strong>：对于一个具体的符号表Table∈SymbolTable，一个给定的名字Name∈NameType，属性Attr∈AttributeType，以及正整数TableSize，符号表的基本操作有：</p>
<p><code>SymbolTable CreateTable(int TableSize)</code>：创建空的符号表，其最大长度为TableSize；</p>
<p><code>bool IsIn(SymbolTable Table,NameType Name)</code>：查找指定 Name 是否在符号表 Table 中；</p>
<p><code>AttributeType Find(SymbolTable Table,NameType Name)</code>：获取符号表 Table 中指定名字 Name 对应的属性；</p>
<p><code>bool Modify(SymbolTable Table,NameType Name,AttributeType Attr)</code>：将Table 中指定名字 Name 的属性修改为 Attr；</p>
<p><code>bool Insert(SymbolTable Table,NameType Name,AttributeType Attr)</code>：向 Table 中插入一个新名字 Name 及其属性 Attr；</p>
<p><code>bool Delete(SymbolTable Table,NameType Name)</code>：从 Table 中删除一个名字 Name 及其属性。</p>
<p><strong>散列(Hashing)的基本思想是：</strong></p>
<p>1.以关键字key为自变量，通过一个确定的函数h（散列函数），计算出对应的函数值h(key)，作为数据对象的存储地址。</p>
<p>2.可能不同的关键字会映射到同一个散列地址上，即h(key_i )=h(key_j ),key_i≠key_j，称为冲突——因此需要某种冲突解决策略。</p>
<p>例：有 n=11 个对象的集合 {18,23,11,20,2,7,27,30,42,15,34}。符号表的大小 TableSize = 17（通常为素数），选取散列函数如下：</p>
<p>h(key) = key mod TableSize (求余)</p>
<p>用这个散列函数对 11 个对象建立查找表，如下所示：</p>


<ul>
<li><p>存放：<br>如果新插入35，h(35)=1，该位置已有对象，冲突</p>
</li>
<li><p>查找：<br>key = 22,h(22) = 5，该地址为空，不在表中<br>key = 30,h(30) = 13，该地址存放的是30，找到</p>
</li>
</ul>
<blockquote>
<p>定于 装填因子：设散列表空间大小为 m，填入表中的元素个数是 n，则称 a=n/m 为散列表的装填因子。</p>
</blockquote>
<h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><p>一个好的散列函数应该考虑以下两个因素：</p>
<p>1.计算简单，以便提高转换速度；</p>
<p>2.关键词对应的地址空间分布均匀，以尽量减少冲突。</p>
<h3 id="数字关键词的散列函数构造"><a href="#数字关键词的散列函数构造" class="headerlink" title="数字关键词的散列函数构造"></a>数字关键词的散列函数构造</h3><p>1.直接定址法</p>
<p>如果我们要统计人口的年龄分布情况（0——120），那么对于年龄这个关键词可以直接作为地址，即 h(key) = key。</p>
<p>如果要统计的是 1990 年以后出任的人口分布情况，那么对于出生年份这个关键词可以减去 1990 作为地址，即 h(key) = key-1990。</p>


<p>总之，取关键词的某个线性函数值为散列地址，即</p>
<p>h(key) = a X key + b   (a,b为常数)</p>
<p>2.除留余数法</p>
<p>现实生活中比较常用的方法是除留余数法。假设散列表长为 TableSize，选择一个正整数 p ≤ TableSize，散列函数构造为：</p>
<p>h(key) = key mod p</p>
<p>这里 p 一般取为小于等于散列表长 TableSize 的某个最大的素数比较好。</p>
<p>3.数字分析法</p>
<p>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址</p>
<p>比如：取手机号 key 的后 4 位作为地址：</p>
<p>散列函数位：h(key) = atoi(key+7)</p>
<h3 id="字符串关键词的散列函数构造"><a href="#字符串关键词的散列函数构造" class="headerlink" title="字符串关键词的散列函数构造"></a>字符串关键词的散列函数构造</h3><p>1.一个简单的散列函数——ASCII码加和法</p>


<p>2.简单的改进——前3个字符移位法</p>


<p>3.好的散列函数——移位法</p>


<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>在前面的散列函数构造过程中，我们努力使散列地址均匀分布在整个地址空间，但实际应用中，冲突只能尽量减少，而不能完全避免。接下来我们讨论在冲突发生时，如何有效地解决它。常用的处理冲突的方法有开放地址法（Open Addressing）和链地址法（Linear Probing）。</p>
<h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p>一旦产生了冲突（该地址已有其它元素），就按照某种规则去寻找另一空地址。</p>
<p>若发生了第 i 次冲突，试探的下一个地址将增加 di，基本公式是：</p>
<p>hi(key) = (h(key) + di) mod TableSize (1 &lt;= i &lt; TableSize)</p>
<p>di决定了不同的解决冲突方案：线性探测、平方探测、双散列。</p>
<p>1.线性探测</p>
<p><strong>以增量序列1,2,3…TableSize-1循环试探下一个存储地址。</strong></p>
<p>设关键词序列为 {47,7,29,11,9,84,54,20,30}</p>
<p>散列表长 TableSize=13（装填因子 9/13=0.69）；</p>
<p>散列函数为：h(key) = key mod 11。</p>
<p>用线性探测法处理冲突，列出一次插入后的散列表，并估算查找性能。</p>


<p>注意”聚集“现象。</p>
<p>散列表查找性能分析</p>
<ul>
<li><p>成功平均查找长度(ASLs)</p>
</li>
<li><p>不成功平均查找长度(ASLu)</p>
</li>
</ul>
<p>散列表如下：</p>


<p>分析：</p>
<p>ASLs：查找表中关键词的平均查找比较次数（其冲突次数加 1）</p>
<p>ASLs = (1+7+1+1+2+1+4+2+4)/9 = 2.56</p>
<p>ASLu：不在散列表中的关键词的平均查找次数（不成功）</p>
<p>一般方法：将不在散列表中的关键词分为若干类。如根据 h(key) 分类</p>
<p>ASLu = (3+2+1+2+1+1+1+9+8+7+6)/11 = 3.73</p>
<p>2.平方探测法——二次探测</p>
<p><strong>以增量序列 1，-1，4，-4，9，-9，…，q^2，-q^2，且 q &lt;= [TableSize/2] 循环试探下一个存储地址。</strong></p>
<p>设关键词序列为 {47,7,29,11,9,84,54,20,30}，散列表长度 TableSize = 11，散列函数为：h(key) = key mod 11。用平方探测法处理冲突，列出依次插入后的散列表，并估算ASLs。</p>


<p>ASLs = (1+1+2+1+1+3+1+4+4)/9 = 2</p>
<p><strong>是否有空间，平方探测（二次探测）就能找到？</strong></p>


<p><strong>有证明表明，如果散列表的长度 TableSize 是某个 4k+3（k是正整数）形式的素数时，平方探测法就可以检测到整个散列表空间。</strong>这一点很重要，使我们能够放心使用平方探测法的理论保证。</p>
<p>在开放地址的散列表中，不能进行标准的删除操作，因为相应的单元可能引起过冲突，数据对象绕过它存在了别处。为此开放地址散列表需要“惰性删除”，即需要增加一个“删除标记”，而并不是真正的删除它。这样可以不影响查找，但额外的存储负担增加了代码的复杂性。</p>
<p>以下是开放地址法的类型声明：</p>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTABLESIZE 100000     <span class="comment">/* 允许开辟的最大散列表长度 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;        <span class="comment">/* 关键词类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;              <span class="comment">/* 散列地址类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> Index Position;         <span class="comment">/* 数据所在位置与散列地址是同一类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列单元的状态，分别对应：有合法元素、空单元、有已删除元素 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; Legitimate, Empty, Deleted &#125; EntryType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span> <span class="title">Cell</span>;</span>  <span class="comment">/* 散列表单元类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span> &#123;</span></span><br><span class="line">    ElementType Data;   <span class="comment">/* 存放的元素 */</span></span><br><span class="line">    EntryType Info;     <span class="comment">/* 单元状态 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span>* <span class="title">HashTable</span>;</span>  <span class="comment">/* 散列表类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span> &#123;</span>        <span class="comment">/* 散列表节点定义 */</span></span><br><span class="line">    <span class="keyword">int</span> TableSize;      <span class="comment">/* 散列表的最大长度 */</span></span><br><span class="line">    Cell *Cells;        <span class="comment">/* 存放散列单元的数组 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如下代码给出了散列表的初始化函数。首先申请散列表需要的空间，再将每个单元的 info 设置为 Empty，表示为空。注意需要确定一个不下于 TableSize 的素数，用作真正的散列表的地址空间大小，这个功能由 NextPrime 实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextPrime</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 返回大于N且不超过MAXTABLESIZE的最小素数 */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> p = (N%<span class="number">2</span>) ? N+<span class="number">2</span> : N+<span class="number">1</span>;  <span class="comment">/* 从大于N的第一个奇数开始 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &lt;= MAXTABLESIZE) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(p); i&gt;<span class="number">2</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(!(p%i)) <span class="keyword">break</span>;   <span class="comment">/* p不是素数 */</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">/* for循环正常结束，说明p是素数 */</span></span><br><span class="line">        <span class="keyword">else</span> p+=<span class="number">2</span>;  <span class="comment">/* 否则试探下一个奇数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HashTable <span class="title">CreateTable</span><span class="params">(<span class="keyword">int</span> TableSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashTable H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TblNode));</span><br><span class="line">    <span class="comment">/* 保证散列表的最大长度是素数 */</span></span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">    <span class="comment">/* 声明单元数组 */</span></span><br><span class="line">    H-&gt;Cells = (Cell*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cell)*H-&gt;TableSize);</span><br><span class="line">    <span class="comment">/* 初始化单元数组为空单元 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; H-&gt;TableSize;i++) &#123;</span><br><span class="line">        H-&gt;Cells[i].Info = Empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是平方探测法的查找函数。首先调用 Hash 函数计算地址，以确定关键词所在的散列表地址。用 while 循环控制直至明确查找成功或者找到空位置表示查找失败，遇到冲突则继续查找。</p>
<p>注意关键词 key 的类型 ElementType 不一定为整形，也可能被定义为字符串，若是字符串，则 while 的判断条件要用 C 语言的 strcmp 函数来替换。若找到关键词，函数直接返回结点的地址，若找不到则返回一个空的单元。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(HashTable H, ElementType Key)</span> </span>&#123;</span><br><span class="line">    Position CurrentPos,OldPos;</span><br><span class="line">    <span class="keyword">int</span> CNum = <span class="number">0</span>; <span class="comment">/* 记录冲突次数 */</span></span><br><span class="line">    CurrentPos = OldPos = Hash(Key, H-&gt;TableSize); <span class="comment">/* 计算出其位置 */</span></span><br><span class="line">    <span class="comment">/* 当该单元为非空并且不是要找的元素时，发生冲突 */</span></span><br><span class="line">    <span class="keyword">while</span>(H-&gt;Cells[CurrentPos].Info != Empty &amp;&amp; H-&gt;Cells[CurrentPos].Data != Key) &#123;</span><br><span class="line">        <span class="comment">/* 字符串类型需调用 strcmp 函数 */</span></span><br><span class="line">        <span class="comment">/* 统计冲突次数 */</span></span><br><span class="line">        <span class="keyword">if</span>((++CNum % <span class="number">2</span>)) &#123;  <span class="comment">/* 奇数次冲突 */</span></span><br><span class="line">            <span class="comment">/* 增量为 [(CNum+1)/2]^2 */</span></span><br><span class="line">            CurrentPos = OldPos + (CNum+<span class="number">1</span>) * (CNum+<span class="number">1</span>) /<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(CurrentPos &gt;= H-&gt;TableSize)</span><br><span class="line">                CurrentPos = CurrentPos%H-&gt;TableSize;   <span class="comment">/* 调整为合法地址 */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* 偶数次冲突 */</span></span><br><span class="line">            <span class="comment">/* 增量为 -(CNum/2)^2 */</span></span><br><span class="line">            CurrentPos = OldPos - CNum * CNum /<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(CurrentPos &lt; <span class="number">0</span>)   <span class="comment">/* 调整为合法地址 */</span></span><br><span class="line">                CurrentPos += H-&gt;TableSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CurrentPos;</span><br><span class="line">    <span class="comment">/* 此时 CurrentPos 或者是 Key 的位置，或者是一个空单元的地址（表示找不到） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是插入函数，先检查 Key 是否已经存在，该单元的状态只要不是合法的，就可以在此插入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(HashTable H, ElementType Key)</span> </span>&#123;</span><br><span class="line">    Position p = Find(H,Key);   <span class="comment">/* 首先检查Key值是否存在 */</span></span><br><span class="line">    <span class="keyword">if</span>(H-&gt;Cells[p].Info != Legitimate) &#123;    <span class="comment">/* 如果这个单元没有被占用，说明Key可以插入在此 */</span></span><br><span class="line">        H-&gt;Cells[p].Info = Legitimate;</span><br><span class="line">        H-&gt;Cells[p].Data = Key;</span><br><span class="line">        <span class="comment">/* 字符串类型需调用strcpy函数 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;键值已存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开放地址法的删除操作只需要该改变单元的状态 Info 即可。</p>
<p>3.双散列探测法</p>


<p>4.再散列（Rehashing）</p>
<p>当散列表元素太多时（即装填因子太大时），查找效率就会下降；实用的装填因子一般取<strong>0.5——0.85</strong>。</p>
<p>当装填因子过大时，解决的方法就是加倍扩大散列表，这个过程叫做**”再散列”**。</p>
<h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>分离链接法就是将相应位置上冲突的所有关键词存储在同一个单链表里面。</p>
<p>设关键字序列为{47,7,29,11,16,92,22,8,3,50,37,89,94,21}，散列函数取：h(key) = key mod 11；用分离链接法处理冲突，结果如下：</p>


<p>表中有 9 个结点只需查找 1 次，5 个结点需要查找 2 次，查找成功的平均查找次数：</p>
<p>ASLs = (9+5*2)/14 = 1.36</p>
<p>以下是分离链接法的代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYLENGTH 15    <span class="comment">/* 关键字符串的最大长度 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElementType[KEYLENGTH+<span class="number">1</span>];  <span class="comment">/* 关键词类型用字符串 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;  <span class="comment">/* 散列地址类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span>* <span class="title">HashTable</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> TableSize;</span><br><span class="line">    List Heads; <span class="comment">/* 指向链表头结点的数组 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>散列表结构包括一个 TableSize 记录表的最大长度以及一个节点数组对应的单链表，它们在初始化时动态分配空间，并设置相应的初值。</p>
<p>以下是散列表的初始化函数 CreateTable。首先申请散列表的头结点空间；然后确定一个不小于 TableSize 的素数，用作真正的散列表的地址空间大小；最后动态分配散列表的地址列表数组并初始化空的头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HashTable <span class="title">CreateTable</span><span class="params">(<span class="keyword">int</span> TableSize)</span> </span>&#123;</span><br><span class="line">    HashTable H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TblNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保证散列的最大长度是素数 */</span></span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配链表表头节点数组 */</span></span><br><span class="line">    H-&gt;Heads = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode)*H-&gt;TableSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化表头节点 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;H-&gt;TableSize; i++) &#123;</span><br><span class="line">        H-&gt;Heads[<span class="number">0</span>].Data[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        H-&gt;Heads.Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是查找 Find 函数。首先调用 Hash 函数计算地址，得到关键字所在的 Heads 中单元的下标 Pos；P 则指向 Heads[Pos] 链表中真正的第一个元素。因为关键字是字符串，所以 while 循环条件判断要用 strcmp 函数来比较 Data 与 Key 的值。若找到了关键词，函数直接返回结点的地址，若找不到则返回空地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(HashTable H, ElementType Key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Position Pos = Hash(Key,H-&gt;TableSize);  <span class="comment">/* 找到该Key的位置 */</span></span><br><span class="line"></span><br><span class="line">    Index P = H-&gt;Heads[Pos].Next;   <span class="comment">/* 从该链表的第一个节点开始 */</span></span><br><span class="line">    <span class="comment">/* 当未到表尾，并且Key未找到时 */</span></span><br><span class="line">    <span class="keyword">while</span>(P &amp;&amp; <span class="built_in">strcmp</span>(P-&gt;Data,Key))</span><br><span class="line">        P=P-&gt;Next;</span><br><span class="line">    <span class="comment">/* 此时P指向找到的节点或者NULL */</span></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是插入函数 Insert。该函数首先调用 Find 函数，如果找到了关键词则不需要插入，返回插入不成功的信息；如果找不到关键词才需要插入。插入时，先申请一个新结点 NewCell，然后计算 Key 的地址 Pos，插入成为单链表 Heads[Pos] 的第一个结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(HashTable H, ElementType Key)</span> </span>&#123;</span><br><span class="line">    Position P = Find(H, Key);</span><br><span class="line">    <span class="keyword">if</span>(!P) &#123;</span><br><span class="line"></span><br><span class="line">        Position NewCell = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        <span class="built_in">strcpy</span>(NewCell-&gt;Data, Key);</span><br><span class="line">        Index Pos=Hash(Key,H-&gt;TableSize);</span><br><span class="line">        <span class="comment">/* 将NewCell插入为H-&gt;Heads[Pos]链表的第一个节点 */</span></span><br><span class="line">        NewCell-&gt;Next = H-&gt;Heads[Pos].Next;</span><br><span class="line">        H-&gt;Heads[Pos].Next =NewCell;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关键词已存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放 CreateTable 所占用的内存空间可以调用如下 DestroyTable 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryTable</span><span class="params">(HashTable H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Position P, temp;</span><br><span class="line">    <span class="comment">/* 释放链表的每个节点 */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;H-&gt;TableSize; i++) &#123;</span><br><span class="line">        P = H-&gt;Heads[i].Next;</span><br><span class="line">        <span class="keyword">while</span>(P) &#123;</span><br><span class="line">            temp = P-&gt;Next;</span><br><span class="line">            <span class="built_in">free</span>(P);</span><br><span class="line">            P = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(H-&gt;Heads); <span class="comment">/* 释放头结点数组 */</span></span><br><span class="line">    <span class="built_in">free</span>(H);    <span class="comment">/* 释放散列表节点 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分离链接法的删除操作与链表的删除操作相似。不过需要先通过 Hash 函数得到链表的头结点，再在该链表中进行删除即可。</p>
<h2 id="散列表的性能分析"><a href="#散列表的性能分析" class="headerlink" title="散列表的性能分析"></a>散列表的性能分析</h2><p>在上面的介绍中，我们已经用 ASL 来度量散列表的查找效率。查找过程中，关键词比较的次数，取决于产生冲突的多少。产生的冲突多，查找效率就高；产生的冲突多，查找效率就低.因此，影响产生冲突多少的因素，也就是影响查找效率的因素。主要有以下三个因素：</p>
<ul>
<li><p>散列函数是否均匀</p>
</li>
<li><p>处理冲突的方法</p>
</li>
<li><p>散列表的装填因子</p>
</li>
</ul>
<h3 id="线性探测法的查找性能"><a href="#线性探测法的查找性能" class="headerlink" title="线性探测法的查找性能"></a>线性探测法的查找性能</h3><p>可以证明，线性探测法的期望探测次数满足下列公式：</p>


<h3 id="平方探测法和双散列探测法的查找性能"><a href="#平方探测法和双散列探测法的查找性能" class="headerlink" title="平方探测法和双散列探测法的查找性能"></a>平方探测法和双散列探测法的查找性能</h3><p>可以证明，平方探测法和双散列探测法的期望探测次数满足下列公式：</p>


<p>下图表示了上面几种探测法的期望探测次数与装填因子之间的关系：</p>


<p>由图可知，当装填因子 &lt; 0.5 的时候，各种探测法的期望探测次数都不大，也比较接近。随着装填因子的增大，线性探测法的期望探测次数增加较快，不成功查找和插入操作的期望探测次数明显比成功查找的期望探测次数要大。合理的装填因子应该不超过0.85。</p>
<h3 id="分离链接法的查找性能"><a href="#分离链接法的查找性能" class="headerlink" title="分离链接法的查找性能"></a>分离链接法的查找性能</h3><p>我们把分离链接法中的每个链表的平均长度定义成装填因子，因此装填因子有可能超过 1。</p>
<p>不难证明，其期望探测次数为：</p>


<h2 id="散列的特点"><a href="#散列的特点" class="headerlink" title="散列的特点"></a>散列的特点</h2><p>1.选择合适的 h(key)，散列法的查找效率期望是常数 O(1)，它几乎与关键字的空间的大小 N 无关，也适合于关键字直接比较计算量大的问题；</p>
<p>2.它是以较小的装填因子为前提，因此，散列方法是一个以空间换时间；</p>
<p>3.散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找。</p>
<h3 id="开放地址法的特点"><a href="#开放地址法的特点" class="headerlink" title="开放地址法的特点"></a>开放地址法的特点</h3><p>1.散列表是一个数组，存储效率高，随即查找；</p>
<p>2.散列表有聚集现象</p>
<h3 id="分离链接法的特点"><a href="#分离链接法的特点" class="headerlink" title="分离链接法的特点"></a>分离链接法的特点</h3><p>1.散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低；</p>
<p>2.关键字删除不需要懒惰删除法，因此没有存储垃圾；</p>
<p>3.太小的装填因子可能导致空间浪费，大的装填因子又会付出更多的时间代价。不均匀的链表长度导致时间效率严重下降。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>散列查找</tag>
        <tag>散列表</tag>
        <tag>哈希表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>堆,哈夫曼树及集合</title>
    <url>/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%913/</url>
    <content><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>前面介绍过队列，它是一种先进先出的数据结构，队列中没有哪一个元素是有特权的，前面的元素未处理完，后面的只能等待。而本文章介绍的堆（Heap）正是考虑了适合于特权需求的数据结构，因此，堆也通常被称为“优先队列”（Priority Queue）。</p>
<a id="more"></a>

<h3 id="堆的定义和表示"><a href="#堆的定义和表示" class="headerlink" title="堆的定义和表示"></a>堆的定义和表示</h3><blockquote>
<p>堆是特殊的队列，从中取出元素是依照元素的优先级大小，而不是元素进入队列的先后顺序。</p>
</blockquote>
<p>那么我们应该如何组织优先队列的存储结构呢？</p>
<p>如采用数组或者链表实现优先队列</p>
<ul>
<li><p>数组<br>插入：元素总是插入尾部：O(1)<br>删除：查找最大或最小值：O(N)<br>从数组中删除需要移动元素：O(N)</p>
</li>
<li><p>链表<br>插入：元素总是插入在链表头部：O(1)<br>删除：查找最大或最小值：O(N)<br>删除结点：O(1)</p>
</li>
<li><p>有序数组<br>插入：找到合适的位置：O(N)或O(logN)<br>移动元素并插入：O(N)<br>删除：删除最后一个元素：O(1)</p>
</li>
<li><p>有序链表<br>插入：找到合适的位置：O(N)<br>插入元素：O(1)<br>删除：删除首元素或者最后一个元素：O(1)</p>
</li>
</ul>
<p>上面 4 种方式，其最坏时间复杂度都达到了 O(N)，而我们知道二叉搜索树的插入和删除操作代价为 O(logN)。因此我们可以利用树型结构来组织数据。</p>
<p><strong>堆最常用放入结构是用二叉树表示，不特指的话，它是一颗完全二叉树。</strong>由于完全二叉树的排列及其规则，因此我们可以使用数组来实现堆的存储。</p>


<p>堆中的元素是按照完全二叉树的层序存储的，还需要注意的是所用数组的起始单元为 1，这样做的目的是更容易从子结点找到父结点。根据完全二叉树的性质，对于下标为 i 的结点，其父结点的下标为 [i/2]。反过来，找结点 i 的左右子结点也非常方便，分别为 2i 和 2i + 1。</p>
<p>堆的两个特性：</p>
<ul>
<li><p>结构性：用数组表示的完全二叉树</p>
</li>
<li><p>有序性：任一结点的关键字是其子树所有结点的最大值或最小值<br>在最大堆（MaxHeap）中，任一结点的值大于或等于其子结点的值，那么根元素是整个堆中最大的；<br>在最小堆（MinHeap）中，任一结点的值小于或等于其子结点的值，那么根元素是整个堆中最小的。</p>
</li>
</ul>
<p>注意：从根节点到任意节点路径上结点序列的有序性！</p>


<h3 id="堆的抽象数据类型描述"><a href="#堆的抽象数据类型描述" class="headerlink" title="堆的抽象数据类型描述"></a>堆的抽象数据类型描述</h3><p>以最大堆为例介绍堆的抽象数据类型描述：</p>
<p>类型名称：最大堆（MaxHeap）</p>
<p>数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值</p>
<p>操作集：最大堆 H∈MaxHeap，元素 item∈ElementType，主要操作有：</p>
<ul>
<li><p><code>MaxHeap CreateHeap(int MaxSize)</code>：创建长度为 MaxSize 的空最大堆</p>
</li>
<li><p><code>bool IsFull(MaxHeap H)</code>：判断最大堆是否已满</p>
</li>
<li><p><code>bool Insert(MaxHeap H, ElementType X)</code>：将元素 X 插入最大堆</p>
</li>
<li><p><code>bool IsEmpty(MaxHeap H)</code>：判断堆是否为空</p>
</li>
<li><p><code>ElementType DeleteMax(MaxHeap H)</code>：删除并返回最大元素</p>
</li>
</ul>
<p>因此用 C 语言描述最大堆如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span>* <span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;      <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    <span class="keyword">int</span> Size;               <span class="comment">/* 堆中当前元素个数 */</span></span><br><span class="line">    <span class="keyword">int</span> Capacity;           <span class="comment">/* 堆的最大容量 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最大堆的创建"><a href="#最大堆的创建" class="headerlink" title="最大堆的创建"></a>最大堆的创建</h3><p>注意到根据用户的输入 MaxSize 创建最大堆时，数组应该有 MaxSize + 1 个元素，因为数组起始单元为 1，元素值存在第 1——MaxSize 个单元中。通常第 0 个单元是无用的，但是如果事先知道堆中所有元素的取值范围，也可以给第 0 个单元赋一个特殊的值 MAXDATA，这个值比堆中任何一个元素都要大。这人 MAXDATA 的“哨兵”作用会在插入操作中用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">CreateHeap</span><span class="params">(<span class="keyword">int</span> MaxSize)</span> </span>&#123;</span><br><span class="line">    MaxHeap H = (MaxHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HNode));</span><br><span class="line">    H-&gt;Data = (ElementType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType)*(MaxSize+<span class="number">1</span>));</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Data[<span class="number">0</span>] = MAXDATA;  </span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大堆的插入"><a href="#最大堆的插入" class="headerlink" title="最大堆的插入"></a>最大堆的插入</h3><p>最大堆中插入一个新元素以后，新增结点既要保证最大堆仍是一个完全二叉树，结点之间的元素值大小也要满足最大堆的性质，因此需要移动元素。</p>
<p>完成一个元素的最大堆插入操作，只要从完全二叉树的新增结点开始，顺着其父结点到根结点的路径，将路径上各点依次与新元素值进行比较，当一结点的值小于新元素的值，就下移这个结点的元素，直到有结点的值大于新元素的值或者根结点也下移为止，空出的结点位置就是新元素插入点。</p>
<p>插入过程可以用一句话简单描述：从新增的最后一个结点的父结点开始，用要插入的元素向下过滤上层结点。实际上，由于堆元素之间的部分有序性，最大堆从根结点到任一叶结点的路径都是递降的有序序列。插入过程的调整就是继续保证这个序列的有序性。</p>
<p>如下给出了最大堆的插入操作算法。注意到如果新插入的 X 比原先堆中所有的元素都大，那么它将一直向上比较到根结点都不会停止。对于这种情况，我们可以加一个特殊判断，当 i 值取 1 时，直接跳出循环，但是这种程序不够优美。因此之前我们定义了一个“哨兵”，即事先知道堆中所有元素的取值范围，这样可以给 H-&gt;Data[0] 赋一个特殊的值 MAXDATA，这个值比堆中所有元素都要大，这样当 i 为 1 时 H-&gt;Data[i/2] &lt; X 这个条件肯定不满足，跳出循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(MaxHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> H-&gt;Size == H-&gt;Capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(MaxHeap H, ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ++(H-&gt;Size);        <span class="comment">/* i指向插入后堆中最后一个元素 */</span></span><br><span class="line">        <span class="keyword">for</span>( ; H-&gt;Data[i/<span class="number">2</span>] &lt; X; i/=<span class="number">2</span>)</span><br><span class="line">            H-&gt;Data[i] = H-&gt;Data[i/<span class="number">2</span>];  <span class="comment">/* 上滤 X */</span></span><br><span class="line">        H-&gt;Data[i] = X;     <span class="comment">/* 找到位置将 X 插入 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的时间复杂度为 O(logN)。</p>
<h3 id="最大堆的删除"><a href="#最大堆的删除" class="headerlink" title="最大堆的删除"></a>最大堆的删除</h3><p>最大堆的删除实际上是取出根结点的最大值元素，同时删除堆的一个结点。删除后仍要是一颗完全二叉树，结点元素的大小仍要满足最大堆的性质。因此删除的结点应该是数组的最后一个单元。即取走根结点之后，最后一个结点必须重新放置。确定最后一个结点放置在哪里是最大堆删除的关键。</p>
<p>因此我们可以将堆中的最后一个元素当成假设的根结点，依次与下层的子结点进行比较，如果小于子结点的值，从子结点中选择较大的元素上移一层，直到在某一点上，比较结果是大于两个子结点的值，此时的空结点就是元素要放置的位置。</p>
<p>删除过程可用一句简单的话描述：从根节点开始，用最大堆中最后一个元素向上过滤下层结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(MaxHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> H-&gt;Size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(MaxHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ElementType MaxItem = H-&gt;Data[<span class="number">1</span>];   <span class="comment">/* 取出根结点存放最大值 */</span></span><br><span class="line">    <span class="comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span></span><br><span class="line">    ElementType X = H-&gt;Data[(H-&gt;Size)--];  <span class="comment">/* 注意堆的规模要减1 */</span></span><br><span class="line">    <span class="keyword">int</span> Parent,Child;</span><br><span class="line">    <span class="keyword">for</span>(Parent=<span class="number">1</span>; <span class="number">2</span>*Parent &lt;= H-&gt;Size; Parent=Child) &#123;</span><br><span class="line">        Child = <span class="number">2</span>*Parent;   <span class="comment">/* 先将最大儿子设为左儿子 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果存在右儿子，并且右儿子的值大于左儿子，则将最大儿子设为右儿子 */</span></span><br><span class="line">        <span class="keyword">if</span>((Child+<span class="number">1</span>) &lt;= H-&gt;Size &amp;&amp; H-&gt;Data[Child+<span class="number">1</span>] &gt; H-&gt;Data[Child])</span><br><span class="line">            Child++;</span><br><span class="line">        <span class="keyword">if</span>(X &gt;= H-&gt;Data[Child]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其时间复杂度也为 O(logN)。</p>
<h3 id="最大堆的建立"><a href="#最大堆的建立" class="headerlink" title="最大堆的建立"></a>最大堆的建立</h3><p>建立最大堆是指如何将已经存在的 N 个元素按照最大堆的要求存放在一个一位数组里面。主要有如下两种方法：</p>
<ul>
<li><p>通过插入操作，将 N 个元素依次插入到一个初始为空的堆中去，其时间复杂度显然是 O(NlogN)。</p>
</li>
<li><p>在线性时间复杂度下建立最大堆。<br>将 N 个元素按照输入顺序存入二叉树中，这一步只需要满足完全二叉树的结构特性；接着调整各结点的位置，以满足最大堆的有序特性。</p>
</li>
</ul>
<p>我们主要介绍第二种方法：</p>
<p>首先将 N 个元素读入数组，接着从第 [N/2] 个结点（这是最后面一个有儿子的结点）开始，对包括此节点在内的其它前面各节点 [N/2]-1,[N-2]-2,…逐一向下进行过滤，直到根结点过滤完毕，最大堆也就建立起来了。</p>
<p>首先实现向下过滤的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">(MaxHeap H, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 对堆中的第 p 个结点向下过滤，与删除操作类似 */</span></span><br><span class="line">    ElementType X = H-&gt;Data[p];</span><br><span class="line">    <span class="keyword">int</span> Parent,Child;</span><br><span class="line">    <span class="keyword">for</span>(Parent = p; <span class="number">2</span>*Parent &lt;= H-&gt;Size; Parent=Child) &#123;</span><br><span class="line">        Child = <span class="number">2</span>*Parent;   <span class="comment">/* 先将最大儿子设为左儿子 */</span></span><br><span class="line">        <span class="comment">/* 如果存在右儿子，并且右儿子的值大于左儿子，则将最大儿子设为右儿子 */</span></span><br><span class="line">        <span class="keyword">if</span>((Child+<span class="number">1</span>) &lt;= H-&gt;Size &amp;&amp; H-&gt;Data[Child+<span class="number">1</span>] &gt; H-&gt;Data[Child])</span><br><span class="line">            Child++;</span><br><span class="line">        <span class="keyword">if</span>(X &gt;= H-&gt;Data[Child]) <span class="keyword">break</span>;  <span class="comment">/* 找到合适的位置 */</span></span><br><span class="line">        <span class="keyword">else</span> H-&gt;Data[Parent] = H-&gt;Data[Child];  <span class="comment">/* 下滤 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着从第 [N/2] 个结点（这是最后面一个有儿子的结点）开始，对包括此节点在内的其它前面各节点 [N/2]-1,[N-2]-2,…逐一向下进行过滤，直到根结点过滤完毕。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(MaxHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 调整堆中的元素，使其满足有序性 */</span></span><br><span class="line">    <span class="comment">/* 这里假设所有 H-&gt;Size 个元素已经存在 H-&gt;Data[] 中 */</span></span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="comment">/* 从最后一个有孩子的父结点开始，到根结点1 */</span></span><br><span class="line">    <span class="keyword">for</span>(p = H-&gt;Size/<span class="number">2</span>; p&gt;=<span class="number">1</span>; p--) &#123;</span><br><span class="line">        PercDown(H,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度为 O(N)。证明如下：</p>


<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>首先看一个简单的例子，要求编写一个程序将百分制成绩转化成五分制成绩。首先给出一个简单的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &lt; <span class="number">60</span>) grade = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">70</span>) grade = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">80</span>) grade = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">90</span>) grade = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> grade = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>其判定树如下：</p>


<p>如果考虑学生的成绩分布概率：</p>


<p>则该判定树的查找效率为：0.05x1 + 0.15x2 + 0.4x3 + 0.3x4 + 0.1x4 = 3.15</p>
<p>如果根据概率修改判定树：</p>


<p>则查找效率变为：0.05x3 + 0.15x3 + 0.4x2 + 0.3x2 + 0.1x2 = 2.2</p>
<p>由此可见，同一问题采用不同的判定逻辑，计算效率是不一样的。那么是否能够找到最好的比较判定逻辑，使运算效率达到最高？即如何根据结点不同的查找频率构造更有效的搜索树？</p>
<h3 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h3><blockquote>
<p>带权路径长度：结点的带权路径长度是指从根结点到该结点之间的路径长度与该结点上所带权值的乘积。</p>
</blockquote>
<p>设一棵树有 n 个叶子结点，每个叶结点带有权值 Wk，从根结点到每个叶结点的长度为 lk，则每个叶结点的带权路径长度之和就是这棵树的带权路径长度（Weighted Path Length,WPL），它可以表示为：</p>
<p>WPL = W1xl1 + W2xl2 + W3xl3 + … + Wkxlk</p>
<blockquote>
<p>假设有 n 个权值构造了 n 个叶结点的二叉树，每个叶子的权重是 n 个权重之一，这样的二叉树可以构造出很多个，其中必有一个是带权路径长度最小的，这颗二叉树称为最优二叉树或哈夫曼树。</p>
</blockquote>
<h3 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h3><p>由哈夫曼树和带权路径长度的定义可知，一棵二叉树要使其 WPL 最小，必须使权值越大的叶结点越靠近根结点，而权值越小的叶结点越远离根结点。哈夫曼根据这一特点提出了一种方法，它是一种贪心算法。该算法在初始状态下将每个字符看成一颗独立的树，每一步执行两棵树的合并，而选择合并对象的原则是“贪心”的，即每次选择权最小的两个数进行合并。具体过程如下：</p>
<p>1.由给定的 n 个权值构造出 n 颗只有一个叶结点的二叉树，从而得到一个二叉树的集合 F；</p>
<p>2.从 F 中选取根结点的权值最小和次小的两颗二叉树作为左右子树构造出一颗新的二叉树，这棵新的二叉树根结点的权值为左右子树根结点权值之和；</p>
<p>3.在集合中删除上一步中作为左右子树的两颗二叉树，并将新构造的二叉树加入到集合 F 中；</p>
<p>4.重复2、3步，当 F 中只剩下一颗二叉树时，这颗二叉树就是所要建立的哈夫曼树。</p>
<p>需要注意的是：对于同一组给定权值叶结点所构造的哈夫曼树，树的形状可能不同。但无论形状如何，这些哈夫曼树的带权路径长度是相同的，并一定都是同一最小值。</p>
<p>为了便于抽取最小权值的子树，在构造树过程中使用最小堆的删除及插入操作。这里堆中的元素是一个加了权值的树结点的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span>* <span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Weight;         <span class="comment">/* 结点权值 */</span></span><br><span class="line">    HuffmanTree Left;   <span class="comment">/* 指向左子树 */</span></span><br><span class="line">    HuffmanTree Right;  <span class="comment">/* 指向右子树 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 定义最小堆，最小堆里面每一个元素都是一颗哈夫曼树 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span>* <span class="title">MinHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> &#123;</span></span><br><span class="line">    HuffmanTree *Data;</span><br><span class="line">    <span class="keyword">int</span> Size;</span><br><span class="line">    <span class="keyword">int</span> Capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 最小堆里面的元素类型都是 HuffmanTree</span></span><br><span class="line"><span class="comment">       假设 H-&gt;Size 个权值已经存在 H-&gt;Data[i]-&gt;Weight 里</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 H-&gt;Data[]按权值 Weight 调整为最小堆 */</span></span><br><span class="line">    BuildHeap(H);</span><br><span class="line">    <span class="keyword">int</span> N = H-&gt;Size;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123; <span class="comment">/* 做 H-&gt;Size - 1次合并 */</span></span><br><span class="line">        <span class="comment">/* 选取两个权值最小的构建新的哈夫曼树 */</span></span><br><span class="line">        T = (HuffmanTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HTNode)); <span class="comment">/* 新建一个新的根结点 */</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);                         <span class="comment">/* 从最小堆中删除一个结点，作为 T 的左子树 */</span></span><br><span class="line">        T-&gt;Right = DeleteMin(H);                        <span class="comment">/* 从最小堆中删除一个结点，作为 T 的右子树 */</span></span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;   <span class="comment">/* 新树的权值为两个子树权值之和 */</span></span><br><span class="line">        <span class="comment">/* 将 T 插入到堆中 */</span></span><br><span class="line">        Insert(H, T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DeleteMin(H); <span class="comment">/* 最小堆中最后一个元素即是指向哈夫曼树根结点的指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，Huffman 算法的时间复杂度为 O(NlogN)。</p>
<p>哈夫曼树的特点：</p>
<ul>
<li><p>没有度为 1 的结点；</p>
</li>
<li><p>n 个叶子结点的哈夫曼树共有 2n-1 个结点；</p>
</li>
<li><p>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树；</p>
</li>
<li><p>对于同一组权值，存在不同构的两颗哈夫曼树。<br>如权值{1,2,3,3}，不同构的两颗哈夫曼树如下：</p>


</li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>问题：给定一段字符串，如何对其中的字符进行编码，使得该字符串的编码存储空间最少？当然从存储空间取出的编码必须通过对应的解码才能还原出字符串。</p>
<p>上述问题的最优解决方法是哈夫曼提出的，按他给出的算法得到的编码就称为“哈夫曼编码”，是进行文件压缩的有效方法，其压缩比通常在 20% 到 90%。</p>
<p>可见的 ASCII 字符大约有一百个左右，加上部分不可见字符，可以用 7 位来识别它们，再加上 1 位校验码，所以一般用 8 位即一个字节来表示一个字符。但在一般的文本中每个字符出现的频率是不同的，且差异较大，通常只是少量不同字符在大量重复出现，用 8 位来存储每个字符是比较浪费的。</p>
<p>假设有一段文本，包含 58 个字符，并由以下 7 个字符构成：a,e,i,s,t,空格(sp),换行(nl)；这 7 个字符出现的次数不同。如何对这 7 个字符进行编码，使得总编码空间最少。</p>
<p>分析：</p>
<ul>
<li><p>采用等长 ASCII 编码：58x8 = 464 位；</p>
</li>
<li><p>仔细分析里面只有 7 个字符是不同的，因此我们完全可以用等长 3 位编码来识别它们。例如可令 a=000,e=001,i=010,s=011,t=100,sp=101,nl=110。这时空间为 58x3 = 174 位；</p>
</li>
<li><p>采用不等长编码：出现频率高的字符用的编码短些，出现频率低的字符则可以编码长些。</p>
</li>
</ul>
<p>因此我们需要解决两个问题：怎么进行不等长编码？如何避免编码的二义性？</p>
<p>不等长编码实际上就是根据字符出现的概率进行编码。</p>
<blockquote>
<p>定义 前缀码：任何字符的编码都不是另一个字符编码的前缀。</p>
</blockquote>
<p>为了避免二义性，所有字符都有应该在二叉树的叶结点上，哈夫曼编码也称为前缀编码。</p>
<p>因此采用哈夫曼树的生成方法可以满足以上要求。</p>


<h2 id="集合及其运算"><a href="#集合及其运算" class="headerlink" title="集合及其运算"></a>集合及其运算</h2><p>集合是一种常用的数据表示方法。集合的运算包括交、并、补、差以及判定一个数据是否是某一集合中的元素。</p>
<p>为了有效地对集合执行各种操作，可以用树结构表示集合，树的每个结点代表一个集合元素。</p>


<p>我们也可以采用数据形式存储集合，数组的每一项是一个结构体，结构体里面是元素值，以及其父元素对应的数组下标，负数代表根节点，非负数代表其父元素的数组下标。</p>


<p>因此可以定义如下结构体来表示集合：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000    <span class="comment">/* 集合的最大容量 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="keyword">int</span> Parent;</span><br><span class="line">&#125; SetType;</span><br></pre></td></tr></table></figure>

<p>1.查找元素所在集合（用根结点表示）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(SetType S[], ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 在数组 S 中查找值位 X 的元素所属集合</span></span><br><span class="line"><span class="comment">       MAXSIZE 为数组 S 的最大长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MAXSIZE &amp;&amp; S[i].Data!=X; i++);</span><br><span class="line">    <span class="keyword">if</span>(i==MAXSIZE)  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* 未找到 X，返回 -1 */</span></span><br><span class="line">    <span class="comment">/* 找到 X，则查找其父结点，直到父结点为负数 */</span></span><br><span class="line">    <span class="keyword">for</span>(; S[i].Parent&gt;=<span class="number">0</span>; i=S[i].Parent);</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">/* 找到 X 所属集合，返回根结点在数组 S 中的下标 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.集合的并运算</p>
<ul>
<li><p>分别找到 X1 和 X2 两个元素所在集合树的根结点</p>
</li>
<li><p>如果它们根结点不同，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[], ElementType X1, ElementType X2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Root1 = Find(S,X1);</span><br><span class="line">    <span class="keyword">int</span> Root2 = Find(S,X2);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2) S[Root1].Parent = Root2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们进行两个集合的合并时，我们希望合并后的集合树的深度尽可能小，这样才能提高查找效率。因此如果每次合并都能比较以下树的高矮，将矮树合并到高树上，这样就能有良好的查找效率。</p>
<p>当然要做到这一点，我们需要知道每个集合的树的高度，而这并不是很容易做到。比较容易获得的是集合当前的元素个数，用个数替换高度也可以起到比较好的作用。这种按照规模或者按照高度合并的算法，统称为按“秩”合并。</p>
<p>因此我们可以把对应集合的树的总结点数存在根结点单元里，同时在它前面加上符号。因此对上面的代码进行改写之后有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[], ElementType X1, ElementType X2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Root1 = Find(S,X1);</span><br><span class="line">    <span class="keyword">int</span> Root2 = Find(S,X2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)&#123;</span><br><span class="line">        <span class="comment">/* 将元素少的集合合并到元素多的集合中，集合中元素个数用的负数表示 */</span></span><br><span class="line">        <span class="keyword">if</span>(S[Root1].Data &gt; S[Root2].Data) &#123;</span><br><span class="line">            S[Root1].Parent = Root2;</span><br><span class="line">            S[Root2].Data += S[Root1].Data; <span class="comment">/* 更新集合中元素个数 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            S[Root2].Parent = Root1;</span><br><span class="line">            S[Root1].Data += S[Root2].Data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>堆</tag>
        <tag>哈夫曼树</tag>
        <tag>哈夫曼编码</tag>
        <tag>集合及运算</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树与平衡二叉树</title>
    <url>/2019/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%912/</url>
    <content><![CDATA[<p>二叉搜索树始终特殊的二叉树,它主要用于解决动态查找问题,能够比较快速地查找出想要的元素.而平衡二叉树是对二叉搜索树的改进,它本身也是一颗平衡二叉树,它保证查找所有结点的比较次数的平均值即树的“平均查找长度”最小.</p>
<a id="more"></a>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>查找问题可分为静态查找和动态查找，静态查找可以用二分查找算法，针对动态查找，数据应该如何组织呢？</p>
<h3 id="二叉搜索树的定义"><a href="#二叉搜索树的定义" class="headerlink" title="二叉搜索树的定义"></a>二叉搜索树的定义</h3><p>二叉搜索树（Binary Search Tree）也叫二叉排序树或二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。一个二叉搜索树是一颗二叉树，它可以为空，如果不为空，它将满足以下性质：</p>
<ul>
<li><p>非空左子树的所有值小于其根节点的值</p>
</li>
<li><p>非空右子树的所有值大于其根节点的值</p>
</li>
<li><p>左、右子树都是二叉搜索树</p>
</li>
</ul>
<p>由于二叉搜索树具有左小右大的特点，因此对它进行中序遍历，将得到一个从小到大的输出序列。</p>
<h3 id="二叉搜索树的动态查找"><a href="#二叉搜索树的动态查找" class="headerlink" title="二叉搜索树的动态查找"></a>二叉搜索树的动态查找</h3><p>二叉搜索树的抽象数据结构定义与普通二叉树基本相同，只是多个以下几个特别的函数：</p>
<p>1.<code>Position Find(BinTree BST, ElementType X)</code>：从二叉搜索树 BST 中查找元素 X，并返回其地址；</p>
<p>2.<code>Position FindMin(BinTree BST)</code>：查找并返回最小值的地址；</p>
<p>3.<code>Position FindMax(BinTree BST)</code>：查找并返回最大值的地址。</p>
<h4 id="二叉搜索树的查找操作-Find"><a href="#二叉搜索树的查找操作-Find" class="headerlink" title="二叉搜索树的查找操作 Find"></a>二叉搜索树的查找操作 Find</h4><p>1.查找从根节点开始，如果树为空返回 NULL，表示未找到</p>
<p>2.如果不为空，则将根节点与 X 进行比较，根据比较结果进行不同的处理：</p>
<ul>
<li>若 X 大于根节点的值，则在右子树中查找</li>
<li>若 X 小于根节点的值，则在左子树中查找</li>
<li>相等表示找到了，返回此结点</li>
</ul>
<p>以下是找到的递归算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* 查找失败 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(BST-&gt;Right,X);  <span class="comment">/* 右子树中递归查找 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(BST-&gt;Left,X);   <span class="comment">/* 左子树中递归查找 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;                 <span class="comment">/* 查找成功 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是查找的非递归算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BinTree T = BST;</span><br><span class="line">    <span class="keyword">while</span>(T) &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; T-&gt;Data)</span><br><span class="line">            T = T-&gt;Right;       <span class="comment">/* 在右子树中查找 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;Data)</span><br><span class="line">            T = T-&gt;Left;        <span class="comment">/* 在左子树中查找 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找最大值和最小值"><a href="#查找最大值和最小值" class="headerlink" title="查找最大值和最小值"></a>查找最大值和最小值</h4><p>根据二叉搜索树的性质，最小值一定在二叉搜索树的最左分支的端点上，而最大值一定在最右分支的端点上。</p>
<p>以下是分别使用递归算法和非递归算法实现的查找最大值和最小值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(BinTree BST)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;               <span class="comment">/* 空二叉树返回NULL */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right) <span class="keyword">return</span> BST;    <span class="comment">/* 找到最右端点并返回 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> FindMax(BST-&gt;Right);    <span class="comment">/* 右子树递归查找 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(BinTree BST)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(BST-&gt;Left)</span><br><span class="line">        BST = BST-&gt;Left;    <span class="comment">/* 沿左分支一直向下，直到最左端点 */</span></span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><p>将元素 X 插入二叉搜索树 BST 中关键是找到元素插入的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">(BinTree BST,ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) &#123;</span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Insert(BST-&gt;Right,X);  <span class="comment">/* 递归插入右子树 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Insert(BST-&gt;Left,X);    <span class="comment">/* 递归插入左子树 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><p>考虑三种情况：</p>
<ul>
<li><p>要删除的是叶结点：直接删除，并修改其父节点指针——置为 NULL</p>

</li>
<li><p>要删除的结点只有一个孩子节点：将其父节点的指针指向要删除结点的孩子节点</p>

</li>
<li><p>要删除结点有左、右两颗子树：用另一结点替换被删除结点：右子树中最小元素 或 左子树中最大元素</p>


</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class="line">    Position tmp;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;Right,X);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Delete(BST-&gt;Left,X);</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">/* 找到了要删除的结点 */</span></span><br><span class="line">            <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;   <span class="comment">/* 被删除结点有左右两个儿子 */</span></span><br><span class="line">                <span class="comment">/* 两种方法1.左子树中找最大的替换该结点 2.右子树中找最小的替换该结点 */</span></span><br><span class="line">                tmp = FindMin(BST-&gt;Right)</span><br><span class="line">                BST-&gt;Data = tmp-&gt;Data;</span><br><span class="line">                BST-&gt;Right = Delete(BST-&gt;Right,BST-&gt;Data);  <span class="comment">/* 在删除结点的右子树中删除该最小元素 */</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* 被删除结点有一个或无子节点 */</span></span><br><span class="line">                tmp = BST;</span><br><span class="line">                <span class="keyword">if</span>(!BST-&gt;Left)          <span class="comment">/* 有右孩子或者无子节点 */</span></span><br><span class="line">                    BST = BST-&gt;Right;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)    <span class="comment">/* 有左孩子或者无子节点 */</span>  </span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>对于二叉搜索树进行查找的时间复杂度是由是由查找过程中的比较次数来衡量的，比较是从根结点到叶结点的路径进行的，它取决于树的深度。树深在最好情况下是 logN，所以二叉搜索树在最好情况的查找复杂度是 O(logN)。但这一结论是由完全二叉树导出的，事实上 N 个结点的二叉树深度取决于其树枝的分布情况。当二叉树退化为一颗单枝树的极端情况下，查找时间复杂度将是线性的 O(N)。</p>
<p>假定二叉树中每个结点的查找概率都是相同的，我们称查找所有结点的比较次数的平均值为树的“平均查找长度”(Average Search Length,ASL)。如下图所示，可以得到各二叉树的平均查找长度：</p>


<p>上述示例表明，一棵树的 ASL 值越小，它的结构越好，与完全二叉树越接近，对它的查找时间复杂度也越接近 O(logN)。因此为了保证二叉树查找的对数级查找时间效率。设计出了平衡二叉树这一数据结构。</p>
<h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><p>平衡二叉树又称 AVL 树，它也是一颗二叉搜索树。</p>
<blockquote>
<p>定义：AVL树是一颗空树或者是具有以下性质的非空二叉搜索树：<br>1.任一结点的左右子树均为 AVL 树；<br>2.根结点左右子树的高度差的绝对值不超过 1。</p>
</blockquote>


<blockquote>
<p>定义：对于二叉树中的任一结点 T，其平衡因子（Balance Factor，BF）定义为 BF(T) = hL - hR，其中 hL 和 hR 分别为左右子树的高度。</p>
</blockquote>
<p>因此根结点左右子树的高度差的绝对值不超过 1 可以量化为 |BF(T)| &lt;= 1。</p>
<p>设高度（边的长度）为 h 的平衡二叉树的最少结点数为 nh，则有：</p>
<p>h = 0,   n0 = 1<br>h = 1,   n1 = 2<br>h = 2,   n2 = 4<br>h = 3,   n3 = 7<br>…</p>
<p>依次类推可以得到：nh = n(h-1) + n(h-2) + 1；</p>
<p>求高度（边的长度）为 h 的平衡二叉树的最少结点数要么左边少一层要么右边少一层，因此高度（边的长度）为 h 的平衡二叉树的最少结点数 nh 等于高度（边的长度）为 h-1 的平衡二叉树的最少结点数 + 高度（边的长度）为 h-2 的平衡二叉树的最少结点数。</p>


<h3 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h3><p>1.右单旋</p>


<p>2.左单旋</p>


<p>3.左-右双旋</p>


<p>4.右-左双旋</p>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>二叉搜索树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>树的定义及描述</title>
    <url>/2019/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%91/</url>
    <content><![CDATA[<p>树（Tree）是由 n 个结点构成的有限集合。当 n=0 时，称为空树；对于任意一颗非空树，它具备以下特征：</p>
<ul>
<li>树中有一个称为根的特殊节点，用 r 表示；</li>
<li>其余结点可分为 m 个互不相交的有限集 T1,T2,…,Tm，其中的每个集合本身又是一棵树，称为原来树的子树。</li>
</ul>
<a id="more"></a>

<p>树的特点：</p>
<ul>
<li>子树是不相交的；</li>
<li>除了根节点外，每个结点有且仅有一个父节点；</li>
<li>一颗 N 个结点的树有 N-1 条边。</li>
</ul>
<p>树的一些基本术语：</p>
<p>1.<strong>结点的度</strong>（Degree）：结点的子树个数<br>2.<strong>树的度</strong>：树的所有结点中最大的度数<br>3.<strong>叶结点</strong>（Leaf）：度为 0 的结点<br>4.<strong>父节点</strong>（Parent）：有子树的结点是其子树的根结点的父节点<br>5.<strong>子节点</strong>（Child）：若 A 结点是 B 结点的父节点，则称 B 结点是 A 结点的子节点；子节点也称孩子结点<br>6.<strong>兄弟节点</strong>（Sibling）：具有同一父节点的各节点彼此是兄弟节点<br>7.<strong>结点的层次</strong>（Level）：规定根节点在 1 层，其它任一结点的层次是其父节点层数加1<br>7.<strong>树的深度</strong>（Depth）：树中所有结点中的最大层次是这棵树的深度</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是一个有穷的结点集合。这个集合可以为空，若不为空，则它是由根节点和称为其左子树和右子树的两个互不相交的二叉树组成。一般来讲二叉树有以下 5 种基本形态：</p>


<p>需要注意的是二叉树的子树有左右顺序之分。</p>
<p>特殊的二叉树：</p>
<ul>
<li>斜二叉树</li>
<li>完美二叉树或满二叉树</li>
<li>完全二叉树</li>
</ul>


<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul>
<li>二叉树第 i 层的最大结点数为 2^(i-1), i&gt;= 1</li>
<li>深度为 k 的二叉树有最大结点数 2^k - 1, k&gt;=1</li>
<li>对任何非空的二叉树，若 n0 表示叶结点个数、n2 是度为 2 的非叶结点个数，则有 n0 = n2 + 1。<br>以下是证明：<br>设 n1 表示度为 1 的结点个数，则二叉树的总结点个数为 n0 + n1 + n2;<br>二叉树的边数为 2<em>n2 + n1，总结点数等于边数 + 1；<br>因此：n0 + n1 + n2 = 2</em>n2 + n1 + 1<br>所以 n0 = n2 + 1。</li>
</ul>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>1.顺序存储</p>
<p><strong>完全二叉树</strong>：按从上到下，从左到右顺序存储 n 个结点的完全二叉树的结点父子关系</p>
<ul>
<li>非根节点的父节点的序号是 [i/2];</li>
<li>结点为 i 的左孩子结点序号为 2i；</li>
<li>结点为 i 的右孩子结点序号为 2i+1;</li>
</ul>
 

<p>一般二叉树如果采用这种结构可能造成极大的空间浪费，因此可采用链式存储结构。</p>
<p>2.链式存储</p>
<p>以下是二叉树的链式存储结构示意图：</p>


<p>因此可以用以下代码来表示如上结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">BinTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><p>1.先序遍历</p>
<p>遍历过程为：</p>
<ul>
<li>访问根节点</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ul>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.中序遍历</p>
<p>遍历过程为：</p>
<ul>
<li>中序遍历其左子树</li>
<li>访问根节点</li>
<li>中序遍历其右子树</li>
</ul>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.后序遍历</p>
<p>遍历过程为：</p>
<ul>
<li>后序遍历其左子树</li>
<li>后序遍历其右子树</li>
<li>访问根节点</li>
</ul>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序、中序、后序遍历过程：遍历过程中经过结点的路线一样，只是访问各节点的时机不同。先序是第一次经过该结点就访问，中序是第二次经过该结点访问，后序是第三次经过该结点访问。</p>


<h3 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h3><p><strong>二叉树先序、中序、后序遍历的非递归算法实现的基本思路：使用堆栈。</strong></p>
<p>1.先序遍历的非递归算法</p>
<ul>
<li>遇到一个结点访问之，并将其压入堆栈，再去访问它的左子树</li>
<li>左子树遍历结束之后，从栈顶弹出一个结点</li>
<li>然后再去先序遍历弹出结点的右子树</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MaxSize); <span class="comment">/* 初始化堆栈 */</span></span><br><span class="line">    <span class="keyword">while</span>(T || !Empty(S)) &#123; <span class="comment">/* 如果树不为空或者堆栈不为空 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(T) &#123;</span><br><span class="line">            <span class="comment">/* 遇到一个结点访问之，并将其压入堆栈，再去访问它的左子树 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;Data);</span><br><span class="line">            Push(S,T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!Empty(S)) &#123;</span><br><span class="line">            <span class="comment">/* 左子树遍历完之后，弹出栈顶元素，并遍历其右子树 */</span></span><br><span class="line">            T = Pop(S);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.中序遍历的非递归算法</p>
<ul>
<li>遇到一个结点将其压入堆栈，并去访问它的左子树</li>
<li>当左子树遍历结束之后，从栈顶弹出这个结点并访问它</li>
<li>然后再去中序遍历弹出结点的右子树。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MaxSize); <span class="comment">/* 初始化堆栈 */</span></span><br><span class="line">    <span class="keyword">while</span>(T || !Empty(S)) &#123; <span class="comment">/* 如果树不为空或者堆栈不为空 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(T) &#123;</span><br><span class="line">            <span class="comment">/* 遇到一个结点将其压入堆栈并去访问它的左子树 */</span></span><br><span class="line">            Push(S,T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!Empty(S)) &#123;</span><br><span class="line">            <span class="comment">/* 左子树遍历完之后，弹出栈顶元素，并访问其右子树 */</span></span><br><span class="line">            T = Pop(S);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;Data);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.后序遍历的非递归算法</p>
<ul>
<li>遇到一个节点将其压入堆栈，再访问它的左子树</li>
<li>左子树遍历结束之后，弹出栈顶结点<br>如果该结点有右节点且右节点还未被打印出栈，将该结点再次压入堆栈，后序遍历该结点的右子树<br>如果该结点没有右结点或者该结点的右结点被访问过了，则访问该结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(Bintree BT)</span> </span>&#123;</span><br><span class="line">    Bintree T = BT;</span><br><span class="line">    Bintree PrintedRT = <span class="literal">NULL</span>;<span class="comment">//上一个被打印出的右节点</span></span><br><span class="line">    Stack S = CreateStack(Maxsize);</span><br><span class="line">    <span class="keyword">while</span> (T || !IsEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (T) &#123;</span><br><span class="line">            Push(S, T);</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!IsEmpty(S)) &#123;</span><br><span class="line">            T = Pop(s);</span><br><span class="line">            <span class="keyword">if</span> ((T-&gt; Right== <span class="literal">NULL</span>)||(T-&gt;Right == PrintedRT)) &#123;    <span class="comment">//右节点为空 或 右节点已经出栈</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class="line">                PrintedRT = T; <span class="comment">//记录“上一个被打印出的右节点”</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//有右节点且右节点还未被打印出栈</span></span><br><span class="line">                Push(S, T);  <span class="comment">//因为当前节点已经出栈，但右儿子节点还未先出栈，所以先把他压进去</span></span><br><span class="line">                T = T-&gt;Right;  <span class="comment">//转向右子树，进入下一次循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.二叉树的层序遍历</p>
<p><strong>二叉树的层序遍历的关键是使用 队列。</strong></p>
<ul>
<li>根结点入队</li>
<li>如果队列不为空，从中取出一个元素，并访问之，将其左右儿子顺序入队</li>
<li>重复第二步</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Queue Q = CreateQueue(MaxSize);</span><br><span class="line"></span><br><span class="line">    AddQ(Q,T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Empty(Q)) &#123;</span><br><span class="line">        T = DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left) AddQ(Q,T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right) AddQ(Q,T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历二叉树的应用"><a href="#遍历二叉树的应用" class="headerlink" title="遍历二叉树的应用"></a>遍历二叉树的应用</h3><p>1.输出所有叶子结点</p>
<p>核心：叶子节点的左右儿子都为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="keyword">if</span>(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.求二叉树的高度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> HL,HR,MaxH;</span><br><span class="line">    <span class="keyword">if</span>(BT) &#123;</span><br><span class="line">        HL = getHeight(BT-&gt;Left);</span><br><span class="line">        HR = getHeight(BT-&gt;Right);</span><br><span class="line">        MaxH = HL &gt; HR ? HL : HR;</span><br><span class="line">        <span class="keyword">return</span> MaxH + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.由两种遍历确定一颗二叉树</p>
<p><strong>由先序和中序遍历序列、后序和中序遍历序列可以唯一确定一棵二叉树。</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>线性结构</title>
    <url>/2019/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>线性结构介绍线性表的抽象定义，并分别讨论基于顺序存储和链式存储的线性表的实现方法。同时将介绍两种典型且应用广泛的线性表：堆栈和队列。</p>
<p>线性表的基本操作是插入和删除，堆栈是插入和删除只发生在同一端的线性表，而队列的插入和删除则分别发生在有序序列的两端，即一端只做插入，一端只做删除。</p>
<a id="more"></a>

<h2 id="线性表的定义与实现"><a href="#线性表的定义与实现" class="headerlink" title="线性表的定义与实现"></a>线性表的定义与实现</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表(Linear List)是由同一类型的元素构成的有序序列的线性结构。线性表的抽象数据描述为：</p>
<p><strong>类型名称</strong>：线性表(List)</p>
<p><strong>数据对象集</strong>: 线性表是由 n 个元素构成的有序序列。</p>
<p><strong>操作集</strong>： 线性表 L∈List，整数 i 表示位置，元素 X∈ElementType，线性表的主要操作有：</p>
<ol>
<li><p><code>List MakeEmpty()</code>：初始化一个空的线性表；</p>
</li>
<li><p><code>ElementType FindKth(List L,int i)</code>：根据位序 i 返回相应元素；</p>
</li>
<li><p><code>Position Find(List L,ElementType X)</code>：在线性表 L 中查找 X 第一次出现的位置；</p>
</li>
<li><p><code>bool Insert(List L,ElementType X,int i)</code>：在 L 的指定位序 i 之前插入一个新元素 X；</p>
</li>
<li><p><code>bool Delete(List L, int i)</code>：从 L 中删除指定位序 i 的元素；</p>
</li>
<li><p><code>int Length(List L)</code>：返回线性表 L 的长度。</p>
</li>
</ol>
<h3 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h3><p>线性表的顺序存储是指在内存中用地址连续的一块存储空间顺序存放线性表的各元素。因此可以用一维数组来表示顺序存储的数据区域。</p>
<p>考虑到线性表的运算有插入、删除操作，即表的长度是动态变化的，因此数组的容量需要设计得足够大，可以根据实际情况来定义一个 MAXSIZE 表示数组的最大容量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000            <span class="comment">/* 线性表的最大容量 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;        <span class="comment">/* 线性表中数据类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;           <span class="comment">/* 线性表中每个位置类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">PtrToLNode</span>;</span>   <span class="comment">/* 定义指向线性表每个结点的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;            <span class="comment">/* 定义线性表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    L-&gt;Last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">(List L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; L-&gt;Last || i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无该元素&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> L-&gt;Data[i];</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L,ElementType X)</span> </span>&#123;</span><br><span class="line">    Position i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; L-&gt;Last) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L,ElementType X, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 在 L 的指定位序 i 前插入一个元素，位序 i 的元素数组下标为 i ，需要把i之后的元素全部后移一位*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last == MAXSIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线性表已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L-&gt;Last + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Position j;</span><br><span class="line">    <span class="keyword">for</span>(j = L-&gt;Last+<span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">        L-&gt;Data[j] = L-&gt;Data[j<span class="number">-1</span>];</span><br><span class="line">    L-&gt;Data[j] = X;</span><br><span class="line">    L-&gt;Last ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除位序为i的元素，对应数组下标为i ，需要把i之后的元素全部前移一位*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线性表为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; L-&gt;Last) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Position j;</span><br><span class="line">    <span class="keyword">for</span>(j=i; j&lt;L-&gt;Last; j++)</span><br><span class="line">        L-&gt;Data[j] = L-&gt;Data[j+<span class="number">1</span>];</span><br><span class="line">    L-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;Last + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知顺序表的删除或插入操作的时间复杂度为 O(N)，查找第 i 个元素的时间复杂度为 O(1)。</p>
<h3 id="线性表的链式存储实现"><a href="#线性表的链式存储实现" class="headerlink" title="线性表的链式存储实现"></a>线性表的链式存储实现</h3><p>为提高线性表的插入或删除效率，可以使用链式存储结构即链表，它不需要用连续的地址来存储单元，它是通过”链”建立起数据元素之间的逻辑关系，因此对链表的插入或删除操作不需要移动元素，只需要修改”链”。</p>


<p>因此链表的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR NULL;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;   <span class="comment">/* 链表每个结点的数据项 */</span></span><br><span class="line">    PtrToLNode Next;    <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br></pre></td></tr></table></figure>

<p>链表名即链表第一个结点的指针。</p>
<p>1.求表长<br>在顺序表中求表长是一件很容易的事，但是在链表里面，我们需要将整个链表遍历一遍，使用一个指向链表头的指针，从前往后移动，再使用计数器count记录移动次数，直到链表结束为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">    PtrToLNode p = L;   <span class="comment">/* 指向链表头 */</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PtrToLNode <span class="title">FindKth</span><span class="params">(List L, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 查找位序为 k 的元素 */</span></span><br><span class="line">    PtrToLNode p = L;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">/* 位序从0开始 */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count &lt; K) &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p &amp;&amp; (count == K))</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L, ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 查找X在链表中的位置 */</span></span><br><span class="line">    Position p = L;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;Data != X)</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找的时间复杂度为 O(N)。</p>
<p>3.插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L, ElementType X, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 在第i个结点前插入一个结点 */</span></span><br><span class="line">    PtrToLNode p ,s;</span><br><span class="line">    <span class="comment">// 如果插入结点在表头</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        s = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则找到第 i 个结点的前一个结点</span></span><br><span class="line">    p = FindKth(L,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在上述的实现中我们将表头插入作为一种特殊的情况处理，为避免这种情况我们一般为链表增加一个空的“头结点”，真正的元素链接在这个空结点之后。这样做的好处是无论在哪里删除，L 的值一直指向固定的空结点。</p>
<p>因此需要理解以下三个概念：</p>
<ul>
<li>头结点：链表首元结点前的一个空结点。</li>
<li>首元结点：链表中存储线性表中第一个数据元素的结点。</li>
<li>头指针：指向链表中第一个结点（或为头结点或为首元结点）的指针。</li>
</ul>
<p>假设链表有头结点，则插入操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L, ElementType X, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 假设链表有头结点，在第i个结点前插入一个结点 */</span></span><br><span class="line">    PtrToLNode p ,s;</span><br><span class="line">    <span class="comment">// 找到第 i 个结点的前一个结点</span></span><br><span class="line">    p = FindKth(L,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.删除<br>这里假设链表有头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除第i个结点 */</span></span><br><span class="line">    PtrToLNode p,tmp;</span><br><span class="line">    p = FindKth(L,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p-&gt;Next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除位置参数错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = tmp-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表的插入和删除操作其时间复杂度也为 O(N)。</p>
<h2 id="堆栈的定义与实现"><a href="#堆栈的定义与实现" class="headerlink" title="堆栈的定义与实现"></a>堆栈的定义与实现</h2><p>思考：计算机如何进行表达式求值？</p>
<ul>
<li>中缀表达式：运算符号位于两个运算数之间，如 a + b*c - d/e</li>
<li>后缀表达式：运算符位于两个运算数之后，如 a b c * + d e / -</li>
</ul>
<p>计算机首先将中缀表达式转换成对应的后缀表达式，然后对后缀表达式进行求值，因此这里有两个问题，如何将中缀表达式转换成后缀表达式？如何对后缀表达式进行求值？</p>
<p>例如：求后缀表达式 6 2 / 3 - 4 2 * + 的值。</p>
<p>策略：从左向右扫描，遇到运算数，先存放起来，遇到运算符计算刚刚存放的两个元素的值（即后进先出），再将值存放起来。</p>
<p>因此这就要利用堆栈进行求值。</p>
<h3 id="堆栈的定义"><a href="#堆栈的定义" class="headerlink" title="堆栈的定义"></a>堆栈的定义</h3><p>堆栈(Stack)可以认为是具有一定约束的线性表，插入和删除操作作用在一个称为栈顶(Top)的端点位置。正是堆栈所具有的这种特性，通常把数据插入称为入栈(Push)，数据删除操作称为出栈(Pop)。</p>
<p>也正是由于这一特性，最后入栈的数据将会被最先弹出，所以堆栈也叫后入先出(Last In First Out,LIFO)表。</p>
<p>堆栈的抽象数据定义为：</p>
<p><strong>类型名称</strong>：堆栈(Stack)。</p>
<p><strong>数据对象集</strong>：一个有0个或多个元素的有穷线性表。</p>
<p><strong>操作集</strong>：对于一个具体长度为正整数 MaxSize 的堆栈 S∈Stack，记栈中的任一元素 X∈ElementType，堆栈的基本操作有：</p>
<ol>
<li><p><code>Stack CreateStack(int MaxSize)</code>：创建一个最大长度为 MaxSize 的堆栈；</p>
</li>
<li><p><code>bool IsFull(Stack S)</code>：检查堆栈是否已满；</p>
</li>
<li><p><code>bool Push(Stack S, ElementType X)</code>：将 X 入栈；</p>
</li>
<li><p><code>bool IsEmpty(Stack S)</code>：检查堆栈是否为空；</p>
</li>
<li><p><code>ElementType Pop(Stack S)</code>：弹出栈顶元素。</p>
</li>
</ol>


<h3 id="堆栈的顺序存储实现"><a href="#堆栈的顺序存储实现" class="headerlink" title="堆栈的顺序存储实现"></a>堆栈的顺序存储实现</h3><p>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成，另外我们还需要知道栈的最大容量，这样方便我们判断栈什么时候是满的。因此栈的顺序存储结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>* <span class="title">PtrToSNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;  <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    Position Top;            <span class="comment">/* 栈顶指针 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;        <span class="comment">/* 栈的最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br></pre></td></tr></table></figure>

<p>以下是创建一个空堆栈的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="keyword">int</span> MaxSize)</span> </span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    S-&gt;Data = (ElementType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType)*MaxSize);</span><br><span class="line">    S-&gt;MaxSize = MaxSize;</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入栈：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Top == S-&gt;MaxSize<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(S))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        S-&gt;Data[++(S-&gt;Top)] = X;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出栈：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;       <span class="comment">/* 特殊值，标记错误 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> S-&gt;Data[(S-&gt;Top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆栈的链式存储实现"><a href="#堆栈的链式存储实现" class="headerlink" title="堆栈的链式存储实现"></a>堆栈的链式存储实现</h3><p>栈的链式存储结构实际上就是一个单链表，插入和删除只能在链栈的栈顶进行。栈顶指针 Top 指向链表头，删除和插入操作都在链表头部进行，因为在尾部无法进行删除操作。</p>
<p>因此为了简便算法，<strong>为链栈增加一个空的头结点</strong>。因此其实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PtrToSNode node = (PtrToSNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    node-&gt;Data = X;</span><br><span class="line">    node -&gt; Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PtrToSNode temp = S-&gt;Next;</span><br><span class="line">        X = temp-&gt;Data;</span><br><span class="line">        S-&gt;Next = temp-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆栈的应用"><a href="#堆栈的应用" class="headerlink" title="堆栈的应用"></a>堆栈的应用</h3><p>前面提到的问题我们解决了后一部分，接下来解决如何将中缀表达式转为后缀表达式？</p>
<p>算法描述：</p>
<p>从头到尾读取中缀表达式的每个元素，对不同元素按照不同情况进行处理：</p>
<p>1.运算数： 直接输出</p>
<p>2.左括号： 入栈</p>
<p>3.右括号： 将栈顶元素弹出并输出，直到遇见左括号（出栈，不输出）</p>
<p>4.运算符： 若运算符的优先级大于栈顶符号优先级，则入栈；</p>
<p>若运算符号优先级小于栈顶符号优先级，则将栈顶符号出栈并输出；再比较新的栈顶符号，直到新的栈顶符号优先级小于该运算符优先级为止，然后将该运算符入栈</p>
<p>5.所有元素处理完毕，则把堆栈中存留的运算符一并输出。</p>
<h2 id="队列的定义与实现"><a href="#队列的定义与实现" class="headerlink" title="队列的定义与实现"></a>队列的定义与实现</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>多个数据构成一个有序序列，而对这个序列的操作有一定要求：只能在一端插入，另一端删除，这样的数据组织方式就是“队列”，队列具有先进先出（First In First Out,FIFO）的特点队列(Queue)也是一个有序线性表。</p>
<p>队列的抽象数据类型定义为：</p>
<p><strong>类型名称</strong>：队列(Queue)。</p>
<p><strong>数据对象集</strong>：有一个或多个元素的有穷线性表。</p>
<p><strong>操作集</strong>：对于一个长度为正整数 MaxSize 的队列 Q∈Queue，记队列中的任一元素 X∈ElementType，队列的基本操作有：</p>
<p>1.<code>Queue CreateQueue(int MaxSize)</code>：生成最大长度为 MaxSize 的空队列；</p>
<p>2.<code>bool IsFull(Queue Q)</code>：判断队列是否已满；</p>
<p>3.<code>bool AddQ(Queue Q, ElementType X)</code>：将元素 X 压入队列；</p>
<p>4.<code>bool IsEmpty(Queue Q)</code>：判断队列是否为空；</p>
<p>5.<code>ElementType DeleteQ(Queue Q)</code>：删除并返回队列头元素。</p>
<h3 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h3><p>为了充分利用数组空间，一般在队列的顺序存储结构中采用循环队列的方式。</p>
<p>当队列头 Front 和 队列尾 Rear 相等时，我们无法判断队列是空的还是满的。其根本原因是 Rear 和 Front 的差值最多有 n 种情况（n为数组的大小），而队列元素的个数却又 n+1 种（0,1,2,…,n），所以仅依靠 Front 和 Raer 是无法区分这 n+1 种情况的。</p>
<p>因此我们有两种解决方法：</p>
<p>1.设置一个从额外标记记录最后一次操作是入队还是出队。如果是入队导致 Front==Rear 说明队列满，如果是出队导致 Front==Rear 说明队列空<br>2.仅使用 n-1 个数组空间，如下图所示表示队列满，因此队列满的条件是 (Rear+1)%数组长度等于Front 。队列空的条件依然是 Front== Rear。</p>


<p>使用第二种方法来实现循环队列，因此队列的顺序存储实现结构可以是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">PtrToQNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    ElementType* Data;      <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    Position Front,Rear;    <span class="comment">/* 队列的头尾指针 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;            <span class="comment">/* 队列的最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToQNode Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">(<span class="keyword">int</span> MaxSize)</span> </span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType)*MaxSize);</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="number">-1</span>;</span><br><span class="line">    Q-&gt;MaxSize = MaxSize;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q-&gt;Rear+<span class="number">1</span>)%(Q-&gt;MaxSize) == Q-&gt;Front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddQ</span><span class="params">(Queue Q, ElementType X)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(IsFull(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;Rear = (Q-&gt;Rear+<span class="number">1</span>)%(Q-&gt;MaxSize);</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;Front == Q-&gt;Rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(Q)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;Front = (Q-&gt;Front+<span class="number">1</span>)%Q-&gt;MaxSize;</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h3><p>队列的链式存储结构也可以用一个单链表来实现。插入和删除操作分别在链表的两头进行：<strong>队列的 front 和 rear 应该分别指向链表的哪一头？</strong></p>
<p>由于在链表尾部无法进行删除操作，因此删除操作在链表头部，插入操作在链表尾部，所以 front 指向链表头部，rear 指向链表尾部。</p>


<p>因此其不带头结点的链式队列可以定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    Position rear;</span><br><span class="line">    Position front;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">Queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddQ</span><span class="params">(Queue Q, ElementType X)</span> </span>&#123;</span><br><span class="line">    PtrToNode node = (PtrToNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    node-&gt;Data = X;</span><br><span class="line">    node-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;Next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PtrToNode node = Q-&gt;front;</span><br><span class="line">        ElementType temp = node-&gt;Data;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear) <span class="comment">/* 如果队列只有一个元素 */</span></span><br><span class="line">            Q-&gt;front = Q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Q-&gt;front = Q-&gt;front-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>线性结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多态</title>
    <url>/2019/11/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-6/</url>
    <content><![CDATA[<p>一个变量对象可以指示多种实际类型的现象称为多态。在运行时能够自动选择调用哪个方法的现象称为自动绑定。</p>
<p>以下我们定义两个类 Employee 类和其子类 Manager 类。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Employee类为员工类，其含有姓名，薪水，雇佣日期这些成员变量</span></span><br><span class="line"><span class="comment">    * 有获取姓名、薪水、雇佣日期的方法</span></span><br><span class="line"><span class="comment">    * 同时还有涨工资的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Manager类为经理类，其继承员工类，除了员工的基本工资以外，经理还有奖金</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, month, day);</span><br><span class="line">        <span class="keyword">this</span>.bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Manager boss = <span class="keyword">new</span> Manager(<span class="string">&quot;Sillywa&quot;</span>, <span class="number">6000</span>, <span class="number">2009</span>, <span class="number">12</span>, <span class="number">5</span>);</span><br><span class="line">        boss.setBonus(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">        staff[<span class="number">0</span>] = boss;</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;xin&quot;</span>, <span class="number">3000</span>, <span class="number">2012</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;yuan&quot;</span>, <span class="number">3000</span>, <span class="number">2012</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Employee e:staff) &#123;</span><br><span class="line">            System.out.println(e.getName() + <span class="string">&quot;:&quot;</span> + e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个 Employee 类型的数组，并且把 staff[0] 的类型设置为 Manager 类型，此时并没有报错。因为 Manager 类继承于 Employee 类，所以一个 Manager 类也是一个 Employee 类，这就是多态的典型例子。</p>
<p>换句话说，一个 Employee 变量既可以引用一个 Employee 类对象，也可以引用一个 Employee 类的任何一个子类的对象，如 Manager 对象。</p>
<p>在最后的遍历中，当 e 引用 Employee 类的对象时，e.getSalary() 调用的是 Employee 类中的 getSalary 方法；当 e 引用 Manager 对象时，e.getSalary() 调用的是 Manager 类中的 getSalary 方法。虚拟机知道 e 的实际引用的对象类型，因此能够正确调用相应的方法。</p>
<p>在上面例子中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager boss = <span class="keyword">new</span> Manager(...);</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 staff[0] 与 boss 引用的同一个对象。但是编译器将 staff[0] 看成 Employee 对象。</p>
<p>这意味着：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">boss.setBonus(<span class="number">1000</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>但是不能这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">1000</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>这是因为 staff[0] 声明的类型是 Employee，而 setBonus 不是 Employee 类的方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>K-means算法的实现与改进</title>
    <url>/2019/11/21/K-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<p>本文主要介绍了 K-means 算法的原理以及如何利用 python 去实现简单的 K-means 算法，然后对于 K-means 算法存在的一些问题进行了适当的改进。</p>
<a id="more"></a>

<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><h3 id="聚类的定义"><a href="#聚类的定义" class="headerlink" title="聚类的定义"></a>聚类的定义</h3><p>聚类就是对大量未标记的数据集，按照数据的内在相似性将数据集划分为多个类别，使同一类别内的数据相似性大而不同类别间的数据相似性小。聚类是典型的无监督学习。</p>
<h3 id="聚类的一般方法"><a href="#聚类的一般方法" class="headerlink" title="聚类的一般方法"></a>聚类的一般方法</h3><p>给定 N 个对象的数据集，将数据集划分为 k 个簇，k≤N，且满足：</p>
<ol>
<li><p>每个簇至少有一个对象</p>
</li>
<li><p>每个对象只能属于一个簇</p>
</li>
</ol>
<p>聚类既能作为一个单独过程，用于找寻数据的内在分布结构，也可以作为分类等其他任务的前驱过程。</p>
<h3 id="不同类型的聚类"><a href="#不同类型的聚类" class="headerlink" title="不同类型的聚类"></a>不同类型的聚类</h3><ol>
<li><p>原型聚类</p>
<p> 原型聚类也叫基于原型的聚类，此类算法假设聚类结构能够通过一组原型刻画，在现实聚类中极为常用。通常情况下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式将产生不同的算法。其中比较典型的就是k均值算法，也叫 K-menas 算法。</p>
</li>
<li><p>密度聚类</p>
<p> 密度聚类也叫基于密度的聚类，此类算法假设聚类结构能够通过样本的紧密程度确定。通常情况下，密度聚类算法从样本密度的角度来考察样本之间的可连接性，并基于可连接样本不断扩展聚类簇以获得最终的聚类结果。其中比较著名就是 DBSCAN 算法。</p>
</li>
<li><p>层次聚类</p>
<p> 层次聚类试图在不同层次对数据集进行划分，从而形成树型的聚类结构。数据集的划分可以采用“自底向上”的聚合策略，也可以采用“自顶向下”的分拆策略。</p>
</li>
<li><p>谱聚类</p>
<p> 谱聚类是一种基于图论的聚类方法，通过对样本数据的拉普拉斯矩阵的特征向量进行聚类，从而达到对样本数据聚类的目的。</p>
</li>
</ol>
<h2 id="K-means-算法原理"><a href="#K-means-算法原理" class="headerlink" title="K-means 算法原理"></a>K-means 算法原理</h2><p>首先随机选取 k 个对象，每个对象初始地代表了一个簇的平均值或中心，称为初始均值向量。对剩余的每个对象根据其与各个簇中心的距离，将它赋给最近的簇。然后重新计算每个簇的平均值得到新的均值向量。这个过程不断重复直到当前均值向量均保持不变。</p>
<p>算法描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从 D 中随机选择 k 个样本作为初始均值向量</span><br><span class="line">repeat</span><br><span class="line">    for j&#x3D;1,2,…,m do</span><br><span class="line">        计算样本与各均值向量的距离</span><br><span class="line">        根据距离最近的均值向量确定样本的簇标记</span><br><span class="line">        将样本划入相应的簇</span><br><span class="line">    end for </span><br><span class="line">    for i&#x3D;1,2,…,k do</span><br><span class="line">        计算新的均值向量</span><br><span class="line">        if 两个均值向量不相同  then</span><br><span class="line">            更新均值向量</span><br><span class="line">        else</span><br><span class="line">            保持当前均值向量不变</span><br><span class="line">        end if</span><br><span class="line">    end for</span><br><span class="line">until 当前均值向量均未更新</span><br></pre></td></tr></table></figure>

<h2 id="K-means-算法实现"><a href="#K-means-算法实现" class="headerlink" title="K-means 算法实现"></a>K-means 算法实现</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmeans</span>:</span></span><br><span class="line">    __dataList = []</span><br><span class="line">    __k = <span class="number">1</span></span><br><span class="line">    __kSample = []</span><br><span class="line">    __count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,fileName,k</span>):</span></span><br><span class="line">        self.__dataList = self.__readData(fileName)</span><br><span class="line">        self.__kSample = self.__getKSample(self.__dataList,k)</span><br><span class="line">        self.__k = k</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始聚类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="comment">#计算每一个点与均值向量之间的距离,确定每一个点的类别</span></span><br><span class="line">            <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(self.__dataList):</span><br><span class="line">                self.__caculateType(self.__dataList[index],self.__kSample)</span><br><span class="line">            <span class="comment"># 保存均值向量的副本</span></span><br><span class="line">            copiedKSample = copy.deepcopy(self.__kSample)</span><br><span class="line">            <span class="comment"># 重新计算均值向量</span></span><br><span class="line">            self.__caculateKSampleByAverge(self.__kSample)</span><br><span class="line">            <span class="comment"># 如果两个均值向量相等，则循环停止</span></span><br><span class="line">            <span class="keyword">if</span> copiedKSample == self.__kSample:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.__count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 绘制散点图</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drawPic</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 由于是二维坐标，因此只需x，y即可</span></span><br><span class="line">        x = []</span><br><span class="line">        y = []</span><br><span class="line">        c = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.__dataList)):</span><br><span class="line">            x.append(self.__dataList[i][<span class="number">0</span>])</span><br><span class="line">            y.append(self.__dataList[i][<span class="number">1</span>])</span><br><span class="line">            c.append(self.__dataList[i][<span class="number">2</span>])</span><br><span class="line">        plt.title(<span class="string">&quot;dataset k=&quot;</span> + str(self.__k))</span><br><span class="line">        plt.scatter(x, y,c=c)</span><br><span class="line">        plt.show()</span><br><span class="line">    <span class="comment"># 获取迭代次数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCount</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__count</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从文件中读取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__readData</span>(<span class="params">self,fileName</span>):</span></span><br><span class="line">        <span class="comment"># 用存放数据的列表</span></span><br><span class="line">        dataList = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fp = open(fileName,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">            fpList = fp.read().splitlines()</span><br><span class="line">            <span class="comment"># 将数据分割成二维列表</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> fpList:</span><br><span class="line">                dataList.append(item.split(<span class="string">&quot;\t&quot;</span>))</span><br><span class="line">            <span class="comment"># 将字符数据转化成浮点数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dataList)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dataList[i])):</span><br><span class="line">                    dataList[i][j] = float(dataList[i][j])</span><br><span class="line">            <span class="comment"># 如果数据不包含类别信息</span></span><br><span class="line">            <span class="comment"># for i in range(len(dataList)):</span></span><br><span class="line">            <span class="comment">#     dataList[i].append(0)</span></span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            print(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">        <span class="comment">#返回数据</span></span><br><span class="line">        <span class="keyword">return</span> dataList</span><br><span class="line">    <span class="comment"># 获取初始k个点，也就是初始均值向量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getKSample</span>(<span class="params">self,dataList, k</span>):</span></span><br><span class="line">        kSample = []    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="comment">#从所有数据集中随机选取k个数据</span></span><br><span class="line">            num = random.randint(<span class="number">0</span>,len(dataList)<span class="number">-1</span>)</span><br><span class="line">            kSample.append(copy.deepcopy(dataList[num]))</span><br><span class="line">        <span class="keyword">return</span> kSample</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算两个点之间的距离</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getDistance</span>(<span class="params">self,dataPoint1,dataPoint2</span>):</span></span><br><span class="line">            </span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 因为每一项数据的最后一位为类别，所以不参与计算距离</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dataPoint1)<span class="number">-1</span>):</span><br><span class="line">            distance = distance + pow(dataPoint1[i]-dataPoint2[i],<span class="number">2</span>)		</span><br><span class="line">        distance = math.sqrt(distance)</span><br><span class="line">        <span class="keyword">return</span> distance</span><br><span class="line">    <span class="comment"># 根据每个样本距离均值向量的长短，计算每个样本所属的类别</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__caculateType</span>(<span class="params">self,dataPoint,kSample</span>):</span></span><br><span class="line">        <span class="comment"># 首先假设该样本距离第一个均值向量最近,即该样本属于第一类</span></span><br><span class="line">        minDistance = self.__getDistance(dataPoint,kSample[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 记录该样本所属的类别</span></span><br><span class="line">        type = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算该样本与每一个均值向量之间的距离</span></span><br><span class="line">        <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(kSample):</span><br><span class="line">            distance = self.__getDistance(dataPoint,item)</span><br><span class="line">            <span class="comment"># 如果该数据点距离该类别较小</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; minDistance:</span><br><span class="line">                minDistance = distance  <span class="comment"># 更新最短距离</span></span><br><span class="line">                type = index    <span class="comment"># 更新样本点所属类别</span></span><br><span class="line">        <span class="comment"># 修改数据点的类别</span></span><br><span class="line">        dataPoint[len(dataPoint)<span class="number">-1</span>] = type</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新计算均值向量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__caculateKSampleByAverge</span>(<span class="params">self,kSample</span>):</span></span><br><span class="line">         <span class="comment"># 对于每个均值向量，其下标为类别</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(kSample)):</span><br><span class="line">            typeI = []</span><br><span class="line">            <span class="comment"># 遍历所有数据找到与其类别一致的数据点</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> self.__dataList:</span><br><span class="line">                <span class="keyword">if</span> item[(len(item)<span class="number">-1</span>)] == i:</span><br><span class="line">                    typeI.append(copy.deepcopy(item))</span><br><span class="line">            <span class="comment">#求和</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(typeI)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(typeI[j])):</span><br><span class="line">                    typeI[j][k] += typeI[j<span class="number">-1</span>][k]</span><br><span class="line">            <span class="comment"># 求均值并更改每一类的聚类中心</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(kSample[i])):</span><br><span class="line">                kSample[i][j] = typeI[len(typeI)<span class="number">-1</span>][j]/len(typeI)</span><br><span class="line"></span><br><span class="line">a = Kmeans(<span class="string">&quot;f://machine_learning/shape_sets/D31.txt&quot;</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">a.start()</span><br><span class="line">print(a.getCount())</span><br><span class="line"><span class="comment">#二维坐标才可以画散点图</span></span><br><span class="line">a.drawPic()</span><br></pre></td></tr></table></figure>

<h2 id="K-means-算法的改进"><a href="#K-means-算法的改进" class="headerlink" title="K-means 算法的改进"></a>K-means 算法的改进</h2><p>K-means 是随机选取的初始点，因此不同的初始点对聚类结果有较大的影响。为解决这一问题我们可采用概率的方式来选择初始点，即 K-means++。</p>
<p>基本思想：</p>
<ol>
<li><p>从输入的集合中随机选取一个点作为聚类的中心</p>
</li>
<li><p>对于数据集中的每一个点，计算它与最近的聚类中心（指已选择的聚类中心）的距离 D(x)</p>
</li>
<li><p>选择一个新的数据点作为新的聚类中心，选择的原则是：D(x) 较大的点，被选取作为聚类中心的概率较大</p>
</li>
<li><p>重复2、3步骤直到 k 个初始聚类中心被选出</p>
</li>
<li><p>利用选出的 k 个初始的聚类中心来运行标准的 K-means 算法</p>
</li>
</ol>
<p>从上面可以看出，此算法的关键是如何将 D(x) 反映到点被选择的概率上，其方法如下：</p>
<ol>
<li><p>对于每个点都会计算与它最近的聚类中心的距离 D(x)，将每个点的 D(x)^2 保存在一个列表 List 中，然后把这些距离加起来，即对 List 中所有元素求和得到 SumList。</p>
</li>
<li><p>对于 List 中的每个点计算 List[i]/SumList ，即每个点概率 P(x)</p>
</li>
<li><p>将 P(x) 累加得到概率区间</p>
</li>
<li><p>产生一个 0-1 的随机数，该数落在哪个区间内就选择哪个点作为新的聚类中心</p>
</li>
</ol>
<p>具体示例如下：</p>
<p>8个点：(1,2),(1,2),(2,1),(2,2),(5,5),(5,6),(6,5),(6,6)</p>
<ol>
<li><p>随机选取一个点作为聚类中心，如3号点 (2,1)</p>
</li>
<li><p>计算 D(x)^2,P(x)</p>
</li>
</ol>


<ol start="3">
<li>产生 0-1 之间的随机数，如果该随机数落在 [0-0.007] 则选取1号点，[0.007-0.021] 则选取2号点，[0.021-0.028] 则选取3号点以此类推，很明显5，6，7，8号点被选取的概率较大，其距离3号点的距离较远。</li>
</ol>
<p>基于以上方法，我们改写选择初始点的函数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKSample</span>(<span class="params">dataList, k</span>):</span></span><br><span class="line">    kSample = []   </span><br><span class="line">    <span class="comment"># 首先随机选取一个数字为种子点 </span></span><br><span class="line">    num = random.randint(<span class="number">0</span>,len(dataList)<span class="number">-1</span>)</span><br><span class="line">    kSample.append(copy.deepcopy(dataList[num]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 用于保存距离的列表</span></span><br><span class="line">        D = []</span><br><span class="line">        <span class="comment"># 用于存储概率的数组</span></span><br><span class="line">        P = []</span><br><span class="line">        <span class="comment"># 对于每个点，我们都计算其和最近的一个“种子点”的距离D(x)^2并保存在一个数组里</span></span><br><span class="line">        <span class="keyword">for</span> item1 <span class="keyword">in</span> dataList:</span><br><span class="line">            minDistance = getDistance(item1,kSample[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> item2 <span class="keyword">in</span> kSample:</span><br><span class="line">                distance = getDistance(item1,item2)</span><br><span class="line">                <span class="keyword">if</span> distance &lt; minDistance:</span><br><span class="line">                    minDistance = distance</span><br><span class="line"></span><br><span class="line">            D.append(pow(minDistance,<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 循环结束之后得到储存距离的数组</span></span><br><span class="line">        sumD = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 然后把距离加起来</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> D:</span><br><span class="line">            sumD = sumD + item</span><br><span class="line">        <span class="comment"># 计算每个样本被选为下一个聚类中心的概率</span></span><br><span class="line">        sumP = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> D:</span><br><span class="line">            itemP = item/sumD</span><br><span class="line">            sumP = sumP + itemP</span><br><span class="line">            P.append(sumP)</span><br><span class="line">        <span class="comment">#随机产生0-1之间的数</span></span><br><span class="line">        rand = random.random()</span><br><span class="line">        <span class="comment"># 计算该数落在哪个区间</span></span><br><span class="line">        <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(P):</span><br><span class="line">            <span class="keyword">if</span> rand &lt; item:</span><br><span class="line">                kSample.append(copy.deepcopy(dataList[index]))</span><br><span class="line">                <span class="keyword">break</span>       </span><br><span class="line">    <span class="keyword">return</span> kSample</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>k-means</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>列出连通集</title>
    <url>/2019/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E4%B9%8B%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个有 N 个顶点和 E 条边的无向图，请用 DFS 和 BFS 分别列出其所有的连通集。假设顶点从 0 到 N−1 编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p>
<a id="more"></a>

<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第 1 行给出 2 个整数 N(0 &lt; N ≤ 10) 和 E，分别是图的顶点数和边数。随后 E 行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>按照”{ v1 v2 … vk }”的格式，每行输出一个连通集。先输出 DFS 的结果，再输出 BFS 的结果。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123; <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> &#125;</span><br><span class="line">&#123; <span class="number">3</span> <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="number">6</span> &#125;</span><br><span class="line">&#123; <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="number">3</span> <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>首先我们需要分别定义图和边，这里我们使用邻接矩阵来存储图:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 10        <span class="comment">/* 定义最大顶点数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用邻接矩阵来存储图 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>* <span class="title">MGraph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;                             <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;                             <span class="comment">/* 边数 */</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxVertex][MaxVertex];     <span class="comment">/* 邻接矩阵 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">Edge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> V1,V2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们需要三个方法，分别来创建一个有 Vertex 个顶点，但没有边的图，然后需要一个方法来将边插入图中，最后用一个方法来创建图。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 图的方法 */</span></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> Vertex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge E)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图创建完成之后，我们需要分别实现 DFS 和 BFS，因此：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Visited[MaxVertex];   <span class="comment">/* 首先定义一个数组用于标记图中的每个顶点是否被访问 */</span></span><br><span class="line"><span class="comment">/* 由于 BFS 需要用到队列，因此我们还得定义队列及其方法 */</span></span><br><span class="line"><span class="comment">/* 队列的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    <span class="keyword">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph Graph, <span class="keyword">int</span> V)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MGraph Graph, <span class="keyword">int</span> V)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队列的方法 */</span></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">(<span class="keyword">int</span> MaxSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q, <span class="keyword">int</span> X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接下来就依次实现这些方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> Vertex)</span> </span>&#123;</span><br><span class="line">    MGraph Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = Vertex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> V = <span class="number">0</span>;V &lt; Graph-&gt;Nv;V++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> W = <span class="number">0</span>;W &lt; Graph-&gt;Nv;W++) &#123;</span><br><span class="line">            Graph-&gt;data[V][W] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge E)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 插入无向边&lt;V1,V2&gt; */</span></span><br><span class="line">    Graph-&gt;data[E-&gt;V1][E-&gt;V2] = <span class="number">1</span>;</span><br><span class="line">    Graph-&gt;data[E-&gt;V2][E-&gt;V1] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Nv);</span><br><span class="line"></span><br><span class="line">    MGraph Graph = CreateGraph(Nv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Graph-&gt;Ne);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Edge E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;E-&gt;V1,&amp;E-&gt;V2);</span><br><span class="line"></span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph Graph, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    Visited[V] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, V);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有节点 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="comment">/* 找到V和i的邻接点 ,如果该邻接点没有被访问，则访问之 */</span></span><br><span class="line">        <span class="keyword">if</span>(Graph-&gt;data[V][i] == <span class="number">1</span>  &amp;&amp; Visited[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            DFS(Graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MGraph Graph, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue Q = CreateQueue(MaxVertex);</span><br><span class="line"></span><br><span class="line">    Visited[V] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将顶点V入队 */</span></span><br><span class="line">    AddQ(Q, V);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">int</span> W = DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, W);</span><br><span class="line">        <span class="comment">/* 找到W的所有邻接点，如果该邻接点没有被访问则将其入队 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph-&gt;data[W][i] == <span class="number">1</span>  &amp;&amp; Visited[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                Visited[i] = <span class="number">1</span>;</span><br><span class="line">                AddQ(Q, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">(<span class="keyword">int</span> MaxSize)</span> </span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    Q-&gt;front = <span class="number">-1</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">    Q-&gt;MaxSize = MaxSize;</span><br><span class="line">    Q-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear +<span class="number">1</span>)%(Q-&gt;MaxSize);</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    Q-&gt;front = (Q-&gt;front+<span class="number">1</span>)%(Q-&gt;MaxSize);</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;data[Q-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;front == Q-&gt;rear ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在 main 函数里面依次输出连通集即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MGraph Graph = BuildGraph();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化Visited */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        Visited[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当还有邻接点未访问时，访问之 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> V = <span class="number">0</span>;V &lt; Graph-&gt;Nv; V++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[V] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line">            DFS(Graph,V);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化Visited */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        Visited[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> V = <span class="number">0</span>;V &lt; Graph-&gt;Nv; V++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[V] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line">            BFS(Graph,V);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 方法可变参数列表</title>
    <url>/2019/11/04/Java-%E5%87%BD%E6%95%B0%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>和其他编程语言一样，当方法的形参个数不确定时，Java 语言也提供一种可变参数列表。具体如下</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewVarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStr</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(String str : args)</span><br><span class="line">			System.out.print(str + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInt</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : args) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 接受一系列形参</span></span><br><span class="line">        printArray(<span class="keyword">new</span> Integer(<span class="number">47</span>), <span class="keyword">new</span> Float(<span class="number">3.15</span>), <span class="keyword">new</span> Double(<span class="number">11.11</span>));</span><br><span class="line">        printArray(<span class="number">47</span>,<span class="number">3.15F</span>,<span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者数组形式</span></span><br><span class="line">        printArray((Object[])<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        printArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        printStr(<span class="string">&quot;I&quot;</span>,<span class="string">&quot;am&quot;</span>);</span><br><span class="line">        printStr(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printInt(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        printInt(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当函数参数指定了一种类型之后，无论是传入该类型的包装类型还是基本类型，该函数都可以正常工作。</p>
<p>同样可变参数也会发生函数重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadingVarargs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    	System.out.print(<span class="string">&quot;first: &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(String str : args)</span><br><span class="line">			System.out.print(str + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">    	System.out.print(<span class="string">&quot;second: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : args) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line">        f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        f(); <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当发生函数重载时，编译器会自动匹配应该调用的方法，匹配规则与传入的形参有关，所以当不传入参数时，编译器就无法匹配正确的方法，因而报错。</p>
<p>因此我们可能会想到添加一个非可变参数类解决问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadingVarargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>); <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这样依然会报错，如果给这两个函数都添加一个非可变参数，问题就得以解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadingVarargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c, Character... args)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>); <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 方法</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 面向对象(三)</title>
    <url>/2019/09/16/TypeScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-3/</url>
    <content><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查，其被称为“鸭式辨型法”或“结构式子类型化”。</p>
<p>在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<a id="more"></a>

<h3 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">my_object: &#123; name: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(my_object.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_object = &#123; age: <span class="number">22</span>, name: <span class="string">&quot;Sillywa&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">getName(my_object);</span><br></pre></td></tr></table></figure>

<p>以上代码我们规定 getName 函数具有一个参数，且该参数必须含有一个 string 类型的 name 属性。需要注意的是，我们传入的参数实际包含很多属性，但是编译器只会检查那些必须的属性是否存在，并且其类型需要匹配。</p>
<p>下面我们重写这个例子，使用接口来进行描述：必须包含一个 string 类型的 name 属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ObjectValue &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">my_object: ObjectValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(my_obj.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_object = &#123; age: <span class="number">22</span>, name: <span class="string">&quot;Sillywa&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">getName(my_object);</span><br></pre></td></tr></table></figure>

<p>我们使用 interface 关键字来定义一个接口，以上代码中 objectValue 为接口的名字，花括号里面为接口所具有的约束。</p>
<p>需要注意的是，类型检查器不会去检查属性的顺序，只要相应属性存在即可。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必须的。可选属性在应用在 “option bags” 模式时很常用，即给函数传入的参数中只有部分属性赋值了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; color: <span class="string">&quot;white&quot;</span>, area: <span class="number">100</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; color: <span class="string">&quot;black&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>只读属性只能在对象刚刚创建是为其赋值，无法修改其值。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Point = &#123; x: <span class="number">12</span>, y: <span class="number">90</span>&#125;;</span><br><span class="line"></span><br><span class="line">p1.x = <span class="number">80</span>;   <span class="comment">// error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TypeScript 具有 ReadonlyArray<T> 类型，它与 Array<T> 类似，只是把所有可变方法去掉了，因此可以保证数组被创建后再也无法被修改：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line"></span><br><span class="line">ro[<span class="number">1</span>] = <span class="number">13</span>;   <span class="comment">// error</span></span><br><span class="line">ro.push(<span class="number">0</span>);  <span class="comment">// error</span></span><br><span class="line">ro.length = <span class="number">90</span>;  <span class="comment">// error</span></span><br><span class="line">a = ro;       <span class="comment">// error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。</p>
<p><code>readonly</code> vs <code>const</code></p>
<p>判断该使用 readonly 还是 const 的方法是看要把它当作变量使用还是属性使用。作为变量使用时用 const，作属性使用时用 readonly。</p>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>TypeScript 在检查对象字面量时会特殊对待而且会经过额外的属性检查，当他们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何”目标类型“不包含的属性时，你会得到一个错误。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createSquare(&#123; e_color: <span class="string">&quot;red&quot;</span>, width: <span class="number">100</span> &#125;);   <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>绕开这些检查非常简单，最简单的方法是使用类型断言：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">createSquare(&#123; e_color: <span class="string">&quot;red&quot;</span>, width: <span class="number">100</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>

<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig 带有上面定义的类型的 color 和 width 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们要表示的是 SquareConfig 可以有任意数量的属性，并且只要他们不是 color 和 width，那么就无所谓它的类型是什么。</p>
<p>还有最后一种跳过检查的方法，它就是将这个对象赋值给另一个变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">&quot;red&quot;</span>, width: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使接口能描述函数类型，需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数的参数会逐个进行类型检查，要求对应位置上的参数类型是兼容的。如果不指定类型， TypeScript 的类型系统会推断出参数类型。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> PersonInterface &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  getAge(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> PersonInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;&#125;;</span><br><span class="line">  getAge(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接口只描述了类的共有部分，而不是公共和私有两部分。它不会帮忙检查类是否具有某些私有成员。</p>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。这样我们可以从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 面向对象(二)</title>
    <url>/2019/09/08/TypeScript%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2/</url>
    <content><![CDATA[<p>前面介绍了 TypeScript 面向对象的基本特性，现在我们接着前面继续学习 TypeScript 面向对象的其他特性，包含 readonly 修饰符、参数属性、存储器、静态属性、抽象类。</p>
<a id="more"></a>

<h2 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h2><p>readonly 关键字将属性设置为只读的，只读属性必须在声明时或构造函数里被初始化。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span>, <span class="keyword">readonly</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;sillywa&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">p1.getName();</span><br><span class="line">p1.getAge();</span><br><span class="line">p1.name;</span><br><span class="line">p1.age;</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&quot;hahah&quot;</span>;      <span class="comment">// 错误，name是只读属性</span></span><br><span class="line">p1.age = <span class="number">45</span>;            <span class="comment">// 错误，age是只读属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述例子中，name属性为只读，在构造函数外声明，age 属性也是只读，在构造函数里初始化，需要注意的是，在构造函数里初始化的属性不用再使用 this 关键字为其赋值。</p>
<p>除 readonly 修饰符外，其它带有修饰符的属性也可以在构造函数里初始化，这种初始化属性的方式称为 参数属性：</p>
<h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span>, <span class="keyword">private</span> age: <span class="built_in">number</span>, <span class="keyword">protected</span> sex: <span class="built_in">string</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  getInfo(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>,and I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old, I am <span class="subst">$&#123;<span class="built_in">this</span>.sex&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。</p>
<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fullNameMaxLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    get fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;fullName has a max length of &quot;</span> + fullNameMaxLength);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>._fullName = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>
<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>前面我们讨论的都是类的实例成员，即那些仅当实例被初始化的时候才会被初始化的属性。</p>
<p>我们也可以使用 static 关键字创建类的静态成员，*** 这些属性存在于类本身上面而不是类的实例上 ***，我们使用 类名.静态成员 来访问这些静态成员。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">static</span> fullName:<span class="built_in">string</span> = <span class="string">&quot;sillywa&quot;</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> age:<span class="built_in">number</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  getInfo(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`my name is <span class="subst">$&#123;Person.fullName&#125;</span>,age is <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">p1.getInfo();</span><br></pre></td></tr></table></figure>

<p>编译之后生成如下 JavaScript 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my name is &quot;</span> + Person.fullName + <span class="string">&quot;,age is &quot;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.fullName = <span class="string">&quot;sillywa&quot;</span>;    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">23</span>);</span><br><span class="line">p1.getInfo();</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它子类的父类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 </p>
<p>abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<p><strong>* 需要注意的是如果一个子类继承了一个抽象类，则该子类必须实现该抽象类中的抽象方法。 *</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)&#123; &#125;;</span><br><span class="line"></span><br><span class="line">  getName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> getAge(): <span class="built_in">number</span>;  <span class="comment">// 必须在子类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(my_name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;Sillywa&quot;</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">stu1.getAge();</span><br><span class="line">stu1.getName()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 面向对象(一)</title>
    <url>/2019/09/07/TypeScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/</url>
    <content><![CDATA[<p>TypeScript 可以采用面向对象的方式来进行编程，以下介绍一些面向对象的基本特性，包含类、继承、super关键字和访问控制修饰符。</p>
<a id="more"></a>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>TypeScript 使用如下方式声明一个类：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line"></span><br><span class="line">p1.sayName();    </span><br><span class="line">p1.name;  </span><br></pre></td></tr></table></figure>

<p>我们声明了一个 Person 类，他有一个 name 属性，一个构造函数和一个 sayName 方法。</p>
<p>我们在引用任何一个类成员的时候都使用了 this 关键字，表示我们要访问的类成员。</p>
<p>接着我们用 new 关键字创建了一个 Person 类的实例对象 p1，由于其构造函数接受一个 my_name 参数，因此我们在实例化 p1 时，传递给一个参数。</p>
<p>最后 p1 就可以使用 Person 类的属性和方法。</p>
<p>以上代码通过 TypeScript 的编译会得到如下 JavaScript 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">my_name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = my_name;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my name is &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line">p1.sayName();</span><br><span class="line">p1.name;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  sayName():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  saySchool():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;school&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">stu1.saySchool();</span><br><span class="line">stu1.sayName();</span><br></pre></td></tr></table></figure>

<p>与其他语言类似，在 TypeScript 中也是使用 extends 关键字实现继承。在上述例子中，Student 类继承 Person 类，Student 为子类或派生类，Person 类为父类或基类。</p>
<p>需要注意的是子类除了不能继承父类的私有成员(方法和属性)和构造函数，其他的都可以继承。</p>
<p>TypeScript 一次只能继承一个类，不支持继承多个类，但 TypeScript 支持多重继承（A 继承 B，B 继承 C）。</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><strong>* 如果子类包含了一个构造函数，它必须调用 super()，它会执行父类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 *</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">tea_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 派生类包含了一个构造函数，它必须调用 super()</span></span><br><span class="line">    <span class="built_in">super</span>(tea_name);</span><br><span class="line">  &#125;</span><br><span class="line">  sayTeaName(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;teacher name&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.sayName());    <span class="comment">// 调用父类的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  school: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">stu_name: <span class="built_in">string</span>, my_school: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 在构造函数里访问 this 的属性之前，我们一定要调用 super()</span></span><br><span class="line">    <span class="built_in">super</span>(stu_name);</span><br><span class="line">    <span class="built_in">this</span>.school = my_school;</span><br><span class="line">  &#125;</span><br><span class="line">  saySchool():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.school;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tea1 = <span class="keyword">new</span> Teacher(<span class="string">&quot;math teacher&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;middle student&quot;</span>,<span class="string">&quot;peaking university&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1.sayTeaName();</span><br><span class="line"><span class="built_in">console</span>.log(stu1.saySchool());</span><br></pre></td></tr></table></figure>

<p>以上我们声明了三个类，其中 Teacher 类和 Student 类都继承 Person 类。由于子类包含了一个构造函数，它必须调用 super()，执行父类的构造函数。如果构造函数接受参数，需要显式传递参数给 super 方法。</p>
<p>从 Teacher 类我们可以看出，super 不仅可以调用父类的构造函数，还可以调用父类的其它共有方法。</p>
<p>从 Student 类可以看出，当子类包含自己的属性时，需要在访问子类的属性之前调用 super()。</p>
<h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>TypeScript 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。TypeScript 支持 3 种不同的访问权限。、</p>
<ul>
<li><p>public：类的所有成员如果没有访问控制符的话，默认为 public，共有，可以在任何地方被访问。</p>
</li>
<li><p>private：私有，只能被其定义所在的类访问。</p>
</li>
<li><p>protected：受保护，可以被其自身以及其子类或父类访问。</p>
</li>
</ul>
<p>前面我们写的类的成员都没有访问控制修饰符，因此默认为 public，可以在任何地方被访问。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  logName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">stu_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(stu_name);</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);    <span class="comment">// 报错，私有成员无法在其它类中被访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line">stu1.sayName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa father&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);       <span class="comment">// 报错，私有成员只能在其所属类中被访问</span></span><br><span class="line"></span><br><span class="line">p1.logName();               <span class="comment">// 正确，私有成员只能在其所属类中被访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码我们定义了一个 Person 类，其有一个私有属性 name，我们可以看到，无论我们通过何种方法，私有属性 name 只能在其所属类中被访问，其他地方都访问不了。</p>
<p>而 protected 修饰符与 private 有一点不同，protected 成员可以被其自身以及其子类或父类访问。</p>
<p>同样是以上代码，我们将 name 的修饰符换为 protected</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  logName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">stu_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(stu_name);</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);    <span class="comment">// 正确，受保护成员可以在其子类中被访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line">stu1.sayName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa father&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);       <span class="comment">// 报错，受保护成员只能在其所属类或其子类或父类中被访问</span></span><br><span class="line"></span><br><span class="line">p1.logName();               <span class="comment">// 正确，受保护成员可以在其所属类中被访问</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript基础</title>
    <url>/2019/09/05/TypeScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="TypeScript-介绍"><a href="#TypeScript-介绍" class="headerlink" title="TypeScript 介绍"></a>TypeScript 介绍</h2><p>TypeScript 是微软开发的自由和开源的编程语言，它是 JavaScript 的超集。TypeScript 在 JavaScript 的基础上添加了可选的静态类型和基于类的面向对象编程。</p>
<p>TypeScript 是基于 JavaScript 的，在运行时需要先编译成 JavaScript 代码，其设计目的是开发大型应用，便于多人协作。</p>
<a id="more"></a>

<p>与 JavaScript 的对比：</p>
<ul>
<li>TypeScript 更适合开发大型应用。</li>
<li>TypeScript 是 JavaScript 的超集，可以编译成纯 JavaScript 代码。</li>
<li>任何可以运行 JavaScript 的地方都可以运行 TypeScript 代码。</li>
<li>提供类、模块和接口等，能更好的构建和维护组件。</li>
</ul>
<p>其给 JavaScript 添加了一些语言扩展，包括：</p>
<ul>
<li>类型批注和编译时类型检查</li>
<li>类型推断</li>
<li>类型擦除</li>
<li>接口</li>
<li>枚举</li>
<li>Mixin</li>
<li>泛型编程</li>
<li>名字空间</li>
<li>元组</li>
<li>Await</li>
</ul>
<p>同时其从 ECMAScript5 移植了以下语法：</p>
<ul>
<li>类</li>
<li>模块</li>
<li>lambda 函数的箭头语法</li>
<li>可选参数及默认参数</li>
</ul>
<h2 id="TypeScript-安装"><a href="#TypeScript-安装" class="headerlink" title="TypeScript 安装"></a>TypeScript 安装</h2><p>安装 TypeScript 前，需先安装 node，然后使用 npm 进行 TypeScript 的安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>

<p>安装完成之后使用 tsc 命令查看版本号以及检查是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure>

<p>然后编写第一个 TypeScript 程序 hello.ts，以 .ts 结尾：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">&quot;hello TypeScript&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>

<p>然后将 hello.ts 文件编译成 js 文件，再运行该 js 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br><span class="line">node hello.js</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-变量类型"><a href="#TypeScript-变量类型" class="headerlink" title="TypeScript 变量类型"></a>TypeScript 变量类型</h2><p>TypeScript 包含如下数据类型：</p>
<ul>
<li>any：任意类型</li>
<li>number：数字类型</li>
<li>string：字符串类型</li>
<li>boolean：布尔类型</li>
<li>数组类型</li>
<li>元组</li>
<li>enum：枚举</li>
<li>void：用于标识方法的返回值，void 标识该方法没有返回值</li>
<li>null：表示一个空对象引用</li>
<li>undefined：初始化变量为一个未定义的值</li>
<li>never：never是其他类型（包括 null 和 undefined ）的子类型，代表从不会出现的值</li>
</ul>
<h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h3><p>任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p>
<ol>
<li>变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x:<span class="built_in">any</span> = <span class="number">1</span>;      <span class="comment">// 数字类型</span></span><br><span class="line">x = <span class="string">&quot;hello&quot;</span>;        <span class="comment">// 字符串</span></span><br><span class="line">x = <span class="literal">false</span>;          <span class="comment">// 布尔类型</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义存储各种类型数据的数组时</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayList:<span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">false</span>];</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">x.ifItExists();    <span class="comment">// 正确，ifItExists方法在运行时可能存在，但这里并不会检查</span></span><br><span class="line">x.toFixed();      <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h3 id="number-类型"><a href="#number-类型" class="headerlink" title="number 类型"></a>number 类型</h3><p>双精度 64 位浮点值。它可以用来表示整数和分数。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> num2:<span class="built_in">number</span> = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p>一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。反引号（`）来定义多行文本和内嵌表达式。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">`str1 is <span class="subst">$&#123;str1&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明存储number类型的数组</span></span><br><span class="line"><span class="keyword">let</span> arr1:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用泛型数组</span></span><br><span class="line"><span class="keyword">let</span> arr2:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x:[<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>];      <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">x1 = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>];    <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>枚举类型用于定义数值集合。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color = &#123;Red, Blue, Pink&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c:Color = Color.Red;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>用于标识方法返回值的类型，表示该方法没有返回值。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello ts&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><p>null 表示一个空对象的引用，typeof null 返回 “object”。</p>
<p>undefined 是一个为初始化值的变量，typeof undefined 返回 “undefined”。</p>
<p>null 和 undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。</p>
<p><strong>* 而在TypeScript中启用严格的空校验（–strictNullChecks）特性，就可以使得 null 和 undefined 只能被赋值给 void 或本身对应的类型。 *</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;            <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">null</span>;         <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中变量 x 只能是数字类型。如果一个类型可能出行 null 或 undefined， 可以用 | 来支持多种类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x:<span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;            <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">null</span>;         <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// right</span></span><br></pre></td></tr></table></figure>

<h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h3><p>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 数字类型</span></span><br><span class="line">y = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用crontab定时执行任务</title>
    <url>/2019/07/17/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在做一个小项目，要求能定时利用 <a href="http://doc.pm2.io/en/plus/overview/">pm2</a> 重启某个进程，即定时执行 <code>pm2 restart xxx</code>。</p>
<p>今天刚好发现 Linux 下可以使用 crontab 来定时执行一些脚本或命令，于是我就开始研究如何利用 crontab 搭配 pm2 定时重启某个进程。</p>
<a id="more"></a>



<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>在研究的过程中，我自己在网上看了很多教程，都是良莠不齐，花了好大功夫我才解决这个问题，接下来具体看一下我的解决过程。</p>
<p>首先看一下 Linux 下如何使用 crontab：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l      &#x2F;&#x2F; 列出Linux下当前用户所有的定时任务</span><br><span class="line">crontab -e     &#x2F;&#x2F; 编辑定时任务</span><br></pre></td></tr></table></figure>

<p>当首次使用 <code>crontab -l</code> 时，会提示当前用户下没有定时任务。</p>
<p>这时我们可以使用 <code>crontab -e</code> 创建一个定时任务，创建时会要求我们选择编辑器，这里我们选择 vim.tiny。如果第一次编辑器选错了，可以运行 <code>sudo select-editor</code>命令重新选择。</p>


<p>然后我们可以写定时任务了，这里我们输入如下代码，然后保存退出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * echo 123 &gt;&gt; &#x2F;test.log</span><br></pre></td></tr></table></figure>
<p>这个命令的意思是每过一分钟将 123 追加到 /test.log 文件的末尾。</p>
<p>从第一个 <code>*</code> 到 最后一个 <code>*</code> 分别是 <strong>分、时、日、月、周</strong>。</p>
<h3 id="执行-shell-脚本"><a href="#执行-shell-脚本" class="headerlink" title="执行 shell 脚本"></a>执行 shell 脚本</h3><p>同时我们也可以编写一个 shell 脚本，让其定时执行。</p>
<p>在 /root 目录下编写 a.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 123 &gt;&gt; &#x2F;root&#x2F;a.txt</span><br></pre></td></tr></table></figure>

<p>然后利用 <code>crontab -e</code> 命令，编辑定时任务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * sh &#x2F;root&#x2F;a.sh &gt;&gt; &#x2F;root&#x2F;test.a.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>上述代码是每分钟执行 a.sh 脚本，并将执行日志写入 /test.a.log 文件。</p>
<h3 id="配合-pm2-使用"><a href="#配合-pm2-使用" class="headerlink" title="配合 pm2 使用"></a>配合 pm2 使用</h3><p>知道基本用法之后我们配合 pm2 使用，想要每分钟重启id号为0的进程（该进程必须为正在运行中的进程），自然而然就会这样写：</p>
<p>首先编写一个 shell 脚本 /root/b.sh 用于重启id号为0的进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 restart 0</span><br></pre></td></tr></table></figure>

<p>然后利用 crontab 去定时执行这个脚本，并记录其日志，<code>crontab -e</code> 输入如下代码（<strong>注意不需要添加 PATH 或者 HOME=/ 等其他东西</strong>，我当时就是看网上添加了 PATH 和 HOME=/ ，之后一直报错）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * * sh &#x2F;root&#x2F;b.sh &gt;&gt; &#x2F;root&#x2F;b.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>然而这样写并不管用，我们打开 /root/b.log 看一下它的报错。</p>
<p>提示 pm2 not found，然后我们使用 <code>which pm2</code> 查看 pm2 的路径，将 pm2 换成其路径，重新编辑 <code>/root/b.shell</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pm2 restart 0</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了利用 crontab 每分钟重启 pm2 的某个进程。当然需要根据自己的需求去设定重启时间。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 继承</title>
    <url>/2019/03/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-5/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 Java 中，类的继承只能是单一继承，也就是说，一个子类只能拥有一个父类。</p>
<p>Java 中用 extends 关键字来实现继承。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承的特点：</p>
<ol>
<li>子类拥有父类非 private 的属性和方法</li>
<li>子类可以拥有自己的属性和方法</li>
<li>子类可以用自己的方式实现父类的方法</li>
<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类</li>
</ol>
<p>Java 中用 extends 关键字来实现继承，用 super 关键字来实现对父类成员的访问，用来引用当前对象的父类，用 this 关键字指向自己的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String fatherName = <span class="string">&quot;baba&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(String name,<span class="keyword">int</span> age,String fatherName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name,age);</span><br><span class="line">      <span class="keyword">this</span>.fatherName = fatherName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFatherName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fatherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFatherName</span><span class="params">(String fatherName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fatherName = fatherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Son s = <span class="keyword">new</span> Son(<span class="string">&quot;sillywa&quot;</span>,<span class="number">23</span>,<span class="string">&quot;myfatyher&quot;</span>);</span><br><span class="line">      System.out.println(s.getName());</span><br><span class="line">      System.out.println(s.getAge());</span><br><span class="line">      System.out.println(s.getFatherName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<em>子类是不能继承父类的构造方法的，它只是隐式调用。如果父类的构造方法带有参数，则必须在子类的构造器中显式通过 super 关键字调用父类的构造方法并配有适当的参数。且必须在子类构造方法的第一行**</em></p>
<p>如果父类构造方法没有参数，则在子类的构造方法中不需要使用 super 关键字调用父类构造方法，系统会自动调用父类的无参构造方法。</p>
<p>Java 中所有的类都继承 Object 类，如果一个类没有使用 extends 关键字明确标识继承另一个类，那么这个类默认继承 Object 类。</p>
<p>Object 类的 toString() 方法返回对象的哈希 code 码（对象地址字符串）。</p>
<p>Object 类的 equals() 方法比较对象的引用是否指向同一块地址。</p>
<h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>当父类中的有些方法对子类并不适用时，子类可以重写父类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;我是父亲：&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String fatherName = <span class="string">&quot;baba&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(String name,<span class="keyword">int</span> age,String fatherName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name,age);</span><br><span class="line">      <span class="keyword">this</span>.fatherName = fatherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;我是儿子：&quot;</span> + <span class="keyword">this</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFatherName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fatherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFatherName</span><span class="params">(String fatherName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fatherName = fatherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Son s = <span class="keyword">new</span> Son(<span class="string">&quot;sillywa&quot;</span>,<span class="number">23</span>,<span class="string">&quot;myfatyher&quot;</span>);</span><br><span class="line">      System.out.println(s.getName());</span><br><span class="line">      System.out.println(s.getAge());</span><br><span class="line">      System.out.println(s.getFatherName());</span><br><span class="line">      System.out.println(s.showDescription());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别地，如果超类方法是 public，子类方法一定要声明为 public。</p>
<h2 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h2><p>有时候可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。如果定义类时使用了 final 修饰符就表明这个类是 final 类。例如希望阻止人们定义 Son 类的子类，就可以在定义这个类时使用 final 修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类中的方法也可以被声明为 final。如果这样做，子类就不能重写这个方法（final 类中的所有方法自动地成为 final 方法，不包括成员变量）。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 封装</title>
    <url>/2019/03/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-4/</url>
    <content><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在面向对象程式设计方法中，封装是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<a id="more"></a>

<p>封装的优点：</p>
<ul>
<li>良好的封装能够减少耦合</li>
<li>类内部的结构可以自由修改</li>
<li>可以对成员变量进行更精确的控制</li>
<li>隐藏信息，实现细节</li>
</ul>
<p>类里面的所有数据都应该保持私有，除提供给对外的接口。</p>
<h2 id="实现封装"><a href="#实现封装" class="headerlink" title="实现封装"></a>实现封装</h2><p>修改属性的可见性来限制对属性的访问（一般限制为private），例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。同时提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java中的成员内部类"><a href="#Java中的成员内部类" class="headerlink" title="Java中的成员内部类"></a>Java中的成员内部类</h2><p>当一个类包含另一个类时，内部类如何访问外部类中的成员属性？如何在外部调用内部类中的方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 外部类的私有属性</span></span><br><span class="line">  <span class="keyword">private</span> String name = <span class="string">&quot;Sillywa&quot;</span>;</span><br><span class="line">  <span class="comment">// 外部类的成员属性</span></span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 成员内部类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;wenwen&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的name：&quot;</span> + Person.<span class="keyword">this</span>.name);</span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的age：&quot;</span> + Person.<span class="keyword">this</span>.age);</span><br><span class="line">      System.out.println(<span class="string">&quot;内部类中的name：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建外部类的对象</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="comment">// 创建内部类的对象</span></span><br><span class="line">    Inner inn = person.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    inn.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出：</p>
<p><strong>内部类通过 外部类名.this.成员属性 访问外部类中的成员属性。</strong></p>
<p><strong>当需要调用内部类中的方法时，需要先实例化外部类，再实例化内部类。</strong></p>
<h2 id="Java中的静态内部类"><a href="#Java中的静态内部类" class="headerlink" title="Java中的静态内部类"></a>Java中的静态内部类</h2><p>静态内部类如何访问外部类的变量？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 外部类的私有静态属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Sillywa&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String city = <span class="string">&quot;wuhan&quot;</span>;</span><br><span class="line">  <span class="comment">// 外部类的成员属性</span></span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 静态内部类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;wenwen&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 静态内部类访问外部的非静态成员： `new 外部类().成员`</span></span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的age：&quot;</span> + <span class="keyword">new</span> Person().age);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 内部类没有与该成员同名的变量： 直接通过 `变量名访问`</span></span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的age：&quot;</span> + city);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 内部类存在与该成员同名的变量： 通过 `类名.静态成员访问`</span></span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的name：&quot;</span> + Person.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>调用时需要实现引入静态内部类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> packageName.Person.Inner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建内部类的对象</span></span><br><span class="line">    Inner inn = <span class="keyword">new</span> Inner();</span><br><span class="line">    inn.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种情况：</p>
<ol>
<li>静态内部类访问外部的非静态成员： <code>new 外部类().成员</code></li>
<li>静态内部类访问外部的静态成员:<ul>
<li>内部类没有与该成员同名的变量： 直接通过 <code>变量名访问</code></li>
<li>内部类存在与该成员同名的变量： 通过 <code>类名.静态成员访问</code></li>
</ul>
</li>
</ol>
<h2 id="Java中的方法内部类"><a href="#Java中的方法内部类" class="headerlink" title="Java中的方法内部类"></a>Java中的方法内部类</h2><p><strong>方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 外部类中的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MInner</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> score = <span class="number">83</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score + <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建方法内部类的实例</span></span><br><span class="line">    MInner minner = <span class="keyword">new</span> MInner();</span><br><span class="line">    minner.getScore();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一定注意哦：<strong>由于方法内部类不能在外部类的方法以外的地方使用(相当于“局部类”)，因此方法内部类不能使用访问控制符和static修饰符。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类与对象</title>
    <url>/2019/03/11/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-3/</url>
    <content><![CDATA[<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><p>面向对象的程序设计（简称OOP）是当今主流的程序设计范式，Java 是完全面向对象的语言。面向对象的程序是由对象组成，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。在OOP中不必关心具体的实现，只要能够满足用户需求即可。</p>
<a id="more"></a>

<p>Alan Kay 曾经总结了第一个成功面向对象语言、同时也是 Java 所基于的语言之一的 Smalltalk 的五个基本特性，这些特性表现了一种纯粹的面向对象程序性设计的方式：</p>
<ul>
<li><p><strong>万物皆对象</strong>。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作。理论上讲，可以抽取待求解问题的任何概念化构件，将其表示为程序中的对象。</p>
</li>
<li><p><strong>程序是对象的集合，它们通过发送消息来告知彼此所要做的</strong>。要想请求一个对象，就必须对该对象发送一条消息。更具体地来说。可以把消息想象为对某个特定对象的方法的调用请求。</p>
</li>
<li><p><strong>每个对象都有自己的由其他对象所构成的存储</strong>。换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。</p>
</li>
<li><p><strong>每个对象都拥有其类型</strong>。即每个对象都是某个类的实例。</p>
</li>
<li><p><strong>某一特定类型的所有对象可以接受同样的消息</strong>。</p>
</li>
</ul>
<p>面向对象的语言有三个重要的特征：封装、继承、多态。</p>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类(class)是一个模板，它描述一类对象的行为和状态。由类构造(construct)对象的过程称为创建类的实例(instance)。<strong>对象具有状态、行为和标识</strong>。这意味着每一个对象都可以拥有内部数据（它们给出了该对象的状态）和方法（它们产生的行为），并且每一个对象都可以唯一地与其它对象区分开来，具体来说就是每一个对象在内存中都有一个唯一的地址。</p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><ul>
<li><p>依赖(“uses-a”)：一个类的方法操作另一个类的对象，应该尽可能地将相互依赖的类减至最少，也就是让类之间的耦合度最小。</p>
</li>
<li><p>聚合(“has-a”)：类A的对象包含类B的对象</p>
</li>
<li><p>继承(“is-a”)：类A扩展类B，类A包含类B的方法和属性</p>
</li>
</ul>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>在 Java 中使用 class 关键字来定义类，一个类的类名应该和文件名同名并且一般首字母大写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦定义了一个类（在Java中你所做的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象），就可以在类中设置两种基本的元素：<strong>字段</strong>（有时也被称为数据成员）和<strong>方法</strong>（有时也被称为成员函数）。字段可以是任何类型的对象，可以通过其引用与其进行通信；也可以是基本类型的一种。如果字段是某个对象的引用，那么必须初始化该引用，以便使其与一个实际的对象（使用 new 来实现）相关联。</p>
<h3 id="基本成员默认值（成员变量默认值）"><a href="#基本成员默认值（成员变量默认值）" class="headerlink" title="基本成员默认值（成员变量默认值）"></a>基本成员默认值（成员变量默认值）</h3><p>若类的某个成员是基本数据类型，即使没有进行初始化，Java 也会确保它获得一个默认值，如下所示。但是这些初始化对于程序来说可能是不正确的，甚至是不合法的。所以最好明确地对变量进行初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultValue.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultValue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> b;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">byte</span> by;</span><br><span class="line">  <span class="keyword">short</span> s;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">long</span> l;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printDefaultValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(b);    <span class="comment">// false</span></span><br><span class="line">    System.out.println(c);    <span class="comment">// &#x27;\u0000&#x27;(null)</span></span><br><span class="line">    System.out.println(by);   <span class="comment">// 0</span></span><br><span class="line">    System.out.println(s);    <span class="comment">// 0</span></span><br><span class="line">    System.out.println(i);    <span class="comment">// 0</span></span><br><span class="line">    System.out.println(l);    <span class="comment">// 0</span></span><br><span class="line">    System.out.println(f);    <span class="comment">// 0.0</span></span><br><span class="line">    System.out.println(d);    <span class="comment">// 0.0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是只有成员变量才会赋默认值，局部变量并不会有默认值。</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>在程序设计语言中将参数传递给方法有两种传递方式：<strong>按值调用</strong>表示方法接收的是调用者提供的值；<strong>按引用调用</strong>表示方法接受的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p>
<p><strong>Java语言总是采用按值传递。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<p>假定一个方法试图将一个参数的值增加三倍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  x = <span class="number">3</span>*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">tripleValue(percent);</span><br></pre></td></tr></table></figure>

<p>调用这个方法之后，percent 的值还是 10。下面看一下具体的执行过程：</p>
<p>1.x 被初始化为 percent 值的一个拷贝（也就是 10）；</p>
<p>2.x 被乘以 3 后等于 30。但是 percent 的值仍然是 10；</p>
<p>3.方法调用结束之后，参数变量 x 不再使用。</p>


<p>然而方法参数共有两种：</p>
<ul>
<li><p>基本类型</p>
</li>
<li><p>引用类型</p>
</li>
</ul>
<p>我们已经知道一个方法不可能修改一个基本数据类型的参数。而对象引用作为参数就不同了，可以很容易地利用方法将一个人的年龄提高三倍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleAge</span><span class="params">(Person x)</span> </span>&#123;</span><br><span class="line">  x.age = <span class="number">3</span> * x.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;sillywa&quot;</span>,<span class="number">20</span>);</span><br><span class="line">tripleAge(p);</span><br></pre></td></tr></table></figure>

<p>1.x 被初始化为 p 值的拷贝，这时 x 和 p 指向同一个对象；</p>
<p>2.当改变 x 的 age 时，即改变的是 x 和 p 共同指向的那个对象的 age；</p>
<p>3.方法结束之后，x 不再使用，但是 p 依然指向那个对象。</p>


<p>我们已经看到，实现改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其它的拷贝同时引用同一个对象。</p>
<p>有些人可能会认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不正确的。看一下例子：</p>
<p>首先编写一个交换两个Person对象的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Person x, Person y)</span> </span>&#123;</span><br><span class="line">  Person temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Java 对对象采用的是按引用调用，那么这个方法就应该能实现交换数据的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;sillywa&quot;</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;sw&quot;</span>,<span class="number">20</span>);</span><br><span class="line">swap(p1,p2);</span><br></pre></td></tr></table></figure>

<p>但是方法并没有改变存储在变量 p1 和 p2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个的拷贝。</p>


<p>最终在方法结束时参数变量 x 和 y都被丢弃了。原来的变量 p1 和 p2 仍然引用这个方法调用之前所引用的对象。</p>
<p>这个过程说明：Java程序设计语言对对象采用的不是引用调用，实际上对象引用是按值传递的。、</p>
<p>下面总结一下 Java 中方法参数的使用情况：</p>
<ul>
<li><p>一个方法不能修改一个基本数据类型的参数；</p>
</li>
<li><p>一个方法可以改变一个对象参数的状态；</p>
</li>
<li><p>一个方法不能让对象参数引用一个新的对象。</p>
</li>
</ul>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>在 Java 中每实例化一个类时都会调用类的构造器，也叫构造方法，用于确保类的初始化。</p>
<p>不接受任何参数的构造器叫做默认构造器，也叫无参构造器。但是和其他方法一样，构造器也能带参数，以便指定如何创建对象。</p>
<p>如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。<strong>构造方法的名称必须与类同名，一个类可以有多个构造方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>假设现在需要创建一个类，既可以用标准方法进行初始化，也可以从文件中读取信息来初始化。这就需要两个构造器：一个默认构造器，另一个取字符串作为形式参数。由于都是构造器，所以它们必须有相同的名字，即类名。<strong>为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载</strong>。同时，尽管方法重载是构造器所必需的，但它也可以用于其他方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num*age:&quot;</span> + age*num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区分方法重载：</strong></p>
<p>要是几个方法有相同的名字，Java 如何才知道你指的是哪一个呢？其实规则很简单：<strong>每个重载方法都必须有一个独一无二的参数列表</strong>。甚至参数顺序不同也足以区分两个方法，不过一般情况下不要这样做，因为这会使代码难以维护。</p>
<p>但是需要注意的是：<strong>不能根据方法的返回值来区分重载方法</strong>。</p>
<h2 id="static-用于创建静态变量和静态方法"><a href="#static-用于创建静态变量和静态方法" class="headerlink" title="static 用于创建静态变量和静态方法"></a>static 用于创建静态变量和静态方法</h2><p>文件结构，一个 package 下面有以下三个类，一个 package 下的所有类都是相互可见的:</p>
<ul>
<li><code>Main.java</code>     程序入口</li>
<li><code>Person.java</code>   Person类</li>
<li><code>Dog.java</code>      Dog类</li>
</ul>
<p><strong>对各种变量而言，成员变量只在本类中可以访问，而用 static 声明的静态变量或方法在同一个 package 下的所有类都可以访问，相当于该 package 下的全局变量或方法。</strong></p>
<p><strong>因此，对于静态变量或静态方法，应使用类名访问。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Person.allAge);</span><br><span class="line">    System.out.println(Dog.allAge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 声明静态变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge = <span class="number">70</span>;</span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dog.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 声明静态变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;dog age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态方法可以直接调用同类中的静态成员，但不能直接调用非静态成员。</strong></p>
<p><strong>普通方法中可以直接使用静态或非静态变量或方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge = <span class="number">70</span>;</span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通方法中可以直接使用静态或非静态变量或方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;person name:&quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;person allAge:&quot;</span> + allAge);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayAllAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person allAge:&quot;</span> + allAge);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法可以直接调用同类中的静态成员，但不能直接调用非静态成员。</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person age:&quot;</span> + age);    <span class="comment">// 调用非静态变量，报错</span></span><br><span class="line">    sayName();                                  <span class="comment">// 调用非静态方法，报错</span></span><br><span class="line">    sayAllAge();                                <span class="comment">// 调用静态方法，成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果在静态方法中想要调用非静态成员，需先实例化对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge = <span class="number">70</span>;</span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person name:&quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;person allAge:&quot;</span> + allAge);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayAllAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person allAge:&quot;</span> + allAge);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在静态方法中想要调用非静态成员，需先实例化对象。</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">12</span>,<span class="string">&quot;Sillywa&quot;</span>);           <span class="comment">// 实例化对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;person age:&quot;</span> + person.age);    <span class="comment">// 调用非静态变量，成功</span></span><br><span class="line">    person.sayName();                                  <span class="comment">// 调用非静态方法，成功</span></span><br><span class="line">    sayAllAge();                                <span class="comment">// 调用静态方法，成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-static-静态初始化块"><a href="#使用-static-静态初始化块" class="headerlink" title="使用 static 静态初始化块"></a>使用 static 静态初始化块</h2><p><strong>需要特别注意：静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">static</span> String name;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge;</span><br><span class="line">  &#123;</span><br><span class="line">    age = <span class="number">10</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;为普通变量赋值&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    allAge = <span class="number">90</span>;</span><br><span class="line">    name = <span class="string">&quot;Sillywa&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;为静态变量赋值&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">为静态变量赋值</span><br><span class="line">为普通变量赋值</span><br><span class="line">为普通变量赋值</span><br></pre></td></tr></table></figure>

<p><strong>可以看出，静态赋值最先执行，当实例化两个对象时，静态初始化只被执行一次。</strong></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>如果某个类只将它作为派生其他类的基类，而不想实例化它，那么可以将其设为抽象类。即抽象类不能被实例化，同时具有抽象方法的类必须声明为抽象类。</p>
<p>可以使用 abstrsct 关键字来声明抽象类和抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象方法在抽象类中可以不必实现，但是继承抽象类的类必须实现抽象类的抽象方法。</p>
<p>除了抽象方法外，抽象类中还可以包含具体的数据和具体方法。</p>
<h2 id="类的设计技巧"><a href="#类的设计技巧" class="headerlink" title="类的设计技巧"></a>类的设计技巧</h2><ol>
<li><p>一定要保证数据私有<br>绝对不要破坏封装性，因此需要编写访问器方法和更改器方法。本文代码为了简便没有按照此规范，千万不要学习这种写法。</p>
</li>
<li><p>一定要对数据进行初始化<br>Java不会对局部变量进行初始化，但是会对成员变量进行初始化。最好不要依赖于系统的默认值，而要显示初始化所有数据。</p>
</li>
<li><p>不要在类中使用过多的基本类型<br>尽量用其他类代替多个相关基本类型的变量的使用，这样使得类更容易理解和修改。</p>
</li>
<li><p>不是所有的成员变量都需要有访问器或更改器</p>
</li>
<li><p>将职责过多的类进行分解</p>
</li>
<li><p>类名和方法名要有含义</p>
</li>
<li><p>优先使用不可变类</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 数组</title>
    <url>/2019/03/10/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1;     <span class="comment">// 建议使用</span></span><br><span class="line">String arr2[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数组长度</span></span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">arr2 = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明的同时指定数组长度</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并赋值时不能指定长度</span></span><br><span class="line"><span class="keyword">int</span>[] arr4 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="For-Each-循环"><a href="#For-Each-循环" class="headerlink" title="For-Each 循环"></a>For-Each 循环</h3><p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p>
<p>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(type element : array) &#123;</span><br><span class="line">  System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> item : arrs) &#123;</span><br><span class="line">  System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays-类提供的方法"><a href="#Arrays-类提供的方法" class="headerlink" title="Arrays 类提供的方法"></a>Arrays 类提供的方法</h3><p>首先引入 Arrays 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>

<p>1.<code>public static void sort(Object[] a)</code></p>
<p>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">63</span>,<span class="number">2</span>,<span class="number">35</span>,<span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(arrs);</span><br></pre></td></tr></table></figure>

<p>2.<code>public static void fill(int[] a, int val)</code></p>
<p>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">Arrays.fill(arrs,a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arrs) &#123;</span><br><span class="line">  System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>3.<code>public static boolean equals(long[] a, long[] a2)</code></p>
<p>如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arrs2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arrs3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> a = Arrays.equals(arrs1, arrs2);</span><br><span class="line"><span class="keyword">boolean</span> b = Arrays.equals(arrs1, arrs3);</span><br><span class="line">System.out.println(a);    <span class="comment">// true</span></span><br><span class="line">System.out.println(b);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>4.<code>public static int binarySearch(Object[] a, Object key)</code></p>
<p>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(数组长度) - 1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> index1 = Arrays.binarySearch(arrs, a);</span><br><span class="line"><span class="keyword">int</span> index2 = Arrays.binarySearch(arrs, b);</span><br><span class="line">System.out.println(index1);</span><br><span class="line">System.out.println(index2);</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h3><p>一般情况下，定义一个方法包含以下语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名) &#123;</span><br><span class="line">  ···</span><br><span class="line">  方法体</span><br><span class="line">  ···</span><br><span class="line">  return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>如果一个类中有两个或两个以上方法名相同、方法参数的个数、顺序或者类型不同的方法，则称为方法的重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载show方法，一个参数方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hello&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载show方法，两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hello&quot;</span> + name);</span><br><span class="line">  System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载show方法，两个参数顺序不同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> age,S tring name)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hello&quot;</span> + name);</span><br><span class="line">  System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当重载方法被调用时，Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将会被执行。</strong></p>
<p><strong>判断方法重载的依据</strong></p>
<ol>
<li>必须在同一个类中</li>
<li>方法名相同</li>
<li>方法参数个数、顺序或类型不同</li>
<li>与方法的修饰符或返回值没有关系</li>
</ol>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>如果一个方法的参数不确定，则可使用可变参数，一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<p>方法的可变参数的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">typeName... parameterName</span><br></pre></td></tr></table></figure>

<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  printMax(<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">6</span>);</span><br><span class="line">  printMax(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(<span class="keyword">int</span>... numbers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;No data&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> max = numbers[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> item : numbers) &#123;</span><br><span class="line">    max = item &gt; max ? item : max;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 简介</title>
    <url>/2019/03/04/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<h2 id="Java-语言的特点"><a href="#Java-语言的特点" class="headerlink" title="Java 语言的特点"></a>Java 语言的特点</h2><ol>
<li>开源</li>
<li>一次编写，到处运行——跨平台性</li>
<li>与C/C++相似的语法结构</li>
<li>强类型</li>
<li>面向对象</li>
<li>丰富的库</li>
<li>使用垃圾回收机制进行内存管理</li>
<li>异常处理</li>
<li>并发处理</li>
<li>使用包对类进行分类</li>
</ol>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>JDK<br>Java development kit： Java 开发工具包</p>
</li>
<li><p>JRE<br>Java runtime environment：  Java 运行环境</p>
</li>
<li><p>JVM<br>Java virtual machine：  Java 虚拟机</p>
</li>
</ol>
<p>三者的关系：</p>


<h2 id="编写-Java-程序"><a href="#编写-Java-程序" class="headerlink" title="编写 Java 程序"></a>编写 Java 程序</h2><h3 id="使用记事本编写-Java-程序"><a href="#使用记事本编写-Java-程序" class="headerlink" title="使用记事本编写 Java 程序"></a>使用记事本编写 Java 程序</h3><p>1.编写源程序 MyProgram.java</p>
<p>2.使用 javac 命令编译源程序，生成 MyProgram.calss 字节码文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac MyProgram.java</span><br></pre></td></tr></table></figure>

<p>3.使用 java 命令运行程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java MyProgram</span><br></pre></td></tr></table></figure>



<h3 id="使用-Eclipse-编写-Java-程序"><a href="#使用-Eclipse-编写-Java-程序" class="headerlink" title="使用 Eclipse 编写 Java 程序"></a>使用 Eclipse 编写 Java 程序</h3><p>集成开发环境(IDE)是一类软件，将程序开发环境和调试环境集合在一起，提高开发效率。</p>
<ol>
<li>创建 Java 项目</li>
<li>创建程序包</li>
<li>编写 Java 源程序</li>
<li>运行 Java 程序</li>
</ol>


<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner stdIn = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取整数</span></span><br><span class="line">    <span class="keyword">int</span> a = stdIn.nextInt();</span><br><span class="line">    <span class="comment">// 读取小数</span></span><br><span class="line">    <span class="keyword">double</span> b = stdIn.nextDouble();</span><br><span class="line">    <span class="comment">// 读取字符串</span></span><br><span class="line">    <span class="comment">// 使用此方法读取字符串时，空白符和制表符被视为字符串的分隔符，因此如果输入中包含空格或者制表符，需要使用nextLine()</span></span><br><span class="line">    String s = stdIn.next();</span><br><span class="line">    <span class="comment">// 读取一整行</span></span><br><span class="line">    String sl = stdIn.nextLine();</span><br><span class="line"></span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(sl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出的方法有很多，比如：</p>
<ul>
<li><p><code>System.out.print()</code>    直接输出</p>
</li>
<li><p><code>System.out.println()</code>  输出一行</p>
</li>
<li><p><code>System.out.printf()</code>   与C语言的printf()函数类似</p>
</li>
</ul>
<p>读取输入可以使用 Java 的 Scanner 类，使用方法如上。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下阿里云镜像安装以及Nginx安装</title>
    <url>/2019/02/27/Linux%E4%B8%8B%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8ANginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本篇文章主要记录了<code>CentOS 7</code>系统以及<code>RedHat 7</code>系统如何安装阿里云镜像以及<code>Nginx</code>，并对<code>Nginx</code>实现基本配置。</p>
<a id="more"></a>

<p>目前<code>RHEL/CentOS</code>软件包主要有三种类型：</p>
<ul>
<li><p><code>RPM</code>包<br><code>rpm</code>是一个完整的数据库平台，包含软件包的版本、安装路径、配置文件等全方面的服务，提供的查询、安装、卸载、升级四大功能，尤其是查询功能，常用的命令有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-q    查询指定软件包是否安装</span><br><span class="line">-qa   查询所有已安装软件列表</span><br><span class="line">-qi   查询指定软件包信息</span><br><span class="line">-ql   查询指定软件包文件列表</span><br><span class="line">-qc   查询指定软件包配置文件</span><br><span class="line">-qf   根据文件路径反向查找软件包</span><br></pre></td></tr></table></figure>
<p>由于<code>rpm</code>各个包的依赖性太强，因此一般通过<code>yum</code>进行<code>rpm</code>包的批量安装，类似于前端的npm包文管理工具</p>
</li>
<li><p>源码包<br>源码包更新及时，可定制化，但是需要自己手动编译，其依赖于编译环境，不推荐新手使用</p>
</li>
<li><p>绿色包</p>
</li>
</ul>
<p>其中我们比较常用的就是通过<code>yum</code>进行<code>rpm</code>包的安装。</p>
<p><code>yum</code>仓库早期使用系统安装光盘，或者系统自带，更新不及时，安装速度也比较慢。</p>
<p>随着技术的发展，目前国内有些比较好的镜像源：如<a href="https://opsx.alibaba.com/mirror">阿里云</a>、<a href="https://mirrors.163.com/">163</a>，都可以提供比较便捷的<code>yum</code>仓库服务。因此我们需要使用国内镜像来通过<code>yum</code>来进行<code>RPM</code>包的安装。</p>
<p>对于<code>CentOS</code>系统而言，官方自带<code>yum</code>库，而<code>RHEL</code>不提供<code>yum</code>库，因此在安装镜像之前<code>RHEL</code>需要卸载原来的红帽<code>yum</code>源，装上<code>CentOS</code>的<code>yum</code>组件。</p>
<p>接下来就是具体的安装步骤。</p>
<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><p>由于<code>CentOS 7</code>自带官方<code>yum</code>库，因此可以直接安装阿里云镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、备份</span><br><span class="line"></span><br><span class="line">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line">2、下载新的CentOS-Base.repo 到&#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"></span><br><span class="line">CentOS 5</span><br><span class="line"></span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-5.repo</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-5.repo</span><br><span class="line">CentOS 6</span><br><span class="line"></span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo</span><br><span class="line">CentOS 7</span><br><span class="line"></span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line"></span><br><span class="line">3、之后运行yum makecache生成缓存</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以参看<a href="https://opsx.alibaba.com/mirror">阿里云镜像站</a>。</p>
<h2 id="REHEL-7"><a href="#REHEL-7" class="headerlink" title="REHEL 7"></a>REHEL 7</h2><p><code>redhat</code>相对<code>CentOS</code>系统麻烦一些，具体步骤：</p>
<ol>
<li><p>卸载红帽<code>yum</code>源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e $(rpm -qa|grep yum) --nodeps</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除所有<code>repo</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf &#x2F;etc&#x2F;yum.conf</span><br><span class="line">rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">rm -rf &#x2F;var&#x2F;cache&#x2F;yum</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载<code>CentOS</code>相关的<code>yum</code>组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-3.4.3-161.el7.centos.noarch.rpm</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-plugin-fastestmirror-1.1.31-50.el7.noarch.rpm</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-updateonboot-1.1.31-50.el7.noarch.rpm</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-utils-1.1.31-50.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果没有wget命令则使用curl命令</span><br><span class="line">curl -o yum-utils-1.1.31-50.el7.noarch.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-utils-1.1.31-50.el7.noarch.rpm</span><br><span class="line">curl -o yum-3.4.3-161.el7.centos.noarch.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-3.4.3-161.el7.centos.noarch.rpm</span><br><span class="line">curl -o yum-metadata-parser-1.1.4-10.el7.x86_64.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">curl -o yum-plugin-fastestmirror-1.1.31-50.el7.noarch.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-plugin-fastestmirror-1.1.31-50.el7.noarch.rpm</span><br><span class="line">curl -o yum-updateonboot-1.1.31-50.el7.noarch.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-updateonboot-1.1.31-50.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>安装时需要注意各个组件是否为最新版本，可前往目标网址查看。</p>
</li>
<li><p>安装所有相关组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh yum-* --nodeps</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载阿里云<code>base</code>仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">sed -i &#39;s#\$releasever#7#g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><p>经过以上步骤，我们已经安装了<code>yum</code>的阿里云镜像，里面只包含一些基本的库，因此我们还需要安装阿里云<code>epel</code>库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br></pre></td></tr></table></figure>

<p>接着可以下载<code>Nginx</code>官方镜像源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name&#x3D;nginx stable repo</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.key</span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是：<code>$releasever</code>为你系统的版本号</strong>。</p>


<p>然后就可以执行安装<code>Nginx</code>了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure>
<p>启动<code>Nginx</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start nginx   临时开启</span><br><span class="line">systemctl enable nginx  永久开启</span><br></pre></td></tr></table></figure>

<p>浏览器输入ip地址即可访问，如访问不了，请关闭防火墙。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld      临时关闭</span><br><span class="line">systemctl disable firewalld   永久关闭</span><br></pre></td></tr></table></figure>

<h2 id="Nginx文件说明"><a href="#Nginx文件说明" class="headerlink" title="Nginx文件说明"></a>Nginx文件说明</h2><p>全局配置文件：<code>/etc/nginx/nginx.conf</code></p>
<p>局部配置文件：<code>/etc/nginx/conf.d/*.conf</code></p>
<p>日志文件：<code>/var/log/nginx/&#123;access.log error.log&#125;</code><br>    访问日志：<code>access.log</code><br>    错误日志：<code>error.log</code></p>
<p>文档根目录：<code>/usr/share/nginx/html</code>    </p>
<p>如果要通过域名访问虚拟机，需要修改本地主机名解析记录：</p>
<ol>
<li><code>vim /etc/hosts</code></li>
<li>在文件中加入 <code>虚拟机ip 域名</code> 即可</li>
<li>访问本机 <code>c:\Windows\System32\drivers\etc\hosts</code></li>
<li>修改<code>hosts</code>文件，同第二步一样</li>
</ol>
<p>有关<code>Nginx</code>的更多可以参考<a href="/2018/12/22/nginx-1/" title="Ubuntu 系统 Nginx 服务下 ssl 证书配置">Ubuntu 系统 Nginx 服务下 ssl 证书配置</a> 以及 <a href="/2018/12/23/nginx-2/" title="Nginx 网站配置以及 NodeJS API 配置">Nginx 网站配置以及 NodeJS API 配置</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 网站配置以及 NodeJS API 配置</title>
    <url>/2018/12/23/nginx-2/</url>
    <content><![CDATA[<h3 id="网站配置简单说明"><a href="#网站配置简单说明" class="headerlink" title="网站配置简单说明"></a>网站配置简单说明</h3><p><code>Nginx</code> 主配置文件为  <code>/etc/nginx/nginx.conf</code></p>


<p><code>Nginx</code> 的 <code>server</code>模块配置文件放在 <code>/etc/nginx/sites-available</code>目录，该目录下默认有一个 <code>default</code> 文件，该文件为 <code>server</code> 模块文件。</p>


<p>我们可以看到 <code>root</code> 后面的路径就是我们网站存放的位置，因此你可以根据实际情况自己修改，我的网站是放在 <code>/var/www/sillywa.blog</code> 目录下，<code>Nginx</code> 会自动寻找该目录下的 <code>index.html</code> 文件。</p>
<a id="more"></a>

<p>其中 <code>server_name</code> 后面可以放我们的域名，多个域名用空格隔开</p>
<p>我们可以自己在 <code>default</code> 文件中新建其他 <code>server</code> 模块，<code>nginx.conf</code> 的 <code>http</code> 模块默认包含该目录下所有的文件</p>


<p>不过通过上图我们发现<code>nginx.conf</code> 默认包含的是 <code>/etc/nginx/sites-enabled/*</code> 下的所有文件，但是我们发现该目录下有一个 <code>default</code> 软链接，该软链接指向<code>/etc/nginx/sites-available/default</code> 文件，因此，对<code>/etc/nginx/sites-available/default</code> 文件的修改会同步到 <code>/etc/nginx/sites-enabled/default</code> </p>


<p>当然，除了直接修改  <code>/etc/nginx/sites-available/default</code> 文件外，我们也可以在 <code>/etc/nginx/conf.d</code> 文件夹下自己添加 <code>server</code> 配置文件，文件以<code>.conf</code>结尾。</p>
<h3 id="Nginx-与-NodeJS-简单结合"><a href="#Nginx-与-NodeJS-简单结合" class="headerlink" title="Nginx 与 NodeJS 简单结合"></a>Nginx 与 NodeJS 简单结合</h3><p>在 <code>Nginx</code> 中设置一个代理，让所有请求跳转到 <code>NodeJS</code> 服务的接口。</p>
<p>这是我们写好的 <code>NodeJS</code> 代码：</p>


<p>在 <code>NodeJS</code> 中我们设置了允许跨域，同时提供一个 <code>post</code> 方法的接口， <code>NodeJS</code> 监听 8888 端口。于是，我们在 <code>Nginx</code> 中加入如下配置：</p>
<p>可以在 <code>/etc/nginx/conf.d</code>文件夹下新建一个 <code>api.conf</code> 文件，然后写入如下配置：</p>


<p>其中的 <code>server_name</code> 是前端请求的 <code>api</code> 地址， <code>ssl</code> 是我们配置的 <code>ssl</code> 证书，可以参考<a href="/2018/12/22/nginx-1/" title="上一篇文章">上一篇文章</a>，<code>location</code> 做一个跳转，当有请求发到 <code>https://api.sillywa.com</code> 的时候， <code>Nginx</code> 会将请求转发到 <code>http://localhost:8888</code>，这样 <code>NodeJS</code> 就能接收到请求。</p>
<p>由于我们在 <code>NodeJS</code> 中允许了跨域，因此可以不必在 <code>Nginx</code> 中进行其他设置。</p>
<p>如果我们没有在 <code>NodeJS</code> 中做跨域， <code>Nginx</code> 中可以增加如下配置：</p>





]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 服务下 ssl 证书配置</title>
    <url>/2018/12/22/nginx-1/</url>
    <content><![CDATA[<p>最近在折腾 <code>Ubuntu</code> 系统以及如何让网站可以 <code>https</code> 访问，于是就了解到 <code>ssl</code> 证书以及 <code>Nginx</code> 服务。通过配置 <code>Nginx</code> 服务就可以让我们的网站可以通过 <code>https</code> 访问了。当然除了 <code>Nginx</code> 服务器可以选择之外，我们也可以利用 <code>Apache、Tomcat、IIS</code>等其他服务器，本文主要介绍 <code>Nginx。</code></p>
<a id="more"></a>

<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br><span class="line">&#x2F;&#x2F; 查看nginx版本</span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure>
<p><code>Ubuntu</code> 安装 <code>Nginx</code> 之后的文件结构大致为：</p>
<ul>
<li>所有配置文件都在 <code>/etc/nginx</code> 下面，并且每个虚拟主机已经安排在了 <code>/etc/nginx/sites-available</code> 下，该文件夹下有一个 <code>default</code> 配置文件</li>
<li>程序放在了 <code>/usr/sbin/nginx</code> </li>
<li>日志放在了 <code>/var/log/nginx</code> 中</li>
<li>启动脚本放在 <code>/etc/init.d/</code> 下</li>
<li>默认的虚拟主机的目录设置在了 <code>/var/www/nginx-default</code> (或者是 <code>/var/www</code>)，也就是说你的网站可以放在这个目录下</li>
</ul>
<h3 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure>

<p>之后可以访问 <code>http://你的公网 ip</code> ，默认监听 80 端口，启动时候若显示端口 80 被占用：<code> Starting nginx: [emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)</code> 修改文件：<code>/etc/nginx/sites-available/default</code>,去掉 <code>listen</code> 前面的 # 号 , # 号在该文件里是注释的意思 , 并且把 <code>listen</code> 后面的 80 端口号改为自己的端口，访问时需要添加端口号。</p>
<h3 id="配置-ssl-证书"><a href="#配置-ssl-证书" class="headerlink" title="配置 ssl 证书"></a>配置 ssl 证书</h3><p>阿里云购买的域名可以申请免费的 <code>ssl</code> 证书。下载之后就会有两个文件，一个 <code>.key</code> 文件，一个 <code>.pem </code>文件，<code>.key</code> 文件是证书私钥文件，<code>.pem</code> 文件是证书文件，一般包含两段内容。一般 <code>Nginx</code> 的一些文档会用该扩展名文件，在阿里云证书中与<code>.crt</code>文件一样。</p>
<p>最终我们获得了两个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example_com.key</span><br><span class="line">example_com.pem</span><br></pre></td></tr></table></figure>

<p>为了统一位置，我们可以把这两个文件放在 <code>/etc/ssl/private/</code> 目录，然后进入 <code>/etc/nginx/sites-available/</code> 目录修改 <code>default</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server; </span><br><span class="line">    listen 443 ssl default_server;</span><br><span class="line">    listen [::]:443 ssl default_server;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;example_com.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;example_com.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成之后重启 <code>Nginx</code> 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nginx reload</span><br></pre></td></tr></table></figure>

<p>之后就可以用 <code>https://www.example.com</code> 访问你的网站了。如果是第一次配置，访问到的就应该是 <code>Nginx</code> 的欢迎页面，该页面一般存放在我们前面说的  <code>/var/www/nginx-default</code> 文件夹下，这里的  <code>nginx-default</code> 一般为 <code>html</code> 文件夹，该文件夹下有一个 <code>.html</code> 文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>web语音识别现状</title>
    <url>/2018/12/18/web%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<p>前几天试着做了一下<code>web</code>的语音识别服务，发现里面还是有不少坑的，因此想写一下<code>web</code>语音识别现状，并对几个语音识别框架作简要分析。</p>
<a id="more"></a>

<h2 id="annyang"><a href="#annyang" class="headerlink" title="annyang"></a>annyang</h2><p>如果在 <code>GitHub</code> 上搜索 <code>Speech recognition</code> ，最受欢迎的前端语音识别库就是 <code>annyang</code>，这个仓库有5.1k <code>star</code>，看着这么多<code>star</code>想着这个语音识别库一定非常好用，于是我就开始了 <code>annyang </code>的爬坑之旅。</p>
<p>首先我在前面先说一下 <code>annyang</code> 这个语音识别库的问题，主要有两点：</p>
<ul>
<li>对于三大浏览器，只兼容 <code>Chrome</code> 浏览器，不兼容 <code>IE</code> 和火狐</li>
<li>需要翻墙才能使用</li>
</ul>
<p>总的来说 <code>annyang</code> 的文档写的还算详细，照着文档一步一步做也能做出理想的效果，但是由于其以上两个问题，因此放弃了对这个框架的进一步探索。</p>
<p>接下来我就探索了一下，为什么这个库会有这样的问题：</p>
<p>首先第一点，<code>annyang</code> 是基于 <code>H5</code> 的 <code>Speech Recognition API</code>，下面这张图说明了这个<code>API</code>的兼容性：</p>


<p>可以看到，大部分浏览器都不支持 <code>Speech Recognition</code>。</p>
<p>接着我们来看一下 <code>MDN</code> 官方文档上怎么说</p>


<p>大概意思是说 <code>Speech Recognition</code> 基于一个识别引擎，这个识别引擎我们推测是<code>Chrome</code>的，因此这就说明了<code>Speech Recognition</code> 只有翻墙才能使用。</p>
<p>因此基于 <code>Speech Recognition</code> 的语音识别我们是无法采用的。</p>
<p>接下来看一下国内的语音识别服务。</p>
<h2 id="腾讯语音识别"><a href="#腾讯语音识别" class="headerlink" title="腾讯语音识别"></a>腾讯语音识别</h2><p>国内的语音识别服务都不是直接的语音识别，怎么说呢，就是需要你上传音频文件到它的指定接口，然后将音频文件的内容识别出来。因此我们就需要改变一下语音识别策略，首先在前端我们需要将用户说的话给录下来，然后生成音频文件传给腾讯服务的接口，但是呢，由于浏览器存在同源策略，我们不能直接将音频文件传给腾讯的接口，所以我们需要一个中间层来帮助我们转发请求，所以现在<strong>语音识别的基础流程</strong>是：</p>
<ol>
<li>前端生成音频文件传给后台</li>
<li>后台接受音频文件转发给腾讯语音识别<code>api</code></li>
<li>腾讯语音识别<code>api</code>返回结果给后台</li>
<li>后台返回结果给前端</li>
</ol>
<p>这里的后台我用的是<code>NodeJS</code>，但是在用腾讯语音识别时，首先需要接口鉴权，我们看一下接口鉴权的具体内容：</p>


<p>看到这些我内心是崩溃的，感觉超级麻烦。但是最后还是照着做了，做了之后就各种鉴权有问题，然后纠结了半天，换成了科大讯飞的语音识别。</p>
<h2 id="科大讯飞语音识别"><a href="#科大讯飞语音识别" class="headerlink" title="科大讯飞语音识别"></a>科大讯飞语音识别</h2><p>我选的是科大讯飞的语音听写<code>api</code>，然后也是要接口认证，当然，认证过程没有腾讯那么麻烦，但是也是不少坑，我最终也是掉进去了走不出来。</p>


<p>最后我终于想到了百度语音识别，然后开始了最后的尝试。</p>
<h2 id="百度语音识别"><a href="#百度语音识别" class="headerlink" title="百度语音识别"></a>百度语音识别</h2><p>首先说明一下，百度语音识别是及其友好的，没有上面的那些授权认证什么的，如果是用<code>NodeJS</code>写后台的话，只需要通过 <code>npm</code> 安装 <code>baidu-aip-sdk</code> 即可调用相应的语音服务。这里在官方文档上有一个<a href="https://github.com/Baidu-AIP/sdk-demo">demo</a>。同时大家也可以参考一下我做的一个完整的前后台语音识别<a href="https://github.com/Sillywa/speech-recognition">demo</a>。</p>
<p>因此最终我选择了百度语音识别，因为其他两个弄了半天也没弄好。</p>
<p>所以我建议大家如果用<code>NodeJS</code>来做后台的话，可以优先选择百度语音识别。</p>
]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>变量对象</title>
    <url>/2018/12/07/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>前一篇文章<a href="/2018/12/07/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/" title="变量提升">变量提升</a>简单的介绍了一下变量提升原则，这篇文章将会从更专业的角度介绍变量提升，主要介绍了变量对象，全局上下文，函数上下文以及执行上下文。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>今天重点讲讲创建变量对象的过程。</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p>
<p>因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。</p>
<h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>我们先了解一个概念，叫全局对象。在 <a href="http://www.w3school.com.cn/jsref/jsref_obj_global.asp">W3School</a> 中也有介绍：</p>
<blockquote>
<p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。<br>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。<br>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 方法。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p>
</blockquote>
<p>如果看的不是很懂的话，容我再来介绍下全局对象:</p>
<p>1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>2.全局对象是由 Object 构造函数实例化的一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure>

<p>3.预定义了一堆，嗯，一大堆函数和属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 都能生效</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.Math.random());</span><br></pre></td></tr></table></figure>

<p>4.作为全局变量的宿主。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br></pre></td></tr></table></figure>

<p>5.客户端 JavaScript 中，全局对象有 window 属性指向自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.window.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br></pre></td></tr></table></figure>

<p>花了一个大篇幅介绍全局对象，其实就想说：</p>
<p>全局上下文中的变量对象就是全局对象呐！</p>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p>
<p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p>
<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p>
<ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p>
<p>变量对象会包括：</p>
<ol>
<li><p>函数的所有形参 (如果是函数上下文)</p>
<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
</li>
<li><p>函数声明</p>
<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li><p>变量声明</p>
<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
</li>
</ol>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">&quot;d&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ol>
<li><p>全局上下文的变量对象初始化是全局对象</p>
</li>
<li><p>函数上下文的变量对象初始化只包括 Arguments 对象</p>
</li>
<li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p>
</li>
<li><p>在代码执行阶段，会再次修改变量对象的属性值</p>
</li>
</ol>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>最后让我们看几个例子：</p>
<p>1.第一题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>

<p>第一段会报错：<code>Uncaught ReferenceError: a is not defined</code>。</p>
<p>第二段会打印：<code>1</code>。</p>
<p>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p>
<p>第一段执行 console 的时候， AO 的值是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        length: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p>
<p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p>
<p>2.第二题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>会打印函数，而不是 undefined 。</p>
<p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<p>转载至<a href="https://github.com/mqyqingfeng/Blog/blob/master/articles/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.md">深入系列文章/JavaScript深入之变量对象</a></p>
]]></content>
      <categories>
        <category>深入理解 Javascript 系列</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>变量提升</title>
    <url>/2018/12/07/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>提到<code>Javascript</code>是怎么执行代码的，大多数人的印象都是一行一行执行啊.但是Javascript在执行代码时,首先会进行解析,最常见的就是变量提升与函数提升.</p>
<p>接下来我们看个例子：</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>如果是一行一行执行的话，第一行输出<code>a</code>的时候，<code>a</code>还未定义，所以代码会报错。</p>
<p>但是运行时发现代码能正确执行，而且第一行输出的是<code>undefined</code>，第三行输出 2；这是为什么呢？</p>
<p>原来我们发现<code>Javascrip</code>t并不是一行一行分析执行代码，而是一段一段分析，然后再执行。这里的一段一段可以看作是一个作用域。那么<code>Javascript</code>是怎么在分析代码的呢？</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p><code>Javascript</code>在进入到一个作用域时，首先会进行“预解析”，查找变量声明和函数声明，也就是找 <code>var</code> 关键字和 <code>function</code> 关键字，然后将变量声明和函数声明提升到作用域顶端，然后再开始执行代码。分析我们前面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>首先进行“预解析”，查找变量声明和函数声明，找到 <code>var a</code>，放到作用域顶端，继续查找变量声明和函数声明，发现没有了，然后开始执行代码。相当于以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>然后再看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>首先进行“预解析”，查找变量声明和函数声明，找到 <code>function a() &#123;&#125;</code>，放到作用域顶端，继续查找变量声明和函数声明，发现没有了，然后开始执行代码。相当于以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<h2 id="变量与函数同名"><a href="#变量与函数同名" class="headerlink" title="变量与函数同名"></a>变量与函数同名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>首先进行“预解析”，查找变量声明和函数声明，找到 <code>var a</code>，然后找到 <code>function a() &#123;&#125;</code>，此时由于函数名与变量名相同，<strong>函数声明会覆盖变量声明</strong>，因此此时代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;函数表达式&quot;</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;函数声明&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>需要注意的是函数表达式并不会提升，因此以上代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;函数声明&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line">a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;函数表达式&quot;</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>这里只讨论了较为简单的变量提升问题，当函数作用域镶套时，问题就会变复杂，但是基本分析原理还是一样的。每当进入一个作用域时按照上面的方法进行分析即可。</p>
<a href="/2018/12/07/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/" title="下一篇文章">下一篇文章</a>将从更专业的角度说明了变量提升.
]]></content>
      <categories>
        <category>深入理解 Javascript 系列</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>词法作用域和动态作用域</title>
    <url>/2018/12/07/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>作用域是一套规则，用于确定在何处以及如何查找变量。<br>作用域有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所接受的<em>词法作用域</em>，也就是静态作用域，<code>Javascript</code> 正式基于这种作用域的。另一种叫做动态作用域，我们这里不作讨论。我们主要来看一下两者的区别。</p>
<a id="more"></a>

<h2 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h2><ul>
<li>词法作用域： 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定，换句话说，函数的作用域是函数在书写时决定的。</li>
<li>动态作用域： 动态作用域并不关心函数是如何声明以及在何处声明，只关心它们从何处调用，换句话说，函数的作用域是在函数被调用时决定的。</li>
</ul>
<p>看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure>

<p>假设 <code>Javascript</code> 采用词法作用域，我们看一下执行过程：</p>
<p>执行函数 <code>foo</code> ，在函数 <code>foo</code> 内部查找是否有局部变量 <code>a</code> ，如果没有，<strong>根据函数书写的位置</strong>，查找上面一层的代码，发现<code>a=1</code>，所以结果为1；</p>
<p>假设<code>Javascript</code>采用动态作用域，我们看一下执行过程：</p>
<p>执行函数<code>foo</code>，在函数<code>foo</code>内部查找是否有局部变量<code>a</code>，如果没有，<strong>就从调用函数的作用域</strong>，也就是<code>bar</code>内部查找变量<code>a</code>，发现<code>a=2</code>，所以结果为2；</p>
<p>根据我们前面的说明，<code>Javascript</code>是基于词法作用域的，所以结果为1。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>《JavaScript权威指南》在讲到词法作用域时，举了如下例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>

<p>根据词法作用域的规则，不论何时何地执行函数<code>f()</code>，返回的<code>scope</code>值都是<code>checkscope</code>内部局部变量<code>scope</code>的值，也就是<code>local scope</code>。</p>
]]></content>
      <categories>
        <category>深入理解 Javascript 系列</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>宽松相等和严格相等</title>
    <url>/2018/12/06/%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89%E5%92%8C%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<p>阅读本篇内容时建议先阅读<a href="/2018/12/06/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="隐式类型转换">隐式类型转换</a></p>
<p>我们通常认为“<code>==</code>检查值是否相等，<code>===</code>检查值和类型是否相等”。这样听起来蛮有道理，然而并不准确。正确的理解应该是：“<code>==</code>允许在相等比较中进行强制类型转换，而<code>===</code>不允许”。因此本文主要介绍在使用宽松相等时,对不同类型的Javascript变量,Javascript是如何进行解析的.</p>
<a id="more"></a>

<h2 id="1-字符串和数字之间的相等比较"><a href="#1-字符串和数字之间的相等比较" class="headerlink" title="1. 字符串和数字之间的相等比较"></a>1. 字符串和数字之间的相等比较</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b =<span class="string">&#x27;42&#x27;</span></span><br><span class="line"></span><br><span class="line">a == b  <span class="comment">// true</span></span><br><span class="line">a === b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>以上代码很容易理解，因为没有进行强制类型转换，所以<code>a===b</code>为<code>false</code>。</p>
<p>而<code>a==b</code>为宽松相等，如果两个值类型不同，其中一个或者两个会进行强制类型转换。</p>
<p>但具体是怎么转换的？是字符串转换为数字还是数字转换为字符串？<br>ES5规范中这样规定：</p>
<blockquote>
<p>(1)如果Type(x)是数字，Type(y)是字符串，则返回 x == ToNumber(y)的结果<br>(2)如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果</p>
</blockquote>
<p>简单来说就是将字符串转换为数字进行相等比较。</p>
<h2 id="2-其它类型与布尔值之间的相等比较"><a href="#2-其它类型与布尔值之间的相等比较" class="headerlink" title="2. 其它类型与布尔值之间的相等比较"></a>2. 其它类型与布尔值之间的相等比较</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;42&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">a == b  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们知道<code>&#39;42&#39;</code>是一个真值，为什么<code>==</code>的结果不是<code>true</code>呢？根据ES5规范：</p>
<blockquote>
<p>(1)如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果<br>(2)如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果</p>
</blockquote>
<p>简单来说就是将布尔值转换为数字进行相等比较。</p>
<p>具体到这个例子，<code>b</code>通过<code>ToNumber(b)</code>转换为数字为<code>1</code>，变为 <code>&#39;42&#39; == 1</code>，按照前面的规则<code>&#39;42&#39;</code>转换为<code>42</code>，最后变为 <code>42 == 1</code>，结果为<code>false</code>。</p>
<h2 id="3-null和undefined之间宽松相等"><a href="#3-null和undefined之间宽松相等" class="headerlink" title="3. null和undefined之间宽松相等"></a>3. <code>null</code>和<code>undefined</code>之间宽松相等</h2><p>在<code>==</code>中null和<code>undefined</code>相等（它们也与其自身相等），除此之外的其它值都不存在这种情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"></span><br><span class="line">a == b      <span class="comment">// true</span></span><br><span class="line">a == <span class="literal">null</span>   <span class="comment">// true</span></span><br><span class="line">b == <span class="literal">null</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a == <span class="literal">false</span>  <span class="comment">// false</span></span><br><span class="line">b == <span class="literal">false</span>  <span class="comment">// false</span></span><br><span class="line">a == <span class="string">&quot;&quot;</span>     <span class="comment">// false</span></span><br><span class="line">b == <span class="string">&quot;&quot;</span>     <span class="comment">// false</span></span><br><span class="line">a == <span class="number">0</span>      <span class="comment">// false</span></span><br><span class="line">b == <span class="number">0</span>      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="4-对象和非对象之间的相等比较"><a href="#4-对象和非对象之间的相等比较" class="headerlink" title="4. 对象和非对象之间的相等比较"></a>4. 对象和非对象之间的相等比较</h2><p>关于对象（对象/函数/数组）和标量基本类型（字符串/数字/布尔值）之间相等的比较，ES5规范中如下规定：</p>
<blockquote>
<p>(1)如果Type(x)是数字或字符串，Type(y)是对象，则返回 x == ToPrimitive(y)的结果；<br>(2)如果Type(x)是对象，Type(y)是数字和字符串，则返回 ToPrimitive(x) == y的结果。<br>这里只提到了数字和字符串，没有布尔值，是因为我们之前介绍过布尔值会被强制转换为数字。<br>例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">42</span>]</span><br><span class="line">a == b  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>[42]</code>首先会调用<code>ToPrimitive</code>抽象操作转换为<code>&#39;42&#39;</code>，变成<code>42 == &#39;42&#39;</code>，然后变成 <code>42 == 42</code>，返回<code>true</code>。</p>
<h2 id="5-比较少见的情况"><a href="#5-比较少见的情况" class="headerlink" title="5. 比较少见的情况"></a>5. 比较少见的情况</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">null</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="literal">false</span> == []</span><br><span class="line"><span class="literal">false</span> == &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">null</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == []</span><br><span class="line"><span class="string">&#x27;&#x27;</span> == &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="number">0</span> == []</span><br><span class="line"><span class="number">0</span> == &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上相等判断均可通过我们前面的讲解分析出来，答案我就不写了。</p>
<p>下面来看一种极端情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] == ![]</span><br></pre></td></tr></table></figure>

<p>以上代码的结果是<code>true</code>还是<code>false</code>，我们先来分析一下：首先<code>![]</code>会被转换为<code>false</code>，变为<code>[] == false</code>，然后<code>[]</code>通过<code>ToPrimitive</code>操作转换为<code>&#39;&#39;</code>，即 <code>&#39;&#39; == false</code>，然后<code>false</code>通过<code>ToNumber</code>转换为<code>0</code>，变为<code>&#39;&#39; == 0</code>，最后<code>&#39;&#39;</code>通过<code>ToNumber</code>转换为<code>0</code>，变为 <code>0 == 0</code>，结果为<code>true</code>。</p>
<h2 id="安全运用隐式强制类型转换"><a href="#安全运用隐式强制类型转换" class="headerlink" title="安全运用隐式强制类型转换"></a>安全运用隐式强制类型转换</h2><p>我们要对<code>==</code>两边的值进行认真推敲，一下两个原则可以让我们有效的避免出错。</p>
<ol>
<li>如果两边的值中有<code>true</code>或<code>false</code>，千万不要使用<code>==</code></li>
<li>如果两边的值中有<code>[]、&#39;&#39;或者0</code>，尽量不要使用<code>==</code></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript 基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2018/12/06/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>冒泡排序是最简单的交换排序，冒泡排序基本原理：</p>
<blockquote>
<p>对 N 个元素的待排序序列，共进行 N-1 次循环。<br>在第 k 次循环中，从第1到第 N-k 个元素从前往后进行比较，每次比较相邻的两个元素，若前一个元素比后一个大则交换两元素的位置，否则位置保持不变。<br>这样一次循环，就把第 k 大的元素放在了 N-k 的位置上，称为第 k 趟冒泡。整个过程共进行 N-1 趟，直到第 1 个元素和第 2 个元素比较完成，最终剩余最小的元素留在第一个位置，排序结束。</p>
</blockquote>
<a id="more"></a>

<p>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里我们可以增加一个flag,如果一趟排序下来没有任何元素交换，说明序列是有序的，不需要继续进行下一次循环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span>(i = N<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                Swap(&amp;a[j],&amp;a[j+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全程无元素交换，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JS语言实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i,j;</span><br><span class="line">    <span class="keyword">let</span> flag;</span><br><span class="line">    <span class="keyword">let</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span>(i = N<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [a[j],a[j+<span class="number">1</span>]] = [a[j+<span class="number">1</span>],a[j]];</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全程无元素交换，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然最坏情况下，冒泡排序的时间复杂度为 <code>O(N²)</code> ；在最好情况下，由于用了 <code>flag</code> 标记，只需要进行 <code>O(N)</code> 次比较就从循环中跳出来了。程序的平均时间复杂度为 <code>O(N²)</code>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>同源策略及其解决方案</title>
    <url>/2018/12/06/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>“同源政策”是浏览器安全的基石，其设计目的是为了保证信息安全，防止恶意的网站窃取数据。所谓“同源”必须满足以下三个方面：</p>
<ol>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同（默认端口是80，可以省略）</li>
</ol>
<a id="more"></a>

<p>如果是非同源的，以下行为会受到限制：</p>
<ul>
<li><code>Cookie、LocalStorage</code>和<code>IndexDB</code>无法读取</li>
<li><code>DOM</code>无法获取</li>
<li><code>AJAX</code>请求不能发送</li>
</ul>
<p>接下来我们主要讲解如何解决以上三个方面的问题。</p>
<h2 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h2><p><code>Cookie</code>只有同源的网站才能获取，但是如果两个网页的一级域名相同，只是二级域名不同，可以设置相同的<code>document.domain</code>，两个网页就可以共享<code>cookie</code>了。</p>
<blockquote>
<p>很多人都误把带<code>www</code>当成一级域名，把其他前缀的当成二级域名，是错误的。正确的域名划分为：<br>1.顶级域名：<code>.com</code><br>2.一级域名：<code>baidu.com</code><br>3.二级域名：<code>tieba.baidu.com</code></p>
<p>举例来说，A网页是<code>http://w1.sillywa.com/a.html</code>，B网页是<code>http://w2.sillywa.com/b.html</code>，我们可以设置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;sillywa.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样两个网页就可以共享<code>Cookie</code>了。</p>
<p>注意，这种方法只是用于<code>Cookie</code>和<code>iframe</code>，<code>LocalStorage</code>和<code>IndexDB</code>无法通过这种方法规避同源政策，而是要是用<code>PostMessage API</code>，下面我们会介绍。</p>
<h3 id="二、iframe"><a href="#二、iframe" class="headerlink" title="二、iframe"></a>二、iframe</h3><p>如果两个网页不同源，就没法拿到对方的<code>DOM</code>。典型的例子是<code>iframe</code>窗口和用<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>所以对于完全不同源的网站，目前可以使用一下三种办法规避同源问题：</p>
<ul>
<li>片段标识符(<code>fragment identifier</code>)</li>
<li><code>window.name</code></li>
<li>跨文档通信<code>API</code>(<code>window.postMessage</code>)</li>
</ul>
<h4 id="1-片段标识符"><a href="#1-片段标识符" class="headerlink" title="1.片段标识符"></a>1.片段标识符</h4><p>片段标识符指的是<code>URL</code>中<code>#</code>后面的内容，比如<code>http://sillywa.com/a.html#fragment</code>中的<code>#fragment</code>，如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息写入子窗口的片段标识符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myIframe&#x27;</span>).src = src</span><br></pre></td></tr></table></figure>

<p>子窗口通过监听<code>hashchange</code>事件得到通知：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.location.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-window-name"><a href="#2-window-name" class="headerlink" title="2.window.name"></a>2.window.name</h4><p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<h4 id="3-window-postMessage"><a href="#3-window-postMessage" class="headerlink" title="3. window.postMessage"></a>3. window.postMessage</h4><p><code>HTML5</code>为了解决跨窗口通讯问题引入了一个新的<code>API</code>：跨文档通信<code>API</code>。这个<code>API</code>为<code>window</code>新增了一个<code>window.postMessage()</code>方法，允许跨窗口通讯，不论这两个窗口是否同源。举例来说：假设父窗口为：<code>http://aaa.com</code>，子窗口为：<code>http://bbb.com</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父窗口向子窗口发送消息</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">&#x27;http://bbb.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line">popup.postMessage(<span class="string">&#x27;Hello World!&#x27;</span>, <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>postMessage()</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（<code>origin</code>），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。</p>
<p>同样，子窗口向父窗口发送消息可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">&#x27;Nice to see you&#x27;</span>, <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p><code>message</code>事件的<code>event</code>对象有以下三个属性：</p>
<ol>
<li><code>event.source：</code>发送消息的窗口</li>
<li><code>event.origin：</code>消息发送的网址</li>
<li><code>event.data：</code>消息内容</li>
</ol>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.source.postMessage(<span class="string">&#x27;Nice to see you!&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将发送的消息改为<code>LocalStorage</code>，则可以互相读取<code>LocalStorage</code>。</p>
<h3 id="三、AJAX"><a href="#三、AJAX" class="headerlink" title="三、AJAX"></a>三、AJAX</h3><p>同样<code>AJAX</code>请求也会受到同源策略的影响，除了使用代理服务器外，还有一下方法可以实现跨域：</p>
<ul>
<li><code>jsonp</code></li>
<li><code>WebScoket</code></li>
<li><code>CORS</code></li>
</ul>
<h4 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h4><p><code>jsonp</code>想必大家都很了解，其由两部分组成：回调函数和数据。其基本思路是：动态插入<code>script</code>标签，向服务器请求<code>json</code>数据，返回的数据将在回调函数里获得。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.setAttribute(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;text/javascript&quot;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Your public IP address is: &#x27;</span> + data.ip);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">&#x27;http://example.com/ip?callback=foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于<code>JSONP</code>是必需的。</p>
<h4 id="2-WebScoket"><a href="#2-WebScoket" class="headerlink" title="2.WebScoket"></a>2.WebScoket</h4><p><code>WebScoket</code>不同于<code>http</code>，它提供一种双向通讯的功能，即客户端可以向服务器请求数据，同时服务器也可以向客户端发送数据。而<code>http</code>只能是单向的。</p>
<p>同时<code>WebScoket</code>使用<code>ws:\//</code>（非加密）和<code>wss:\//</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>要创建<code>WebScoket</code>，先实例化一个<code>WebScoket</code>对象并传入要连接的<code>URL</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scoket = <span class="keyword">new</span> WebScoket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实例化<code>WebScoket</code>对象之后，浏览器会马上尝试建立连接。与<code>XHR</code>类似，<code>WebScoket</code>也有一系列表示当前状态的<code>readyState</code>属性，如下：</p>
<ul>
<li><code>WebScoket.OPENING</code>  (0)：正在建立连接</li>
<li><code>WebScoket.OPEN</code>  (1)：已经建立连接</li>
<li><code>WebScoket.CLOSING</code>  (2)：正在关闭连接</li>
<li><code>WebScoket.ClOSE</code>  (3)：已经关闭连接</li>
</ul>
<p><code>WebScoket</code>没有<code>readyStatechange</code>事件；不过它有其他的事件，我们待会介绍。</p>
<p>要关闭<code>WebScoket</code>连接，可以调用<code>close()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scoket.close()</span><br></pre></td></tr></table></figure>

<p><code>WebScoket</code>连接之后，就可以发送和就收数据。要发送数据可以调用<code>send()</code>方法，并传入字符串，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scoket = <span class="keyword">new</span> WebScoket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>)</span><br><span class="line">scoket.send(<span class="string">&#x27;hello word&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>因为<code>WebScoket</code>只能发送纯文本数据，所以对于复杂的数据类型我们应先将其序列化转化为json字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">scoket.send(<span class="built_in">JSON</span>.stringify(message))</span><br></pre></td></tr></table></figure>

<p>同样服务器必须先解析再读取数据。</p>
<p>当服务器向客户端发来消息时，<code>WebScoket</code>对象就会触发<code>message</code>事件。这个<code>message</code>事件与其它传递消息的协议类似，也就是把返回的数据保存在<code>event.data</code>的属性中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scoket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与通过<code>send()</code>发送到服务器的数据一样，<code>event.data</code>中返回的数据也是字符串。</p>
<p><code>WebScoket</code>对象还有其他三个事件，在连接生命周期的不同阶段触发。</p>
<ul>
<li><code>open：</code>在成功建立连接时触发</li>
<li><code>error</code>：在发生错误时触发，连接不能持续</li>
<li><code>close：</code>在连接关闭时触发</li>
</ul>
<p><code>WebScoket</code>对象不支持<code>DOM2</code>级事件侦听器，因此必须使用<code>DOM0</code>级语法分别定义每个事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scoket = <span class="keyword">new</span> WebScoket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>)</span><br><span class="line">scoket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;connection start&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">scoket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;connection error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">scoket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这三个事件中只有<code>close</code>的<code>event</code>对象有额外的信息。这个事件的对象有三个额外的属性：<code>wasClean、code、reason</code>。其中<code>wasClean</code>是一个布尔值，表示连接是否已经明确地关闭；<code>code</code>是服务器返回的数值状态码；<code>reason</code>是一个字符串，包含服务器发回的信息。</p>
<h4 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h4><p><code>CORS</code>是一个<code>W3C</code>标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。</p>
<p>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAX</code>只能同源使用的限制。</p>
<p>相比<code>jsonp</code>只能发送<code>get</code>请求，<code>CORS</code>允许发送任何类型的请求。但<code>CORS</code>要求浏览器和服务器同时支持。目前所有浏览器都支持，<code>IE</code>需要<code>IE10</code>以上。</p>
<p>整个<code>CORS</code>通讯过程中都是浏览器自动完成，不需要用户的参与。<code>CORS</code>通讯和同源的<code>AJAX</code>请求没有区别。浏览器一旦发现<code>AJAX</code>请求跨域，就会自动添加一些头部信息，有时候还会多出一次附加请求。</p>
<p>浏览器将<code>CORS</code>请求分为两类：简单请求和非简单请求。</p>
<p>只要同时满足一下两个条件就是简单请求，否则就是非简单请求：</p>
<p>（1）请求方法是下列方法之一：</p>
<ul>
<li><code>HEAD</code></li>
<li><code>GET</code></li>
<li><code>POST</code></li>
</ul>
<p>（2）<code>http</code>的头信息不超出以下几个字段：</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Last-Event-ID</code></li>
<li><code>Content-Type</code>：只限于三个值<code>application/x-www-form-urlencoded、multipart/form-data、text/plain</code></li>
</ul>
<p>对于简单请求，浏览器会自动在头部信息里增加一个<code>Origin</code>字段，用来表示请求来自与哪个源，服务器根据这个值决定是否同意此次请求。如果<code>Origin</code>不在请求范围内，服务器返回一个正常的<code>http</code>回应。这个回应的头信息中没有<code>Access-Control-Allow-Origin</code>字段，浏览器发现没有这个字段之后就会抛出一个错误。如果<code>Origin</code>在请求范围内，服务器返回的响应会多出几个头信息字段，其中一个是<code>Access-Control-Allow-Origin</code>，它的值要么是<code>Origin</code>的值，要么是*，表示允许任何域名的请求。</p>
<p>对于非简单请求，它会在正式通信之前，增加一次<code>http</code>查询请求，称为”预检”请求（<code>preflight</code>）。通常是一个<code>OPTION</code>请求。这个请求先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪<code>http</code>动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>如果大家想要更详细的了解<code>CORS</code>，可以参考以下文章。</p>
<p>参考文章：</p>
<p>阮一峰《<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a>》</p>
<p>阮一峰《<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a>》</p>
<p>参考书籍：</p>
<p>《javascript高级程序设计》</p>
]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器回流(Reflow)与重绘(Repaint)及其思考</title>
    <url>/2018/12/06/reflow-and-repaint/</url>
    <content><![CDATA[<p>我们知道浏览器在解析文档时，会经历以下步骤：</p>
<ol>
<li>将<code>HTML</code>解析为<code>DOM</code>，将<code>CSS</code>解析为<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并生成<code>Render Tree</code></li>
<li>然后根据<code>Render Tree</code>将节点绘制在页面上</li>
</ol>
<p>所谓回流是当元素尺寸、结构或者某些属性发生改变时，浏览器重新部分或者全部渲染文档的过程。<br>所谓重绘是指元素样式发生改变但并未改变其在文档流中的位置。</p>
<a id="more"></a>

<h3 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流(Reflow)"></a>回流(Reflow)</h3><p>我们理解了回流之后再看看哪些操作会导致浏览器回流：</p>
<ol>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或者位置发生变化</li>
<li>元素内容变化</li>
<li>元素字体变化</li>
<li>添加或删除<code>DOM</code></li>
<li>激活<code>CSS</code>伪类</li>
<li>查询某些属性或调用某些方法：<ul>
<li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li>
<li><code>offsetWidth、offsetHeight、offsetTop、offsetLeft</code></li>
<li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li>
<li><code>scrollIntoView()、scrollIntoViewIfNeeded()</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
<li><code>scrollTo()</code></li>
</ul>
</li>
</ol>
<h3 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘(Repaint)"></a>重绘(Repaint)</h3><p>当页面中元素的样式改变并不影响其在文档流中得到位置时，浏览器紧紧将新样式赋给它并重新绘制，这就是重绘。例如<code>color、background-color、visibility</code></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>既然这样那么我们如何避免重绘与回流呢？</p>
<ul>
<li>避免使用<code>table</code>布局</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上，脱离文档流的元素不会引起回流</li>
<li>可以使用<code>tranform</code>属性来设置动画</li>
<li>避免频繁操作样式，最好使用<code>class</code>来更改样式</li>
<li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面进行<code>DOM</code>操作</li>
<li>可以先将元素设为<code>display:none</code>，操作后再把它显示出来。因为在<code>display</code>为<code>none</code>的元素上操作不会引起重绘与回流</li>
</ul>
]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>JS事件</title>
    <url>/2018/12/06/event/</url>
    <content><![CDATA[<p>事件用来处理js与HTML之间的交互，我们可以使用事件处理程序来监听事件，以便在事件发生时执行相应代码。</p>
<a id="more"></a>

<h3 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h3><ul>
<li>事件冒泡：IE事件流叫做事件冒泡，即事件由最具体的元素向外传播，是由内向外的</li>
<li>事件捕获：事件捕获即事件由不具体的元素到具体元素，是由外向内传播</li>
<li>DOM事件流：DOM2级事件规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段</li>
</ul>
<h3 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h3><ul>
<li><h4 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h4></li>
</ul>
<p>直接在html代码中绑定事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;doSomething()&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>我们一般不采用这种方法绑定事件，因为html代码与js代码耦合度太高，不便于维护。但是现在的vue框架使用的却是这种事件处理程序。</p>
<ul>
<li><h4 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h4></li>
</ul>
<p>这种方法就是将一个函数赋值给一个事件处理程序属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中我们需要注意的是DOM0级事件处理程序被认为是元素的方法，因此事件处理程序是在元素的作用域中运行的，this指向当前元素。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 输出元素的id属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h4></li>
</ul>
<p>DOM2级事件处理程序定义了两个方法，用于处理指定和删除事件处理程序的操作：<code>addEventListener()</code>和<code>removeEventListener()</code>。所有DOM节点都包含这两个方法，并且他们都接受三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后一个布尔值如果为true表示在捕获阶段调用事件处理程序；如果为false表示在冒泡阶段调用事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>使用DOM2级事件处理程序的好处是可以为一个节点添加多个事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>这两个事件处理程序会按照顺序依次执行，所以首先弹出0，再弹出1。</p>
<p>通过<code>addEventListener()</code>添加的事件处理程序只能使用<code>removeEventListener()</code>来移除；移除时使用的参数应当与添加时相同。这也就是说直接添加的匿名函数处理程序是无法移除的，举例来说：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 没有用</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>在这个例子中我们虽然调用<code>removeEventListener()</code>使用的看似相同的参数，其实两个匿名函数根本不同，所以我们的给函数起个名字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, handler, <span class="literal">false</span>)  <span class="comment">// 有效</span></span><br></pre></td></tr></table></figure>
<p>大多数情况下我们都应该在事件冒泡阶段调用事件处理程序以兼容各大浏览器。最好在只需要在事件到达目标前截获它的时候将事件处理程序添加到事件捕获阶段。</p>
<p><strong>需要注意的是DOM2级事件处理程序和DOM0级事件处理程序一样，事件处理程序中的this也是指向当前元素。</strong></p>
<ul>
<li><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4></li>
</ul>
<p>IE实现了与DOM2级处理程序中类似的两个方法：<code>attachEvent()和detachEvent()</code>，这两个方法接受相同的两个参数：事件名称和事件处理程序函数。事件处理程序默认被添加到事件冒泡阶段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是<code>attachEvent()</code>第一个参数为<code>&#39;onclick&#39;</code>而非<code>addEventListener()</code>中的<code>&#39;click&#39;</code></strong></p>
<p><strong>在IE中使用<code>attachEvent()</code>与DOM0级DOM2级方法的主要区别在于事件处理程序函数的作用域不一样。在使用DOM0级DOM2级方法时，事件处理函数的作用域为当前元素所在作用域，this指向当前元素，而在使用<code>attachEvent()</code>方法时，事件处理程序函数的作用域为全局作用域，this指向window。</strong></p>
<p>同样我们亦可以使用<code>attachEvent()</code>方法为一个元素添加多个事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>不过需要注意的是，与DOM事件处理不同，这些事件处理程序并不是按照他们添加的顺序依次执行，而是以相反的顺序执行</strong>。所以先弹出1，再弹出0。</p>
<p>与DOM事件处理程序一样，通过<code>attachEvent()</code>添加的事件也只能使用<code>detachEvent()</code>方法移除，参数必须一模一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, handler)</span><br><span class="line">btn.detachEvent(<span class="string">&#x27;onclick&#x27;</span>, handler)</span><br></pre></td></tr></table></figure>

<p>在所有事件处理程序中HTML事件处理程序和DOM0级事件处理程序兼容所有浏览器，DOM2级事件处理程序兼容IE9+、Firefox、Chrome和OPera，IE事件处理程序兼容IE8及以下，不过现在大部分公司都不会兼容IE8及以下，所以广泛使用的还是DOM0级和DOM2级事件处理程序。</p>
<h3 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h3><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含所有与事件对象有关的信息。包括导致事件的元素、事件的类型等等。所有浏览器都支持event，但支持方式不同。</p>
<ul>
<li><h4 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h4><p>兼容DOM的浏览器都会将一个event对象传入到事件处理程序中。无论是DOM0级还是DOM2级事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>在通过HTML特性指定的事件处理程序时，同样存在event对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(event)&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>event对象包含一下常用属性与方法：</p>
</li>
<li><p><code>type</code>：事件类型如click</p>
</li>
<li><p><code>target</code>：事件实际发生的目标</p>
</li>
<li><p><code>preventDefault()</code>：取消事件的默认行为</p>
</li>
<li><p><code>stopPropagation()</code>：取消事件捕获或冒泡</p>
</li>
</ul>
<p>需要注意的是只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完毕，event对象就会被销毁。</p>
<ul>
<li><h4 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h4>与访问DOM中的event对象不同，访问IE中的event对象取决于事件处理程序。</li>
</ul>
<p>以下是DOM0级事件处理程序时的event：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = <span class="built_in">window</span>.event</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>event对象被看作为window的一个属性。</p>
<p>但是如果事件处理程序使用<code>attachEvent()</code>添加的，那么就会有一个event对象作为参数被传入事件处理函数中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果直接使用HTML事件处理程序，也可以通过event变量访问到event对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(event)&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>IE中的event对象同时也有一下几个常见的属性及方法：</p>
<ul>
<li><code>type</code></li>
<li><code>srcElement</code>：事件目标，相当于target</li>
<li><code>returnValue</code>：默认为true，设置为false可以取消事件的默认行为，相当于preventDefault()</li>
<li><code>cancelBubble</code>：默认为false，将其设置为true可以取消事件冒泡，相当于stopPropagation()</li>
</ul>
<h3 id="四、事件委托"><a href="#四、事件委托" class="headerlink" title="四、事件委托"></a>四、事件委托</h3><p>当事件处理程序过多时，为了避免我们一个个添加事件处理程序，我们可以考虑使用事件委托。考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;sayOne&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;sayTwo&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;sayThree&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>现在我们要点击li元素然后执行不同的函数，一般做法是给每一个li元素都添加一个事件处理程序，但是这种做法或导致页面性能下降，因此我们利用事件冒泡，只指定一个事件处理程序，用它来管理所有同类事件，具体实现方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>)</span><br><span class="line">list.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// target为当前点击的元素</span></span><br><span class="line">    <span class="keyword">var</span> target = event.target</span><br><span class="line">    <span class="keyword">switch</span>(target.id) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;sayOne&#x27;</span>:</span><br><span class="line">            alert(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;sayTwo&#x27;</span>:</span><br><span class="line">            alert(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;sayThree&#x27;</span>:</span><br><span class="line">            alert(<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript 基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM</title>
    <url>/2018/12/06/DOM/</url>
    <content><![CDATA[<p>所谓DOM就是文档对象模型，我们可以把一个文档的各种元素想象成一个节点树，每一段标记都可以通过树中的一个节点（Node）来表示：HTML元素通过元素节点表示、属性通过属性节点表示、文本通过文本节点表示。总共有12种节点类型，我们需要重点掌握元素节点，属性节点和文本节点。</p>
<a id="more"></a>

<h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>每一个节点都具有一系列公共属性，下面我们列举一下常见的属性：</p>
<ul>
<li><code>nodeType</code>: 显示节点的类型，1代表元素节点、2代表属性节点、3代表文本节点</li>
<li><code>nodeName</code>: 元素节点的标签名，以大写表示</li>
<li><code>tagName</code>: 与<code>nodeName</code>一样</li>
<li><code>nodeValue</code>: 元素节点的值，文本节点和属性节点才有值，元素节点的<code>nodeValue</code>为<code>null</code></li>
<li><code>attributes</code>: 返回属性节点的集合<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;wrapper&quot;</span> id=<span class="string">&quot;totop&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;totop&#x27;</span>).attributes[<span class="string">&quot;id&quot;</span>]  <span class="comment">// 此处是id属性节点，并不是id的值</span></span><br><span class="line"><span class="comment">// 要得到id的值，只需获取该属性节点的值</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;totop&#x27;</span>).attributes[<span class="string">&quot;id&quot;</span>].nodeValue</span><br><span class="line"><span class="comment">// 当然一般情况下我们这样获取id的值</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;totop&#x27;</span>).id</span><br></pre></td></tr></table></figure></li>
<li><code>firstChild</code>: 表示某个节点的第一个节点</li>
<li><code>lastChild</code>: 表示某个节点的最后一个节点</li>
<li><code>childNodes</code>: 表示某个节点的所有子节点的数组</li>
<li><code>parentNode</code>: 表示某个节点的第一个父节点</li>
<li><code>nextSibling</code>: 下一个兄弟节点</li>
<li><code>previousSibling</code>: 上一个兄弟节点</li>
</ul>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><ol>
<li>创建节点<ul>
<li>创建一个元素节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个div元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>创建一个文本节点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var text &#x3D; document.createTextNode(&#39;Hello Word&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>添加节点</li>
</ol>
<p>当我们创建了一个个节点之后我们需要把他们组合在一起，即将一个节点添加到另一个节点中。这是我们可以用<code>appendChild()</code>方法，将该节点添加到另一个节点的<code>childNodes</code>末尾。添加节点之后，<code>appendChild()</code>返回新增的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个div元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello Word&#x27;</span>)</span><br><span class="line">div.appendChild(text)</span><br><span class="line"><span class="comment">// 最后还需要将节点加入到body中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line"></span><br><span class="line">div.lastChild == div.appendChild(text)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>插入节点</li>
</ol>
<p>我们可以用<code>insertBefore()</code>方法来在一个节点之前插入另一个节点，调用该方法的应当是目标节点的父节点，这个方法接受两个参数：要插入的节点和目标节点。插入节点后，被插入的节点会变成目标节点的前一个兄弟节点(<code>previousSibling</code>)，同时返回插入的节点。如果第二个参数是<code>null</code>，则和<code>appendChild()</code>方法一样。</p>
<p>下面是该方法的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parentElement.insertBefore(newElement, targetElement)</span><br></pre></td></tr></table></figure>
<p>我们不必搞清楚目标元素的父元素是谁，因为<code>targetElement</code>元素的<code>parentNode</code>就是目标元素的父元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">targetElement.parentNode.insertBefore(newElement, targetElement)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>移除节点</li>
</ol>
<ul>
<li><p><code>replaceChild()</code>：该方法替换一个节点的子节点，接受两个参数：第一个为新的节点，第二个为目标节点，返回目标节点并从文档中被移除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换第一个子节点</span></span><br><span class="line">someNode.replaceChild(newNode, someNode.firstChild)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>removeChild()</code>：该方法接受一个参数，即要移除的节点，返回移除的节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除第一个子节点</span></span><br><span class="line">someNode.removeChild(someNode.firstChild)</span><br></pre></td></tr></table></figure>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3></li>
</ul>
<ol>
<li>获取属性</li>
</ol>
<p>通常情况下我们可以使用<code>getAttribute()</code>方法来获取一个属性节点的值，该方法只有一个参数：要获取的属性的名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someNode.getAttribute(attribute)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>设置属性</li>
</ol>
<p>当我们需要修改或设置属性时，可以使用<code>setAttribute()</code>方法，该方法接受两个参数：要设置或修改的属性，属性值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someNode.setAttribute(attribute, value)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>移除属性</li>
</ol>
<p>当我们需要移除属性时，可以使用<code>removeAttribute()</code>方法，该方法接受一个参数：要移除的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someNode.removeAttribute(attribute)</span><br></pre></td></tr></table></figure>
<h3 id="理解元素的子节点"><a href="#理解元素的子节点" class="headerlink" title="理解元素的子节点"></a>理解元素的子节点</h3><p>我们需要注意的是不同浏览器处理子节点的方式是不一样的，以下面代码为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很显然<code>&lt;div&gt;</code>元素有3个子节点，分别是3个<code>&lt;p&gt;</code>元素，但是这种说法只有在IE浏览器中才是正确的。因为在其它浏览器中<code>&lt;div&gt;</code>有7个子节点，增加了4个文本节点（表示<code>&lt;p&gt;</code>元素之间的空隙）。如果像下面这样删除空格，那么所有浏览器都会返回相同数量的子节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此如果要通过<code>childNodes</code>属性遍历子节点，一定要判断节点类型即<code>nodeType</code>的值，只有当<code>nodeType</code>值为1时，才能进行操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = element.childNodes.length; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.childNodes[i].nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript 基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Object.defineProperty() 的原生js双向数据绑定</title>
    <url>/2018/12/06/%E5%8E%9F%E7%94%9Fjs%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>前面我们介绍过存储器属性(<a href="/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/" title="重新认识JS对象（一）-- 对象及其属性">重新认识JS对象（一）-- 对象及其属性</a>)，以及如何用<code>Object.defineProperty()</code>定义一个存储器属性，今天我们介绍如何用<code>Object.defineProperty()</code>实现双向数据绑定。</p>
<a id="more"></a>

<p>我们知道一个存储器属性有四个属性描述符：<code>get，set，configurable，enumerable</code>。我们来复习一下如何创建一个存储器属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    name: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;nickname&#x27;</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上代码我们给<code>user</code>创建了一个名为<code>nickname</code>的存储器属性。</p>
<p>接下来我们改写<code>get</code>和<code>set</code>，让它们与<code>DOM</code>绑定，并实现双向数据绑定，以下为具体实现的伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> user = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;inputValue&#x27;</span>, &#123;</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>我们打开控制台，改变<code>user.inputValue</code>的值，会发现<code>input</code>输入框里的值也发生变化；同样我们在<code>input</code>输入框里面输入值，在控制台打印<code>user.inputValue</code>，会发现<code>user.inputValue</code>也发生了变化。这样我们就实现了双向的数据绑定。</p>
<p>如果多个<code>DOM</code>绑定同一个数据，我们可以监听<code>input</code>输入框的<code>keyup</code>事件，只要触发了<code>keyup</code>事件我们就把<code>user.inputValue</code>的值赋给另一个<code>DOM</code>，具体实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;test&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> user = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;inputValue&#x27;</span>, &#123;</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value = value</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML = user.inputValue</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>最后附上源码图片<br><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e673d16d3544a?w=809&h=889&f=png&s=92772"></p>
<p>思考：其实实现双向数据绑定并不一定要用<code>Object.defineProperty()</code>，其主要是运用存储器属性的<code>get和set</code>，以下代码也可以实现双向数据绑定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;test&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> user = &#123;</span><br><span class="line">      <span class="keyword">get</span> <span class="title">inputValue</span>() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span> <span class="title">inputValue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value = value</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML = user.inputValue</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript 基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式类型转换</title>
    <url>/2018/12/06/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>在javascript中隐式类型转换总是返回基本类型值，如字符串、数字、布尔值，不会返回对象或者函数。所以我们在介绍隐式类型转换之前首先来看一看字符串、数字、布尔值之间类型转换的基本规则。这里涉及到<code>ToString</code>、<code>ToNumber</code>和<code>ToBoolean</code>，同时我们还会介绍<code>ToPrimitive</code>。</p>
<a id="more"></a>

<h2 id="一、抽象值操作"><a href="#一、抽象值操作" class="headerlink" title="一、抽象值操作"></a>一、抽象值操作</h2><h3 id="（一）ToString"><a href="#（一）ToString" class="headerlink" title="（一）ToString"></a>（一）<code>ToString</code></h3><p><code>ToString</code>负责处理非字符串到字符串的强制类型转换。</p>
<p>(1)基本类型的值转化为字符串的基本规则：</p>
<pre><code>1. null转化为&quot;null&quot;
2. undefined转化为&quot;undefined&quot; 
3. true转化为&quot;true&quot;
4. 数字的字符串转化规则遵循通用规则，不过那些极小或者极大的数值使用指数形式：

var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000
a.toString()  // &quot;1.07e21&quot;</code></pre>
<p>(2)对于普通对象来说，如果没有自定义<code>toString()</code>方法，返回<code>&quot;[object Object]&quot;</code>。如果有自己的<code>toString()</code>方法就会调用该方法并返回值。</p>
<p>(3)数组的<code>toString()</code>返回所有单元字符串化以后再用”,”连接起来：<br>    var a = [1,2,3]<br>    a.toString()  // “1,2,3” </p>
<p>(4)日期、正则、函数也遵循通用规则。</p>
<h3 id="（二）ToNumber"><a href="#（二）ToNumber" class="headerlink" title="（二）ToNumber"></a>（二）<code>ToNumber</code></h3><p>(1)基本类型的值转化为数字的基本规则：</p>
<pre><code>1. null转化为0
2. undefined转化为NaN
3. true转化为1，false转化为0
4. 字符串的处理遵循通用规则

Number(&quot;23&quot;)  // 23
Number(&quot;&quot;)    // 0</code></pre>
<p>(2)对象或者数组首先会被转化为相应的基本类型，如果返回的是非数字的基本类型，再按照以上规则进行转化。其中对象转化为基本类型的时候会使用<code>ToPrimitive</code>操作。</p>
<h3 id="（三）ToPrimitive"><a href="#（三）ToPrimitive" class="headerlink" title="（三）ToPrimitive"></a>（三）<code>ToPrimitive</code></h3><p><code>ToPrimitive</code>操作会首先检查对象是否有<code>valueOf()</code>方法，如果有并且返回基本类型的值，就调用该方法进行类型转化。如果没有就使用<code>toString()</code>返回的值。</p>
<p>如果<code>valueOf()</code>和<code>toString()</code>均不返回基本类型的值，就会产生<code>TypeError</code>错误。</p>
<p>如果不对对象和数组的<code>valueOf()</code>和<code>toString()</code>方法进行重写，那么：</p>
<p>(1)对象的<code>valueOf()</code>返回对象本身，<code>toString()</code>返回<code>&quot;[object Object]&quot;</code></p>
<p>(2)数组的<code>valueOf()</code>返回数组本身，<code>toString()</code>返回所有单元字符串化以后再用”,”连接起来。</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.valueOf()   <span class="comment">// &#123; name: &#x27;sillywa&#x27; &#125;</span></span><br><span class="line">a.toString()  <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line">b.valueOf()   <span class="comment">// [1,2,3]</span></span><br><span class="line">b.toString()  <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure></code></pre>
<h3 id="（四）ToBoolean"><a href="#（四）ToBoolean" class="headerlink" title="（四）ToBoolean"></a>（四）<code>ToBoolean</code></h3><ol>
<li><code>null</code>转化为<code>false</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>undefined</code>转化为<code>false</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>除””以外，所有字符串转化为<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>)  <span class="comment">// fasle</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;abc&quot;</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;0&#x27;</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>除0（包括+0和-0）和<code>NaN</code>外，所有数字转化为<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">-9</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>所有对象转化为<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([])  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是通过new关键字得到的是一个对象</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Boolean</span>(a &amp;&amp; b &amp;&amp; c)</span><br><span class="line">d   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="二、隐式类型转化"><a href="#二、隐式类型转化" class="headerlink" title="二、隐式类型转化"></a>二、隐式类型转化</h2><h3 id="（一）字符串和数字之间的隐式类型转化"><a href="#（一）字符串和数字之间的隐式类型转化" class="headerlink" title="（一）字符串和数字之间的隐式类型转化"></a>（一）字符串和数字之间的隐式类型转化</h3>(1)数字转化为字符串</li>
</ol>
<p>+运算符既能用于数字相加，也能用于字符串拼接。那么javascript是怎么判断我们要执行那个操作的呢？例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;42&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">a + b  <span class="comment">// &quot;420&quot;</span></span><br><span class="line">c + d  <span class="comment">// 42</span></span><br><span class="line">e + f  <span class="comment">// &quot;420&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上代码不难理解，通常我们认为+运算符两边只要有一个操作数是字符串就会执行字符串的拼接操作，但是实际情况更为复杂，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a + b  <span class="comment">// &quot;1,23,4&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>a,b</code>都不是字符串，但是它们都被转化为字符串进行拼接操作，原因何在？</p>
<p>简单的理解应当是如果+运算符其中一个是字符串或者可以通过<code>ToPrimitive</code>（针对于对象，包括数组）转化为字符串，则执行字符串的拼接；否则执行数字相加。</p>
<p><em style="color:red">需要注意的是如果是 <code>+ &#39;42&#39;</code>代表强制类型转化为数字，即 <code>42</code>。</em></p>
<p>(2)字符串转化为数字</p>
<p>- , * , /都可以用来将字符串转化为数字，其规则与+类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;3.14&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = a - <span class="number">0</span></span><br><span class="line">b  <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<p>同样对于对象和数组也是一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>]</span><br><span class="line">a - b   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>为了执行减法运算，<code>a、b</code>都需要被转化为数字，首先通过<code>ToPrimitive</code>转化为字符串再转化为数字。</p>
<h3 id="（二）布尔值到数字的隐式类型转化"><a href="#（二）布尔值到数字的隐式类型转化" class="headerlink" title="（二）布尔值到数字的隐式类型转化"></a>（二）布尔值到数字的隐式类型转化</h3><p>简单举了例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="literal">false</span>  <span class="comment">// 1</span></span><br><span class="line"><span class="number">1</span>+ <span class="literal">true</span>  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="（三）隐式类型转化为布尔值"><a href="#（三）隐式类型转化为布尔值" class="headerlink" title="（三）隐式类型转化为布尔值"></a>（三）隐式类型转化为布尔值</h3><p>以下几种情况会发生隐式类型转化为布尔值</p>
<ol>
<li><code>if(..)</code>条件判断语句</li>
<li><code>for()</code>中的条件判断</li>
<li><code>while()</code>和<code>do..while(..)</code>中的条件判断</li>
<li><code>? :</code> 三目运算符中的条件判断</li>
<li>逻辑运算符 <code>|| </code>和<code> &amp;&amp;</code> 左边的操作数</li>
</ol>
<h3 id="（四）-和-amp-amp"><a href="#（四）-和-amp-amp" class="headerlink" title="（四）|| 和 &amp;&amp;"></a>（四）<code>|| 和 &amp;&amp;</code></h3><p>ES5规范中有如下描述</p>
<blockquote>
<p><code>&amp;&amp;</code>和 <code>||</code> 运算符并不一定返回布尔值，而是两个操作数其中一个的值</p>
</blockquote>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">a || b  <span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b  <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line">c || b  <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line">c &amp;&amp; b  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p><code>|| 和 &amp;&amp;</code> 首先会对第一个操作数进行条件判断，如果其不是布尔值，会被转化为布尔值，在进行判断。</p>
<p>对于 <code>||</code> 如果第一个操作数返回true则返回第一个操作数的值，如果第一个操作数返回false就返回第二个操作数的值。</p>
<p>对于 <code>&amp;&amp;</code> 如果第一个操作数返回true则返回第二个操作数的值，如果第一个操作数返回false就返回第一个操作数的值。</p>
<p>本篇就介绍到这里，下篇介绍隐式类型转换之(宽松相等和严格相等)。</p>
]]></content>
      <categories>
        <category>JavaScript 基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识JS对象（三）-- 原型及原型链</title>
    <url>/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>原型及原型链是Javascript里面很重要的概念,本文深入探讨了两者的关系及区别.</p>
<a id="more"></a>

<h2 id="一、原型检测"><a href="#一、原型检测" class="headerlink" title="一、原型检测"></a>一、原型检测</h2><p>javascript中提供<code>Object.getPrototypeOf()</code>方法来获得对象的直接原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1)  <span class="comment">// &#123;constructor: ƒ Person()&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1.__proto__)  <span class="comment">// Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person2)  <span class="comment">// &#123;name: &quot;sillywa&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>javascript有以下几种方法检测一个对象的原型：</p>
<ol>
<li><code>isPrototypeOf()</code>：检测一个对象是否是另一个对象的原型</li>
<li><code>obj.constructor.prototype</code>：检测非<code>Object.create()</code>创建的对象的原型<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// isPrototypeOf()方法</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj1)  <span class="comment">// true</span></span><br><span class="line">obj1.isPrototypeOf(obj2)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj2)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.constructor.prototype</span></span><br><span class="line">obj1.constructor.prototype === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// obj1是obj2的原型，以下等式应为true</span></span><br><span class="line">obj2.constructor.prototype === obj1  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 而实际上</span></span><br><span class="line">obj2.constructor.prototype === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
以上代码中<code>obj1</code>是<code>obj2</code>的原型，<code>obj2.constructor.prototype === obj1</code>应为<code>true</code>但是实际上却是<code>false</code>，因为<code>obj2</code>的<code>__proto__</code>里面并没有一个<code>constructor</code>属性，<code>obj2.constructor</code>实际上是<code>obj1</code>的<code>__proto__</code>里面的<code>constructor</code>，所以<code>obj2.constructor.prototype === Object.prototype</code>。<br><img src="https://user-gold-cdn.xitu.io/2018/2/2/161555a08b89f7c8?w=501&h=377&f=png&s=40282"><h2 id="二、constructor、-proto-与prototype之间的关系"><a href="#二、constructor、-proto-与prototype之间的关系" class="headerlink" title="二、constructor、__proto__与prototype之间的关系"></a>二、<code>constructor</code>、<code>__proto__</code>与<code>prototype</code>之间的关系</h2>在javascript中我们每创建一个对象，该对象都会获得一个<code>__proto__</code>属性（该属性是个对象），该属性指向创建该对象的<code>构造函数的原型</code>即<code>prototype</code>，同时<code>__proto__</code>对象有一个<code>constructor</code>属性指向该构造函数。这里我们需要注意的是只有函数才有<code>prototype</code>，每个对象（函数也是对象）都有<code>__proto__</code>，<code>Object</code>本身是个构造函数。举例来说：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="comment">// 也可以使用对象字面量创建，但使用Object.create()情况会不一样</span></span><br><span class="line"><span class="comment">// Object本身是个构造函数</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// true</span></span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line">obj.__proto__.constructor === <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 我们一般习惯这样写</span></span><br><span class="line">obj.constructor === <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
当我们访问<code>obj.constructor</code>的时候，<code>obj</code>本身是没有<code>constructor</code>属性的，但属性访问会沿着<code>__proto__</code>向上查找，即在<code>obj.__proto__</code>里面寻找<code>constructor</code>属性，如果找到了就返回值，如果未找到则继续向上查找直到<code>obj.__proto__.__proto__...(__proto__) === null </code>为止，没有找到则返回undefined。这样由<code>__proto__</code>构成的一条查找属性的线称为‘原型链’。<h2 id="三、进一步探讨"><a href="#三、进一步探讨" class="headerlink" title="三、进一步探讨"></a>三、进一步探讨</h2>我们知道JS是单继承的，<code>Object.prototype</code>是原型链的顶端，所有对象从它继承了包括<code>toString</code>等等方法和属性。</li>
</ol>
<p>前面我们说到<code>Object</code>本身是构造函数，那么它继承了<code>Function.prototype</code>;<code>Function</code>也是对象，继承了<code>Object.prototype</code>。这里就有一个鸡和蛋的问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>以下是ES规范的解释：</p>
<blockquote>
<p><code>Function</code>本身就是函数，<code>Function.__proto__</code>是标准的内置对象<code>Function.prototype</code>。<br><code>Function.prototype.__proto__</code>是标准的内置对象<code>Object.prototype</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;sillywa&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/2/161558d58482d19c?w=826&h=253&f=png&s=20926"></p>
<p>总的来说：先有<code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code>继承<code>Object.prototype</code>而产生，最后，<code>Function</code>和<code>Object</code>和其它构造函数继承<code>Function.prototype</code>而产生。</p>
<h2 id="四、Object-create"><a href="#四、Object-create" class="headerlink" title="四、Object.create()"></a>四、<code>Object.create()</code></h2><p>我们知道通过<code>Object.create()</code>创建的对象实际上等于将该对象的<code>__proto__</code>指向<code>Object.create()</code>里面的参数对象，那么当涉及到原型时它是怎么工作的呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a)</span><br><span class="line"></span><br><span class="line">b.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// false</span></span><br><span class="line">b.__proto__ === a  <span class="comment">// true</span></span><br><span class="line">b.__proto__.constructor === <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">b.__proto__.hasOwnProperty(<span class="string">&#x27;constructor&#x27;</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>下面我们来具体看一看当<code>var b = Object.create(a)</code>到底发生了什么，以下实在浏览器中的结果：<br><img src="https://user-gold-cdn.xitu.io/2018/2/2/161555a08b89f7c8?w=501&h=377&f=png&s=40282"><br>我们可以看到当<code>var b = Object.create(a)</code>实际上是把<code>b</code>的<code>__proto__</code>指向了<code>a</code>。当访问<code>b.constructor</code>时，实际上访问的是<code>b.__proto__.__proto__.constructor</code>。</p>
<h2 id="五、实例与总结"><a href="#五、实例与总结" class="headerlink" title="五、实例与总结"></a>五、实例与总结</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;sillywa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.__proto__ === Person.prototype</span><br><span class="line">person1.__proto__.__proto__ === Person.prototype.__proto__</span><br><span class="line">person1.__proto__.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line">Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype </span><br><span class="line">person1.__proto__.__proto__.__proto__ === <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">Person.__proto__ === <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>
<p>以上均返回<code>true</code>，前五个等式和第一部分内容相关，最后一个等式为第二部分内容，<strong>需要注意的是IE浏览器里面并没有实现<code>__proto__</code>，为了便于理解我们可以这样解释，但是最好不要在实际中使用</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/2/161557f207fff784?w=823&h=242&f=png&s=21059"></p>
]]></content>
      <categories>
        <category>JavaScript 基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识JS对象（二）-- 对象及其属性</title>
    <url>/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>前面介绍了如何创建对象，对象的存储器属性以及对象的特性（属性描述符），今天我们接着前面的来介绍对象及其属性。</p>
<a id="more"></a>

<h2 id="一、删除属性"><a href="#一、删除属性" class="headerlink" title="一、删除属性"></a>一、删除属性</h2><p><code>delete</code> 运算符可以用来删除对象的属性，它的操作数应当是个属性访问表达式（如果是个非法的操作数，早严格模式下会报错）。但它只能删除对象的自有属性，不能删除在原型对象上的属性，如果需要删除原型对象上的属性，需要在原型里面进行操作。</p>
<p>当<code>delete</code> 删除属性成功或者没有任何副作用时，返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name  <span class="comment">// 删除name属性，返回true</span></span><br><span class="line">person1.name  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图删除原型上的属性</span></span><br><span class="line"><span class="keyword">delete</span> person1.sex  <span class="comment">// 无法删除，没有任何副作用，返回true</span></span><br><span class="line">person1.sex  <span class="comment">// &#x27;boy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除sex属性</span></span><br><span class="line"><span class="keyword">delete</span> Person.prototype.sex</span><br><span class="line">person1.sex  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="comment">// 或者可以这样，和上面的效果一样</span></span><br><span class="line"><span class="keyword">delete</span> person1.__proto__.sex</span><br></pre></td></tr></table></figure>
<p><code>delete</code> 不能删除那些<code>configurable</code>为<code>false</code>的属性，也不能删除通过变量声明或者函数声明创建的全局对象的属性。在严格模式下删除不可配置的属性会报错，非严格模式下返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype  <span class="comment">// 不能删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">this</span>.x  <span class="comment">// 不能删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">this</span>.f  <span class="comment">// 不能删除</span></span><br></pre></td></tr></table></figure>
<h2 id="二、检测属性"><a href="#二、检测属性" class="headerlink" title="二、检测属性"></a>二、检测属性</h2><p>有三种方法可以检测对象中是否含有某个属性：</p>
<ol>
<li><code>in 运算符</code>：  检测属性在自身及原型链上是否存在</li>
<li><code>hasOwnProperty()</code>：  检测属性是否为自有属性（不包括继承属性）</li>
<li><code>propertyIsEnumerable()</code>：  检测属性为自有属性切可枚举<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// in 运算符</span></span><br><span class="line"><span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> person1  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;sex&#x27;</span> <span class="keyword">in</span> person1  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty()</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">&#x27;sex&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// propertyIsEnumerable</span></span><br><span class="line">person1.propertyIsEnumerable(<span class="string">&#x27;age&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">person1.propertyIsEnumerable(<span class="string">&#x27;sex&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 定义一个不可枚举的属性college</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person1,<span class="string">&#x27;college&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="string">&#x27;wuhan&#x27;</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">person1.propertyIsEnumerable(<span class="string">&#x27;college&#x27;</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
判断一个对象中是否存在某个属性不能用<code>!=undefined</code>，因为即使这个属性不存在也会返回<code>undefined</code>。<h2 id="三、枚举属性"><a href="#三、枚举属性" class="headerlink" title="三、枚举属性"></a>三、枚举属性</h2>枚举属性即遍历对象中所有的属性包括可枚举属性与不可枚举属性。</li>
</ol>
<p>遍历可枚举属性有以下两种方法：</p>
<ol>
<li><code>for in循环</code>：  遍历对象中所有可枚举的属性，包括<strong>自有属性和继承属性</strong>。可以配合<code>hasOwnProperty()</code>方法得到自有属性。</li>
<li><code>Object.keys()</code>：  遍历对象中所有可枚举的<strong>自有属性</strong>，返回由这些属性组成的数组。</li>
</ol>
<p>遍历不可枚举的属性有一种方法：</p>
<ol>
<li><code>Object.getOwnPropertyNames()</code> 它和<code>Object.keys()</code>类似，返回对象所有自有属性的名称，<strong>包括不可枚举的属性</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person1,<span class="string">&#x27;college&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="string">&#x27;wuhan&#x27;</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// person1有三个属性，一个可枚举自有属性name，一个可枚举继承属性sex，一个不可枚举自有属性college</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可枚举的自有属性和继承属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop)   <span class="comment">// &#x27;name&#x27;,&#x27;sex&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 仅仅返回可枚举的自有属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (person1.hasOwnProperty(prop)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(prop)   <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可枚举的自有属性组成的数组</span></span><br><span class="line"><span class="built_in">Object</span>.keys(person1)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所有自有属性组成的数组，包括不可枚举的属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person1)  <span class="comment">// [&#x27;name&#x27;,&#x27;college&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>至此对象及其属性介绍完毕，下一章将讨论对象的<a href="/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/" title="原型及原型链">原型及原型链</a></p>
]]></content>
      <categories>
        <category>JavaScript 基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识JS对象（一）-- 对象及其属性</title>
    <url>/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>本文探讨了Javascript对象的创建,以及对象的属性及其特性,同时还说明了属性的设置与屏蔽.</p>
<a id="more"></a>

<h2 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h2><p>javascript中有三种方法可以创建一个对象：</p>
<ol>
<li><p>对象字面量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>new 构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.create()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>需要注意的是通过<code>Object.create()</code>创建的对象实际上等于将该对象的<code>__proto__</code>指向<code>Object.create()</code>里面的参数对象，而<code>obj</code>本身是个空对象。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 等价于 obj.__proto__ = &#123; name: &#x27;jack&#x27;, age: 12 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__)  <span class="comment">// &#123; name: &#x27;jack&#x27;, age: 12 &#125;</span></span><br><span class="line">obj.toString()   <span class="comment">// &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果往<code>Object.create()</code>里面传入的是<code>null</code>，则创建的对象不继承<code>Object</code>的任何方法及属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__)  <span class="comment">// undefined</span></span><br><span class="line">obj.toString()  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>如果想创建一个空对象，需要传入<code>Object.prototype</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// 和 &#123;&#125; 、new Object()一样</span></span><br></pre></td></tr></table></figure>
<h2 id="二、对象的属性"><a href="#二、对象的属性" class="headerlink" title="二、对象的属性"></a>二、对象的属性</h2><p>我们知道，对象的属性是由名字、值和一组特性组成（属性的特性待会介绍）。在ES5中属性值可以用一个或两个方法代替，这两个方法就是<code>getter</code>和<code>setter</code>。由<code>getter</code>和<code>setter</code>定义的属性称为“存储器属性”，它不同于数据类型的属性，数据属性只有一个简单的值。我们重点讲解存储器属性。</p>
<p>当我们查询存储器属性时会调用<code>getter</code>方法（无参数）。这个方法返回值就是属性存取表达式返回的值。</p>
<p>当我们设置存储器属性时会调用<code>setter</code>方法（有参数）。这个方法修改存储器属性的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    num: <span class="number">12</span>,</span><br><span class="line">    age: <span class="number">13</span>,</span><br><span class="line">    get num1 () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.num</span><br><span class="line">    &#125;,</span><br><span class="line">    set num1 (value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = value</span><br><span class="line">    &#125;,</span><br><span class="line">    get age1 () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.num1   <span class="comment">// 12</span></span><br><span class="line">obj.num1 = <span class="number">120</span></span><br><span class="line">obj.num1  <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line">obj.age1  <span class="comment">// 13</span></span><br><span class="line">obj.age1 = <span class="number">130</span></span><br><span class="line">obj.age1  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>存储器属性定义为一个或者两个和属性同名的函数，这个函数定义没有使用<code>function</code>关键字而是使用<code>get</code>和<code>set</code>。</p>
<p>可以看出如果该属性只有<code>getter</code>方法则只能读取该属性不能设置该属性，同样如果只有<code>setter</code>方法就只能设置该属性，不能读取该属性，只有当两者都有时才能正常读取和设置属性。</p>
<h2 id="三、对象属性的特性"><a href="#三、对象属性的特性" class="headerlink" title="三、对象属性的特性"></a>三、对象属性的特性</h2><p>每个对象的数据属性都有四个特性（也可以说是属性描述符），分别为：</p>
<ol>
<li><code>value</code>  属性的值</li>
<li><code>writable</code>  可写性，如果为<code>false</code>该值将不能被修改</li>
<li><code>enumerable</code>  可枚举性，如果为<code>false</code>将不能被枚举</li>
<li><code>configurable</code>  可配置性，如果为<code>false</code>将不能被配置，即不能被<code>delete</code>操作符删除，不能更改这四个特性，一旦设为<code>false</code>则无法再设为<code>true</code>，也就是一个不可逆过程</li>
</ol>
<p>前面我们讲过存储器属性，每隔对象的存储器属性同样也有四个特性，分别为：</p>
<ol>
<li><code>get</code></li>
<li><code>set</code></li>
<li><code>enumerable</code></li>
<li><code>configurable</code></li>
</ol>
<p>如果想要获得一个对象某个属性的这四个特性，可以调用 Object.getOwnPropertyDescriptor() 方法，该方法接受两个参数，第一个为对象，第二个为对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    get age1 () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age1</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">age1</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.age1 = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取数值属性的特性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &quot;jack&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取存储器属性的特性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;age1&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;enumerable: true, configurable: true, get: ƒ, set: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图获取不存在的属性，返回undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;sex&#x27;</span>)  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图获取原型上的属性，返回undefined </span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;toString&#x27;</span>)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看出，<code>Object.getOwnPropertyDescriptor()</code> 只能得到自有属性的描述符，要想获得继承属性的特性，我们可以把该对象的原型传进去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line">Person.prototype.age = <span class="number">13</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person1.__proto__, <span class="string">&#x27;sex&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &quot;boy&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上可以看出，我们通过对象字面量和<code>new</code>运算符创建的对象的属性它们的<code>writable</code>,<code>enumerable</code>,<code>configurable</code>都有<code>true</code>，默认都是可写、可枚举、可配置。如果要修改属性的特性可以调用<code>Object.defineProperty()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将name属性设为不可枚举并将其值设为jack</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &quot;jack&quot;, writable: true, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增age属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">12</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: 12, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将name变为存储器属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;set: undefined, enumerable: false, configurable: true, get: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">obj.age = <span class="number">78</span></span><br><span class="line">obj.age  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是通过<code>Object.defineProperty()</code> 创建的属性其<code>writable</code>, <code>enumerable</code>, <code>configurable</code> 都为<code>false</code>。尝试修改不写的属性不会报错，但也不会修改，只有在严格模式下才会报错。</p>
<p>如果需要同时修改和创建多个属性，可以使用<code>Object.defineProperties()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperties(&#123;&#125;,&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">&#x27;sillywa&#x27;</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span> + <span class="built_in">this</span>.name</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="四、属性的设置和屏蔽"><a href="#四、属性的设置和屏蔽" class="headerlink" title="四、属性的设置和屏蔽"></a>四、属性的设置和屏蔽</h2><p>我们知道当我们书写以下代码时</p>
<p><code>obj.foo = &#39;bar&#39;</code></p>
<p>如果<code>obj</code>存在一个名为<code>foo</code>的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p>
<p>如果<code>foo</code>不是直接存在于obj中，<code>[[prototype]]</code>链就会被遍历，如果原型链上找不到<code>foo</code>，<code>foo</code>就直接被添加到<code>obj</code>上。</p>
<p>然而，如果原型链上找到了<code>foo</code>属性，情况就有些不一样了。</p>
<p>如果属性<code>foo</code>既出现在<code>obj</code>中也在其原型链中，那么<code>obj</code>中包含的<code>foo</code>属性就会屏蔽原型链里面的<code>foo</code>属性，这就是属性屏蔽，原理就是属性的查找规则。</p>
<p>下面我们看一下如果<code>foo</code>不直接存在于<code>obj</code>中，而是在其原型链中时，<code>obj.foo = &#39;bar&#39;</code>会出现的三种情况：</p>
<ol>
<li>如果原型链中存在名为<code>foo</code>的普通数据访问属性并且其<code>writable</code>为<code>true</code>，那么就会直接在<code>obj</code>中添加<code>foo</code>属性，它是属性屏蔽。</li>
<li>如果原型链中存在<code>foo</code>，但其<code>writabla</code>为<code>false</code>，那么无法修改已有属性或者在<code>obj</code>中创建屏蔽属性。如果运行在严格模式下，会抛出一个错误。否则这条赋值语句会被忽略，不会发生属性屏蔽。</li>
<li>如果原型链上存在<code>foo</code>并且它是一个<code>setter</code>，那就一定会调用这个<code>setter</code>。<code>foo</code>不会被添加到<code>obj</code>中，也不会重新定义这个<code>setter</code>。</li>
</ol>
<p>大多数人认为，如果向原型链中已存在的属性赋值，就一定会发生属性屏蔽，但以上三种情况只有一种是如此。</p>
<p>如果希望在任何情况下都屏蔽<code>foo</code>，那就不能使用<code>=</code>操作符来赋值，而是使用<code>Object.defineProperty()</code>来向<code>obj</code>中添加<code>foo</code>。</p>
<p>情况一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Person.prototype.foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line">obj.foo = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">obj.foo   <span class="comment">// &#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>
<p>情况二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">&#x27;foo&#x27;</span>,&#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line">obj.foo = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">obj.foo  <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>情况三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: &#x27;foo&#x27;,</span><br><span class="line">    set foo (value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = value</span><br><span class="line">    &#125;,</span><br><span class="line">    get foo () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line">obj.foo = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">obj.foo  <span class="comment">// &#x27;bar&#x27;</span></span><br><span class="line"><span class="comment">// obj中并没有foo这个属性，只是调用了setter</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>有些情况下会隐式产生屏蔽，一定要注意，思考一下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">obj.a  <span class="comment">// 2</span></span><br><span class="line">myObj.a  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">myObj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">myObj.a ++  <span class="comment">// 隐式屏蔽</span></span><br><span class="line"></span><br><span class="line">obj.a  <span class="comment">// 2</span></span><br><span class="line">myObj.a  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">myObj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>尽管<code>myObj.a ++ </code>看起来是查找并增加<code>obj.a</code>的属性，但是别忘了<code>++</code>操作符相当于<code>myObj.a = myObj.a + 1</code>；因此<code>++</code>操作首先会通过原型链查找到<code>obj.a</code>，并读取其值为2，然后加1赋值给<code>myObj.a</code>。</p>
]]></content>
      <categories>
        <category>JavaScript 基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT 高级配置</title>
    <url>/2018/12/05/topnext/</url>
    <content><![CDATA[<p>前一篇文章介绍了NexT的基本配置，其主要涉及两个配置文件第一个是主目录下的<code>_config.yml</code>，另一个是我们的主题配置文件<code>thems/next/_config.yml</code>，接下来我们继续深入。</p>
<a id="more"></a>

<h1 id="添加社交网址"><a href="#添加社交网址" class="headerlink" title="添加社交网址"></a>添加社交网址</h1><p>在<code>thems/next/_config.yml</code>查找 <code>social</code>，找到如下代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Social Links.</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span></span><br><span class="line"><span class="symbol">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || github</span></span><br><span class="line">  E-<span class="symbol">Mail:</span> <span class="symbol">mailto:</span>yourname@gmail.com <span class="params">||</span> envelope</span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br></pre></td></tr></table></figure>
<p>去掉 <code>social</code> 的注释并将你需要展示的信息网址注释去掉，可以修改名称和网址。</p>
<p>效果如图：</p>


<h1 id="页面底部添加访问量"><a href="#页面底部添加访问量" class="headerlink" title="页面底部添加访问量"></a>页面底部添加访问量</h1><p>在<code>thems/next/_config.yml</code>查找 <code>busuanzi</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">busuanzi_count:</span></span><br><span class="line">  <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">total_visitors_icon:</span> user</span><br><span class="line">  <span class="symbol">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">total_views_icon:</span> eye</span><br><span class="line">  <span class="symbol">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">post_views_icon:</span> eye</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>

<p>本地查看访问量可能有误，但是放到线上就没问题了。</p>
<h1 id="为文章添加评论与阅读次数"><a href="#为文章添加评论与阅读次数" class="headerlink" title="为文章添加评论与阅读次数"></a>为文章添加评论与阅读次数</h1><p>在<code>leancloud</code>上面注册帐号，新建一个应用，找到应用对应的<code>appid</code>和<code>appkey</code>，然后在<code>thems/next/_config.yml</code>查找 <code>valine</code>，将填入<code>appid</code>和<code>appkey</code>以下代码中，相应字段设为<code>true</code>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">valine:</span></span><br><span class="line">  <span class="symbol">enable:</span> <span class="literal">true</span> <span class="comment"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span></span><br><span class="line">  <span class="symbol">appid:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="symbol">appid:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="symbol">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="symbol">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="symbol">placeholder:</span> Just go go <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="symbol">avatar:</span> mm <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="symbol">guest_info:</span> nick,mail,link <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="symbol">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line">  <span class="symbol">visitor:</span> <span class="literal">true</span> <span class="comment"># leancloud-counter-security is not supported for now. </span></span><br></pre></td></tr></table></figure>

<h1 id="为页面添加搜索功能"><a href="#为页面添加搜索功能" class="headerlink" title="为页面添加搜索功能"></a>为页面添加搜索功能</h1><p>在<code>thems/next/_config.yml</code>查找 <code>local_search</code>，并将<code>enable</code>设为<code>true</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">local_search:</span></span><br><span class="line">  <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="symbol">trigger:</span> auto</span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="symbol">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># unescape html strings to the readable one</span></span><br><span class="line">  <span class="symbol">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后访问<a href="https://github.com/theme-next/hexo-generator-searchdb">注释提供的网址</a>，按它的步骤操作。</p>
<h1 id="文章分享链接"><a href="#文章分享链接" class="headerlink" title="文章分享链接"></a>文章分享链接</h1><p>在<code>thems/next/_config.yml</code>查找 <code>needmoreshare</code>，并将<code>enable</code>设为<code>true</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">needmoreshare2:</span></span><br><span class="line">  <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">postbottom:</span></span><br><span class="line">    <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="symbol">options:</span></span><br><span class="line">      <span class="symbol">iconStyle:</span> box</span><br><span class="line">      <span class="symbol">boxForm:</span> horizontal</span><br><span class="line">      <span class="symbol">position:</span> bottomCenter</span><br><span class="line">      <span class="symbol">networks:</span> Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line">  <span class="symbol">float:</span></span><br><span class="line">    <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="symbol">options:</span></span><br><span class="line">      <span class="symbol">iconStyle:</span> box</span><br><span class="line">      <span class="symbol">boxForm:</span> horizontal</span><br><span class="line">      <span class="symbol">position:</span> middleRight</span><br><span class="line">      <span class="symbol">networks:</span> Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后访问<a href="https://github.com/theme-next/theme-next-needmoreshare2">注释提供的网址</a>，按它的步骤操作。</p>
<h1 id="博客页脚记时"><a href="#博客页脚记时" class="headerlink" title="博客页脚记时"></a>博客页脚记时</h1><p>打开 <code>\themes\next\layout\_partials\footer.swig</code>，在最下面添加如下代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date();</span><br><span class="line">    function createtime() &#123;</span><br><span class="line">        var grt= new Date(<span class="string">&quot;12/03/2018 00:00:00&quot;</span>);<span class="regexp">//</span>此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+<span class="number">250</span>);</span><br><span class="line">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = Math.floor(days);</span><br><span class="line">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = Math.floor(hours);</span><br><span class="line">        <span class="keyword">if</span>(String(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum);</span><br><span class="line">        mnum = Math.floor(minutes); <span class="keyword">if</span>(String(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum);</span><br><span class="line">        snum = Math.round(seconds); <span class="keyword">if</span>(String(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125;</span><br><span class="line">        document.getElementById(<span class="string">&quot;timeDate&quot;</span>).innerHTML = <span class="string">&quot;Running for &quot;</span>+dnum+<span class="string">&quot; Days &quot;</span>;</span><br><span class="line">        document.getElementById(<span class="string">&quot;times&quot;</span>).innerHTML = hnum + <span class="string">&quot; Hours &quot;</span> + mnum + <span class="string">&quot; m &quot;</span> + snum + <span class="string">&quot; s&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setInterval(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>并将以下代码放在这个文件你喜欢的位置，然后查看效果。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span id=<span class="string">&quot;timeDate&quot;</span>&gt;&lt;<span class="regexp">/span&gt;&lt;span id=&quot;times&quot;&gt;&lt;/span</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>NexT</code>高级配置就介绍这么多，至此，我们已搭建出一个比较完整的博客，然后接下来就可以快乐的写博客啦！</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 及 NexT 基本配置与使用</title>
    <url>/2018/12/05/usehexo/</url>
    <content><![CDATA[<p>前一篇文章介绍了如何搭建博客，但是没有介绍如何使用和个性化配置博客。因此这篇文章主要来介绍<code>Hexo</code>的主题及其配置以及如何来写自己的博客。</p>
<a id="more"></a>

<h1 id="主题下载与应用"><a href="#主题下载与应用" class="headerlink" title="主题下载与应用"></a>主题下载与应用</h1><p><code>Hexo</code>提供各种各样的主题，我们可以进入<a href="https://hexo.io/themes/">官网</a>去选择自己喜欢的主题，然后在<code>GitHub</code>上有其具体的介绍。</p>
<p>接下来我们以<a href="https://github.com/theme-next/hexo-theme-next">NexT</a>主题为例进行介绍。</p>
<p>截至目前为止，<code>NexT</code>主题已经从v5.1.x更新至<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">v6.6.0</a>，仓库也从原来的老仓库迁移到<a href="https://github.com/theme-next/hexo-theme-next">这里</a>。因此<code>NexT</code>主题的很多配置都和以前不一样了，我当时在网上看的时候全是老版本的配置方法，花费了不少时间。最后发现其实可以自己看着<code>themes</code>下的<code>_config.yml</code>进行配置，很多插件都在<a href="https://github.com/theme-next">theme-next</a>这个仓库有。</p>
<h2 id="下载-NexT"><a href="#下载-NexT" class="headerlink" title="下载 NexT"></a>下载 NexT</h2><p>切换到主目录，然后克隆整个仓库到<code>themes/next</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>之后我们会发现 <code>themes</code>下多了个<code>next</code>文件夹，即我们的主题文件夹。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>整个 <code>Hexo</code> 博客有两个主要的配置文件，第一个是主目录下的<code>_config.yml</code>，另一个是我们的主题配置文件，是<code>thems/next/_config.yml</code>。</p>
<p>现在我们开始将我们下载的主题应用到我们的博客中，我们只需修改主目录下的<code>_config.yml</code>，如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">theme:</span> <span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>然后<code>hexo s</code>启动博客即可。<br><strong>需要注意的是：每当我们修改了主目录下的<code>_config.yml</code>，只有重启博客服务才能生效；而修改<code>thems/next/_config.yml</code>是不需要重启博客服务的。</strong></p>
<p>同样我们可以在主目录下的<code>_config.yml</code>进行其他设置，我们可以看到里面有网站基本设置，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hexo           </span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">author: John Doe</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>网站标题</td>
</tr>
<tr>
<td>subtitle</td>
<td>网站副标题</td>
</tr>
<tr>
<td>description</td>
<td>网站描述</td>
</tr>
<tr>
<td>author</td>
<td>作者名字</td>
</tr>
<tr>
<td>language</td>
<td>网站语言，NexT v6.0.3以后中文设为 zh-CN</td>
</tr>
</tbody></table>
<p>具体全部配置参考<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a>。</p>
<p>我们暂时不需要全部理解其意思，只要把网站的基本描述改为你自己的就好。</p>
<h1 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h1><h2 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h2><p><code>Scheme</code> 的切换通过更改主题配置文件，打开<code>thems/next/_config.yml</code>，搜索 scheme 关键字。 你会看到有三行 <code>scheme</code> 的配置，将你需用启用的 <code>scheme</code> 前面注释 <code>#</code> 去除即可。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="symbol">scheme:</span> Muse</span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。<br>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白<br>Mist - Muse 的紧凑版本，整洁有序的单栏外观<br>Pisces - 双栏 Scheme，小家碧玉似的清新</p>
</blockquote>
<p>选择对应的外观，刷新浏览器即可预览。</p>
<h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><p>打开<code>thems/next/_config.yml</code>，找到如下代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line">  <span class="symbol">home:</span> / <span class="params">||</span> home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="symbol">archives:</span> /archives/ <span class="params">||</span> archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<p>这里是进行菜单配置，去掉哪个注释，就会多一个相应的菜单选项。</p>
<p>当需要<code>about</code>、<code>tags</code>、<code>categories</code> 需要手动创建这个页面，如果不创建点击则不会出现相应页面。</p>
<p>使用如下命令创建这些文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>之后<code>source</code>文件夹下就会出现三个这样的文件夹。</p>
<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>打开<code>thems/next/_config.yml</code>，找到如下代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">avatar:</span></span><br><span class="line">  <span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># You can also use other linking images.</span></span><br><span class="line">  <span class="symbol">url:</span> <span class="comment">#/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line">  <span class="symbol">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span></span><br><span class="line">  <span class="symbol">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line">  <span class="symbol">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>修改字段 <code>avatar</code>， 值设置成头像的链接地址，参考<a href="http://theme-next.iissnan.com/getting-started.html#avatar-setting">这个链接</a>。</p>
<p>以上主题设置可以参考<a href="http://theme-next.iissnan.com/">Next文档</a>。</p>
<h2 id="tags-和-categories-设置"><a href="#tags-和-categories-设置" class="headerlink" title="tags 和 categories 设置"></a>tags 和 categories 设置</h2><p>当菜单中有了 <code>tags</code> 和 <code>categories</code> 时，我们需要在 <code>Front-matter</code> 中添加 <code>type</code> 属性。所谓 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a> 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量。</p>
<p><code>tags/index.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-12-05 10:00:29</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>categories/index.md</code> 同理。</p>
<p>只有这样当我们新建一篇博客时，指定的<code>tags</code>和<code>categories</code>才会同步，<code>hexo</code>才会识别出来你的 <code>tags</code> 和 <code>categories</code>。所以接下来我们看如何新建一篇博客。</p>
<h1 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h1><p>新建博客很简单，使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章题目&quot;</span><br></pre></td></tr></table></figure>
<p>这样就会在<code>source</code>目录下自动创建一个名为 <code>文章题目.md</code> 的文件，我们只要在这个文件上写文章就行了。同样我们需要每篇文章指定一个或多个 <code>tags</code> 和 一个 <code>categories</code>。这样你的菜单中<code>tags</code> 页面 和<code>categories</code>页面就会有内容了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章题目</span><br><span class="line">date: 2018-12-05 15:42:22</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这样整个 <code>NexT</code> 基本配置就结束了，之后将会介绍一些<a href="/2018/12/05/topnext/" title="更高级的配置">更高级的配置</a>。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo and GitHub Pages 博客搭建</title>
    <url>/2018/12/05/hexo/</url>
    <content><![CDATA[<p>最近没事想着自己来搭建一个博客，在网上看了一些资料发现，<code>Hexo + GitHub</code> 是目前比较常用的博客搭建系统，因此就照着网上的教程一步一步，历经一天左右的时间搭建了这个个人博客。</p>
<p>想着用博客来记录自己的学习笔记，希望自己能把写博客这个习惯坚持下来。</p>
<p>ok，接下来就来看看我是怎么一步步搭建这个博客的。</p>
<a id="more"></a>

<h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><h2 id="了解-Hexo"><a href="#了解-Hexo" class="headerlink" title="了解 Hexo"></a>了解 Hexo</h2><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>在安装<code>Hexo</code>之前我们需要知道电脑里有没有下面的应用程序，如果没有，点击安装，具体安装方法就不做介绍了；如果有则直接看下一步。</p>
<ul>
<li><a href="https://nodejs.org/en/">Node.js</a></li>
<li><a href="https://git-scm.com/">Git</a></li>
</ul>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>以上两个程序安装成功之后，接下来使用 <code>npm</code> 安装 <code>Hexo</code>，如果 <code>npm</code> 安装较慢，可考虑使用淘宝镜像 <a href="https://npm.taobao.org/">cnpm</a>，安装完 <code>cnpm</code> 之后可将下面所有用到 <code>npm</code> 的地方换为<code>cnpm</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>输入以下命令检查 <code>Hexo</code> 是否安装成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo --version</span><br></pre></td></tr></table></figure>
<p>如果有版本信息则安装 <code>Hexo</code> 成功。</p>
<h1 id="开始搭建博客"><a href="#开始搭建博客" class="headerlink" title="开始搭建博客"></a>开始搭建博客</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>Hexo</code>安装完成之后，用以下命令新建一个文件夹并初始化 <code>Hexo</code> 所需文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder_name&gt;</span><br><span class="line">cd folder_name</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p><code>hexo init</code>过程可能会较慢，请耐心等待。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>以上过程结束之后，用如下命令在本地运行我们的博客。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><code>hexo server</code> 可以简写为 <code>hexo s</code>。</p>
<p>接着我们用浏览器打开 <code>localhost:4000</code> 即可看到我们搭建的博客。</p>
<h1 id="将博客放入GitHub"><a href="#将博客放入GitHub" class="headerlink" title="将博客放入GitHub"></a>将博客放入GitHub</h1><p>博客搭建好之后，我们在 <code>GitHub</code> 新建一个仓库，可以命名为 <code>your_blog_name.github.io</code> ，以后就可以直接通过<code>your_blog_name.github.io</code>访问你的博客了。</p>
<p><strong>请务必将仓库名设为xxx.github.io xxx为你自定义，否则之后会出现很多问题</strong></p>
<p>新建好之后，在你的博客目录下，即前面提到的 <code>folder_name</code>下，使用如下命令关联<code>GitHub</code>仓库。</p>
<p>如果是第一次使用<code>GitHub</code>或者是没有配置 <code>ssh</code> 可能会要求输入帐号密码 ，最好的解决办法是<a href="https://segmentfault.com/a/1190000002645623">配置ssh</a>，然后再进行以下操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure>

<p>接着打开主目录（folder_name）下的 <code>_config.yml</code>配置文件，找到 <code>deploy</code>，进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: &lt;远程仓库地址&gt;</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<p>然后安装以下插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后执行以下命令生成静态文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>可简写为 <code>hexo g</code></p>
<p>最后将文件上传到<code>GitHub</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>可简写为 <code>hexo d</code></p>
<h1 id="开启Pages服务"><a href="#开启Pages服务" class="headerlink" title="开启Pages服务"></a>开启Pages服务</h1><p><code>GitHub</code>上找到我们的仓库，点击右边的<code>Settings</code>：</p>

<p>下滑找到 <code>GitHub Pages</code> ，点击 <code>master branch</code>，点击 <code>save</code>，即可开启<code>Pages</code>服务。</p>


<p>点击<code>GitHub Pages</code>旁边给出的链接即可访问你的博客了。</p>
<p>这样你的博客基本上就搭建成功了，下一篇我们介绍<a href="/2018/12/05/usehexo/" title="如何配置和使用Hexo">如何配置和使用Hexo</a>。</p>
<p>大家也可以参考<a href="https://hexo.io/zh-cn/">Hexo官网</a>。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
