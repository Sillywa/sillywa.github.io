<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vi基本操作</title>
    <url>/2019/03/06/vi%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<p>vi 是 Linux 常用的编辑器，本文记录了 vi 的基本操作。</p>
<h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><ol>
<li><p>命令模式<br>用 vi 打开一个文件即进入命令模式</p>
</li>
<li><p>输入模式<br>a i o 进入输入模式</p>
</li>
</ol>
<ul>
<li>a 光标后输入</li>
<li>i 光标前输入</li>
<li>o 光标下一行输入</li>
<li>A 光标所在行的行尾输入</li>
<li>O 光标所在行的上一行新建一行</li>
<li>esc退回到命令模式</li>
</ul>
<ol start="3">
<li>末行模式</li>
</ol>
<ul>
<li>: 进入末行模式</li>
<li>esc返回命令模式</li>
</ul>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ol>
<li><p>行内跳转<br>home 或者 $ 跳转行首<br>end 或者 ^ 跳转行尾</p>
</li>
<li><p>行间跳转<br>末行模式输入 <code>set nu</code> 显示行数</p>
<ul>
<li><p>命令模式<br><code>#gg</code>     跳转到#行，#代表数字<br><code>G</code>       跳转到行尾<br><code>gg</code>      跳转到行首</p>
</li>
<li><p>末行模式<br><code>:#</code>      跳转到#行，#代表数字</p>
</li>
</ul>
</li>
</ol>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ul>
<li>命令模式<br><code>#yy</code>       从光标所在行开始，往下复制#行</li>
<li>末行模式<br><code>:#y</code>       复制第#行<br><code>:m,ny</code>     复制从第m行到第n行</li>
</ul>
<h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><ul>
<li><code>p</code> 光标后粘贴</li>
<li><code>P</code> 光标前粘贴</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li><p>命令模式<br><code>x或者del</code>     删除光标所在字符<br><code>#dd</code>         删除从光标所在行开始，往下数#行</p>
</li>
<li><p>末行模式<br><code>:#d </code>        删除第#行<br><code>:m,nd</code>       删除从第m行到第n行</p>
</li>
</ul>
<h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p>  删除 + 粘贴     </p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>命令模式<br>  <code>/word</code> 从上往下查找word，小写n，查找下一个匹配的<br>  <code>?word</code> 从下往上查找word，大写N，查找上一个匹配的</p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>末行模式<br>  <code>:s/old/new</code>   将光标所在行，满足的第一个old替换成new<br>  <code>:s#old#new</code>  </p>
<p>  <code>:s/old/new/g</code> 光标所在行的所有old替换成new<br>  <code>:s#old#new#g</code>  </p>
<p>  <code>:m,ns/old/new</code> 第m行到第n行，每行第一个满足的old替换成new</p>
<p>  <code>:%s/old/new/g</code>   全文替换<br>  <code>:%s#old#new#g</code></p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>末行模式<br>  <code>:r /root/test.txt</code> 在光标下一行写入文件/root/test.txt</p>
<h2 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h2><ul>
<li>末行模式<br>:wq<br>:x</li>
<li>命令模式<br>ZZ</li>
</ul>
<h2 id="其他退出"><a href="#其他退出" class="headerlink" title="其他退出"></a>其他退出</h2><ul>
<li>强制退出<br>:q!</li>
<li>强制保存退出<br>:wq!</li>
<li>正常退出<br>:q</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Linux基本命令</title>
    <url>/2018/12/06/%E5%AD%A6%E4%B9%A0Linux%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h1><ul>
<li><code>pwd</code> 打印当前工作目录</li>
<li><code>cd</code> 改变目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;bin  绝对路径从根目录出发，到达目标目录</span><br><span class="line">cd .&#x2F;usr 相对路径从工作目录出发，到达目标目录</span><br><span class="line">cd .. 到达父目录</span><br><span class="line">cd(cd ~) 到达家目录，如果未root用户，pwd会打印出 &#x2F;root，其上一层为 根目录&#x2F;</span><br><span class="line">cd &#x2F; (cd -) 回到根目录</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><code>ls</code> 列出目录内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l 使用长格式显示结果</span><br><span class="line">ls -t 按修改时间排序</span><br><span class="line">ls -r 以相反的顺序显示</span><br><span class="line">ls -S 按文件大小对结果进行排序</span><br><span class="line">ls -R [文件夹] 列出文件树</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
<li><code>file</code> 确定文件类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure></li>
<li><code>less</code> 查看文件内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure></li>
<li><code>touch</code> 新建文件</li>
</ul>
<h1 id="操作文件与目录"><a href="#操作文件与目录" class="headerlink" title="操作文件与目录"></a>操作文件与目录</h1><ul>
<li><code>mkdir</code> 创建目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir dir1              创建单个目录</span><br><span class="line">mkdir dir1 dir2 dir3    创建多个目录</span><br><span class="line">mkdir -p dir&#123;1..9&#125;      创建多个目录a1到a9</span><br><span class="line">mkdir -p a&#123;1..3&#125;&#x2F;b&#123;1..3&#125;创建多个目录a1到a3，并且在每个目录下创建b1到b3</span><br></pre></td></tr></table></figure></li>
<li><code>cp</code> 复制文件或目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp file1 file2          将文件file1复制到file2中,file2内容将会被覆盖</span><br><span class="line">cp -r dir1 dir2         复制目录时一定要加 -r，如果dir2目录存在，则会复制到dir2目录下和mv是一样的道理</span><br><span class="line">cp file1 file2 dir1     将多个文件复制到一个目录下</span><br></pre></td></tr></table></figure>
<code>cp</code>命令选项</li>
</ul>
<p><code>cp</code>在覆盖已存在的文件时默认情况下是 <code>cp -i</code>，即需要用户确认，我们可以这样 <code>\cp</code> 即可无需确认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-r          递归复制目录及其内容。复制目录时需要这个选项</span><br><span class="line">-u          将文件从一个目录复制到另一个目录时，只会复制目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          复制文件时显示信息性消息</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mv</code> 重命名或移动文件和目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv item1 item2              将文件或目录item1移动或重命名为item2</span><br><span class="line">mv item1 item2 item3 dir1   将多个条目移动到dir1目录下</span><br></pre></td></tr></table></figure>
<code>mv</code>命令选项与<code>cp</code>大致相同，<code>mv</code>没有<code>-r</code>选项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-u          将文件从一个目录移动到另一个目录时，只会移动目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          移动时显示信息性消息</span><br></pre></td></tr></table></figure></li>
<li><code>rm</code> 删除文件或目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -r item1 item2 item3         删除item1,item2,item3,删除目录时需要-r</span><br><span class="line">rm *.html                       删除以.html结尾的文件</span><br></pre></td></tr></table></figure>
<code>rm</code>命令选项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-i          删除前提示用户确认</span><br><span class="line">-r          递归删除目录及其内容。删除目录时需要这个选项</span><br><span class="line">-f          忽略不存在的文件，并无需提示确认</span><br><span class="line">-v          删除时显示信息性消息</span><br></pre></td></tr></table></figure></li>
<li><code>ln</code> 创建硬链接和符号链接<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln file hard-link-name      创建file文件的硬链接</span><br><span class="line">ln -s file sym-link-name    创建file文件的符号链接，符号链接指向源文件，与源文件内容保持一致</span><br></pre></td></tr></table></figure>
<code>file</code>为相对于<code>sym-link-name</code>的文件，即为相对路径，当然也可以是绝对路径<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s ..&#x2F;file sym-link-name     file在当前目录的父目录中，即file相对于sym-link-name的位置</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;I am fine&quot;                        打印 I am fine</span><br><span class="line">echo &quot;I am fine&quot; &gt; &#x2F;root&#x2F;test.txt       将 I am fine写入&#x2F;root&#x2F;test.txt中</span><br><span class="line">echo &quot;I am fine&quot; &gt;&gt; &#x2F;root&#x2F;test.txt      将 I am fine追加到&#x2F;root&#x2F;test.txt末尾</span><br><span class="line">grep &quot;关键字&quot; test.txt                  在test.txt中查找含有关键字的行并打印</span><br><span class="line">grep -v &quot;关键字&quot; test.txt               在test.txt中查找不含有关键字的行并打印</span><br><span class="line">grep ^&quot;关键字&quot; test.txt                 在test.txt中查找以关键字开头的行并打印</span><br><span class="line">grep $&quot;关键字&quot; test.txt                 在test.txt中查找以关键字结尾的行并打印</span><br></pre></td></tr></table></figure>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l | grep &quot;关键字&quot; &gt; &#x2F;root&#x2F;test.txt  列出当前目录文件信息并交给grep过滤，最后写入&#x2F;root&#x2F;test.txt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 面向对象(三)</title>
    <url>/2019/09/16/TypeScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-3/</url>
    <content><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查，其被称为“鸭式辨型法”或“结构式子类型化”。</p>
<p>在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h3 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">my_object: &#123; name: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(my_object.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_object = &#123; age: <span class="number">22</span>, name: <span class="string">&quot;Sillywa&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">getName(my_object);</span><br></pre></td></tr></table></figure>

<p>以上代码我们规定 getName 函数具有一个参数，且该参数必须含有一个 string 类型的 name 属性。需要注意的是，我们传入的参数实际包含很多属性，但是编译器只会检查那些必须的属性是否存在，并且其类型需要匹配。</p>
<p>下面我们重写这个例子，使用接口来进行描述：必须包含一个 string 类型的 name 属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ObjectValue &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">my_object: ObjectValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(my_obj.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_object = &#123; age: <span class="number">22</span>, name: <span class="string">&quot;Sillywa&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">getName(my_object);</span><br></pre></td></tr></table></figure>

<p>我们使用 interface 关键字来定义一个接口，以上代码中 objectValue 为接口的名字，花括号里面为接口所具有的约束。</p>
<p>需要注意的是，类型检查器不会去检查属性的顺序，只要相应属性存在即可。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必须的。可选属性在应用在 “option bags” 模式时很常用，即给函数传入的参数中只有部分属性赋值了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; color: <span class="string">&quot;white&quot;</span>, area: <span class="number">100</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; color: <span class="string">&quot;black&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>只读属性只能在对象刚刚创建是为其赋值，无法修改其值。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Point = &#123; x: <span class="number">12</span>, y: <span class="number">90</span>&#125;;</span><br><span class="line"></span><br><span class="line">p1.x = <span class="number">80</span>;   <span class="comment">// error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TypeScript 具有 ReadonlyArray<T> 类型，它与 Array<T> 类似，只是把所有可变方法去掉了，因此可以保证数组被创建后再也无法被修改：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line"></span><br><span class="line">ro[<span class="number">1</span>] = <span class="number">13</span>;   <span class="comment">// error</span></span><br><span class="line">ro.push(<span class="number">0</span>);  <span class="comment">// error</span></span><br><span class="line">ro.length = <span class="number">90</span>;  <span class="comment">// error</span></span><br><span class="line">a = ro;       <span class="comment">// error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。</p>
<p><code>readonly</code> vs <code>const</code></p>
<p>判断该使用 readonly 还是 const 的方法是看要把它当作变量使用还是属性使用。作为变量使用时用 const，作属性使用时用 readonly。</p>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>TypeScript 在检查对象字面量时会特殊对待而且会经过额外的属性检查，当他们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何”目标类型“不包含的属性时，你会得到一个错误。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createSquare(&#123; e_color: <span class="string">&quot;red&quot;</span>, width: <span class="number">100</span> &#125;);   <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>绕开这些检查非常简单，最简单的方法是使用类型断言：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">createSquare(&#123; e_color: <span class="string">&quot;red&quot;</span>, width: <span class="number">100</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>

<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig 带有上面定义的类型的 color 和 width 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们要表示的是 SquareConfig 可以有任意数量的属性，并且只要他们不是 color 和 width，那么就无所谓它的类型是什么。</p>
<p>还有最后一种跳过检查的方法，它就是将这个对象赋值给另一个变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">&quot;red&quot;</span>, width: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使接口能描述函数类型，需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数的参数会逐个进行类型检查，要求对应位置上的参数类型是兼容的。如果不指定类型， TypeScript 的类型系统会推断出参数类型。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> PersonInterface &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  getAge(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> PersonInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;&#125;;</span><br><span class="line">  getAge(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接口只描述了类的共有部分，而不是公共和私有两部分。它不会帮忙检查类是否具有某些私有成员。</p>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。这样我们可以从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 面向对象(二)</title>
    <url>/2019/09/08/TypeScript%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2/</url>
    <content><![CDATA[<p>前面介绍了 TypeScript 面向对象的基本特性，现在我们接着前面继续学习 TypeScript 面向对象的其他特性，包含 readonly 修饰符、参数属性、存储器、静态属性、抽象类。</p>
<h2 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h2><p>readonly 关键字将属性设置为只读的，只读属性必须在声明时或构造函数里被初始化。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span>, <span class="keyword">readonly</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;sillywa&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">p1.getName();</span><br><span class="line">p1.getAge();</span><br><span class="line">p1.name;</span><br><span class="line">p1.age;</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&quot;hahah&quot;</span>;      <span class="comment">// 错误，name是只读属性</span></span><br><span class="line">p1.age = <span class="number">45</span>;            <span class="comment">// 错误，age是只读属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述例子中，name属性为只读，在构造函数外声明，age 属性也是只读，在构造函数里初始化，需要注意的是，在构造函数里初始化的属性不用再使用 this 关键字为其赋值。</p>
<p>除 readonly 修饰符外，其它带有修饰符的属性也可以在构造函数里初始化，这种初始化属性的方式称为 参数属性：</p>
<h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span>, <span class="keyword">private</span> age: <span class="built_in">number</span>, <span class="keyword">protected</span> sex: <span class="built_in">string</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  getInfo(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>,and I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old, I am <span class="subst">$&#123;<span class="built_in">this</span>.sex&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。</p>
<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fullNameMaxLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    get fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;fullName has a max length of &quot;</span> + fullNameMaxLength);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>._fullName = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>
<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>前面我们讨论的都是类的实例成员，即那些仅当实例被初始化的时候才会被初始化的属性。</p>
<p>我们也可以使用 static 关键字创建类的静态成员，*** 这些属性存在于类本身上面而不是类的实例上 ***，我们使用 类名.静态成员 来访问这些静态成员。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">static</span> fullName:<span class="built_in">string</span> = <span class="string">&quot;sillywa&quot;</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> age:<span class="built_in">number</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  getInfo(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`my name is <span class="subst">$&#123;Person.fullName&#125;</span>,age is <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">p1.getInfo();</span><br></pre></td></tr></table></figure>

<p>编译之后生成如下 JavaScript 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my name is &quot;</span> + Person.fullName + <span class="string">&quot;,age is &quot;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.fullName = <span class="string">&quot;sillywa&quot;</span>;    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">23</span>);</span><br><span class="line">p1.getInfo();</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它子类的父类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 </p>
<p>abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<p><strong>* 需要注意的是如果一个子类继承了一个抽象类，则该子类必须实现该抽象类中的抽象方法。 *</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)&#123; &#125;;</span><br><span class="line"></span><br><span class="line">  getName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> getAge(): <span class="built_in">number</span>;  <span class="comment">// 必须在子类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(my_name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;Sillywa&quot;</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">stu1.getAge();</span><br><span class="line">stu1.getName()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 面向对象(一)</title>
    <url>/2019/09/07/TypeScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/</url>
    <content><![CDATA[<p>TypeScript 可以采用面向对象的方式来进行编程，以下介绍一些面向对象的基本特性，包含类、继承、super关键字和访问控制修饰符。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>TypeScript 使用如下方式声明一个类：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line"></span><br><span class="line">p1.sayName();    </span><br><span class="line">p1.name;  </span><br></pre></td></tr></table></figure>

<p>我们声明了一个 Person 类，他有一个 name 属性，一个构造函数和一个 sayName 方法。</p>
<p>我们在引用任何一个类成员的时候都使用了 this 关键字，表示我们要访问的类成员。</p>
<p>接着我们用 new 关键字创建了一个 Person 类的实例对象 p1，由于其构造函数接受一个 my_name 参数，因此我们在实例化 p1 时，传递给一个参数。</p>
<p>最后 p1 就可以使用 Person 类的属性和方法。</p>
<p>以上代码通过 TypeScript 的编译会得到如下 JavaScript 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">my_name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = my_name;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my name is &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line">p1.sayName();</span><br><span class="line">p1.name;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  sayName():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  saySchool():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;school&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">stu1.saySchool();</span><br><span class="line">stu1.sayName();</span><br></pre></td></tr></table></figure>

<p>与其他语言类似，在 TypeScript 中也是使用 extends 关键字实现继承。在上述例子中，Student 类继承 Person 类，Student 为子类或派生类，Person 类为父类或基类。</p>
<p>需要注意的是子类除了不能继承父类的私有成员(方法和属性)和构造函数，其他的都可以继承。</p>
<p>TypeScript 一次只能继承一个类，不支持继承多个类，但 TypeScript 支持多重继承（A 继承 B，B 继承 C）。</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><strong>* 如果子类包含了一个构造函数，它必须调用 super()，它会执行父类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 *</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">tea_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 派生类包含了一个构造函数，它必须调用 super()</span></span><br><span class="line">    <span class="built_in">super</span>(tea_name);</span><br><span class="line">  &#125;</span><br><span class="line">  sayTeaName(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;teacher name&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.sayName());    <span class="comment">// 调用父类的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  school: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">stu_name: <span class="built_in">string</span>, my_school: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 在构造函数里访问 this 的属性之前，我们一定要调用 super()</span></span><br><span class="line">    <span class="built_in">super</span>(stu_name);</span><br><span class="line">    <span class="built_in">this</span>.school = my_school;</span><br><span class="line">  &#125;</span><br><span class="line">  saySchool():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.school;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tea1 = <span class="keyword">new</span> Teacher(<span class="string">&quot;math teacher&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;middle student&quot;</span>,<span class="string">&quot;peaking university&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1.sayTeaName();</span><br><span class="line"><span class="built_in">console</span>.log(stu1.saySchool());</span><br></pre></td></tr></table></figure>

<p>以上我们声明了三个类，其中 Teacher 类和 Student 类都继承 Person 类。由于子类包含了一个构造函数，它必须调用 super()，执行父类的构造函数。如果构造函数接受参数，需要显式传递参数给 super 方法。</p>
<p>从 Teacher 类我们可以看出，super 不仅可以调用父类的构造函数，还可以调用父类的其它共有方法。</p>
<p>从 Student 类可以看出，当子类包含自己的属性时，需要在访问子类的属性之前调用 super()。</p>
<h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>TypeScript 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。TypeScript 支持 3 种不同的访问权限。、</p>
<ul>
<li><p>public：类的所有成员如果没有访问控制符的话，默认为 public，共有，可以在任何地方被访问。</p>
</li>
<li><p>private：私有，只能被其定义所在的类访问。</p>
</li>
<li><p>protected：受保护，可以被其自身以及其子类或父类访问。</p>
</li>
</ul>
<p>前面我们写的类的成员都没有访问控制修饰符，因此默认为 public，可以在任何地方被访问。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  logName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">stu_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(stu_name);</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);    <span class="comment">// 报错，私有成员无法在其它类中被访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line">stu1.sayName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa father&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);       <span class="comment">// 报错，私有成员只能在其所属类中被访问</span></span><br><span class="line"></span><br><span class="line">p1.logName();               <span class="comment">// 正确，私有成员只能在其所属类中被访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码我们定义了一个 Person 类，其有一个私有属性 name，我们可以看到，无论我们通过何种方法，私有属性 name 只能在其所属类中被访问，其他地方都访问不了。</p>
<p>而 protected 修饰符与 private 有一点不同，protected 成员可以被其自身以及其子类或父类访问。</p>
<p>同样是以上代码，我们将 name 的修饰符换为 protected</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">my_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = my_name;</span><br><span class="line">  &#125;</span><br><span class="line">  logName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">stu_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(stu_name);</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);    <span class="comment">// 正确，受保护成员可以在其子类中被访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line">stu1.sayName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Sillywa father&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);       <span class="comment">// 报错，受保护成员只能在其所属类或其子类或父类中被访问</span></span><br><span class="line"></span><br><span class="line">p1.logName();               <span class="comment">// 正确，受保护成员可以在其所属类中被访问</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript基础</title>
    <url>/2019/09/05/TypeScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="TypeScript-介绍"><a href="#TypeScript-介绍" class="headerlink" title="TypeScript 介绍"></a>TypeScript 介绍</h2><p>TypeScript 是微软开发的自由和开源的编程语言，它是 JavaScript 的超集。TypeScript 在 JavaScript 的基础上添加了可选的静态类型和基于类的面向对象编程。</p>
<p>TypeScript 是基于 JavaScript 的，在运行时需要先编译成 JavaScript 代码，其设计目的是开发大型应用，便于多人协作。</p>
<p>与 JavaScript 的对比：</p>
<ul>
<li>TypeScript 更适合开发大型应用。</li>
<li>TypeScript 是 JavaScript 的超集，可以编译成纯 JavaScript 代码。</li>
<li>任何可以运行 JavaScript 的地方都可以运行 TypeScript 代码。</li>
<li>提供类、模块和接口等，能更好的构建和维护组件。</li>
</ul>
<p>其给 JavaScript 添加了一些语言扩展，包括：</p>
<ul>
<li>类型批注和编译时类型检查</li>
<li>类型推断</li>
<li>类型擦除</li>
<li>接口</li>
<li>枚举</li>
<li>Mixin</li>
<li>泛型编程</li>
<li>名字空间</li>
<li>元组</li>
<li>Await</li>
</ul>
<p>同时其从 ECMAScript5 移植了以下语法：</p>
<ul>
<li>类</li>
<li>模块</li>
<li>lambda 函数的箭头语法</li>
<li>可选参数及默认参数</li>
</ul>
<h2 id="TypeScript-安装"><a href="#TypeScript-安装" class="headerlink" title="TypeScript 安装"></a>TypeScript 安装</h2><p>安装 TypeScript 前，需先安装 node，然后使用 npm 进行 TypeScript 的安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>

<p>安装完成之后使用 tsc 命令查看版本号以及检查是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure>

<p>然后编写第一个 TypeScript 程序 hello.ts，以 .ts 结尾：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">&quot;hello TypeScript&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>

<p>然后将 hello.ts 文件编译成 js 文件，再运行该 js 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br><span class="line">node hello.js</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-变量类型"><a href="#TypeScript-变量类型" class="headerlink" title="TypeScript 变量类型"></a>TypeScript 变量类型</h2><p>TypeScript 包含如下数据类型：</p>
<ul>
<li>any：任意类型</li>
<li>number：数字类型</li>
<li>string：字符串类型</li>
<li>boolean：布尔类型</li>
<li>数组类型</li>
<li>元组</li>
<li>enum：枚举</li>
<li>void：用于标识方法的返回值，void 标识该方法没有返回值</li>
<li>null：表示一个空对象引用</li>
<li>undefined：初始化变量为一个未定义的值</li>
<li>never：never是其他类型（包括 null 和 undefined ）的子类型，代表从不会出现的值</li>
</ul>
<h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h3><p>任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p>
<ol>
<li>变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x:<span class="built_in">any</span> = <span class="number">1</span>;      <span class="comment">// 数字类型</span></span><br><span class="line">x = <span class="string">&quot;hello&quot;</span>;        <span class="comment">// 字符串</span></span><br><span class="line">x = <span class="literal">false</span>;          <span class="comment">// 布尔类型</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义存储各种类型数据的数组时</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayList:<span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">false</span>];</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">x.ifItExists();    <span class="comment">// 正确，ifItExists方法在运行时可能存在，但这里并不会检查</span></span><br><span class="line">x.toFixed();      <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h3 id="number-类型"><a href="#number-类型" class="headerlink" title="number 类型"></a>number 类型</h3><p>双精度 64 位浮点值。它可以用来表示整数和分数。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> num2:<span class="built_in">number</span> = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p>一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。反引号（`）来定义多行文本和内嵌表达式。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">`str1 is <span class="subst">$&#123;str1&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明存储number类型的数组</span></span><br><span class="line"><span class="keyword">let</span> arr1:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用泛型数组</span></span><br><span class="line"><span class="keyword">let</span> arr2:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x:[<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>];      <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">x1 = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>];    <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>枚举类型用于定义数值集合。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color = &#123;Red, Blue, Pink&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c:Color = Color.Red;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>用于标识方法返回值的类型，表示该方法没有返回值。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello ts&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><p>null 表示一个空对象的引用，typeof null 返回 “object”。</p>
<p>undefined 是一个为初始化值的变量，typeof undefined 返回 “undefined”。</p>
<p>null 和 undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。</p>
<p><strong>* 而在TypeScript中启用严格的空校验（–strictNullChecks）特性，就可以使得 null 和 undefined 只能被赋值给 void 或本身对应的类型。 *</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;            <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">null</span>;         <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中变量 x 只能是数字类型。如果一个类型可能出行 null 或 undefined， 可以用 | 来支持多种类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x:<span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;            <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">null</span>;         <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// right</span></span><br></pre></td></tr></table></figure>

<h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h3><p>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 数字类型</span></span><br><span class="line">y = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用crontab定时执行任务</title>
    <url>/2019/07/17/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在做一个小项目，要求能定时利用 <a href="http://doc.pm2.io/en/plus/overview/">pm2</a> 重启某个进程，即定时执行 <code>pm2 restart xxx</code>。</p>
<p>今天刚好发现 Linux 下可以使用 crontab 来定时执行一些脚本或命令，于是我就开始研究如何利用 crontab 搭配 pm2 定时重启某个进程。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>在研究的过程中，我自己在网上看了很多教程，都是良莠不齐，花了好大功夫我才解决这个问题，接下来具体看一下我的解决过程。</p>
<p>首先看一下 Linux 下如何使用 crontab：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l      &#x2F;&#x2F; 列出Linux下当前用户所有的定时任务</span><br><span class="line">crontab -e     &#x2F;&#x2F; 编辑定时任务</span><br></pre></td></tr></table></figure>

<p>当首次使用 <code>crontab -l</code> 时，会提示当前用户下没有定时任务。</p>
<p>这时我们可以使用 <code>crontab -e</code> 创建一个定时任务，创建时会要求我们选择编辑器，这里我们选择 vim.tiny。如果第一次编辑器选错了，可以运行 <code>sudo select-editor</code>命令重新选择。</p>


<p>然后我们可以写定时任务了，这里我们输入如下代码，然后保存退出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * echo 123 &gt;&gt; &#x2F;test.log</span><br></pre></td></tr></table></figure>
<p>这个命令的意思是每过一分钟将 123 追加到 /test.log 文件的末尾。</p>
<p>从第一个 <code>*</code> 到 最后一个 <code>*</code> 分别是 <strong>分、时、日、月、周</strong>。</p>
<h3 id="执行-shell-脚本"><a href="#执行-shell-脚本" class="headerlink" title="执行 shell 脚本"></a>执行 shell 脚本</h3><p>同时我们也可以编写一个 shell 脚本，让其定时执行。</p>
<p>在 /root 目录下编写 a.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 123 &gt;&gt; &#x2F;root&#x2F;a.txt</span><br></pre></td></tr></table></figure>

<p>然后利用 <code>crontab -e</code> 命令，编辑定时任务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * sh &#x2F;root&#x2F;a.sh &gt;&gt; &#x2F;root&#x2F;test.a.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>上述代码是每分钟执行 a.sh 脚本，并将执行日志写入 /test.a.log 文件。</p>
<h3 id="配合-pm2-使用"><a href="#配合-pm2-使用" class="headerlink" title="配合 pm2 使用"></a>配合 pm2 使用</h3><p>知道基本用法之后我们配合 pm2 使用，想要每分钟重启id号为0的进程（该进程必须为正在运行中的进程），自然而然就会这样写：</p>
<p>首先编写一个 shell 脚本 /root/b.sh 用于重启id号为0的进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 restart 0</span><br></pre></td></tr></table></figure>

<p>然后利用 crontab 去定时执行这个脚本，并记录其日志，<code>crontab -e</code> 输入如下代码（<strong>注意不需要添加 PATH 或者 HOME=/ 等其他东西</strong>，我当时就是看网上添加了 PATH 和 HOME=/ ，之后一直报错）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * * sh &#x2F;root&#x2F;b.sh &gt;&gt; &#x2F;root&#x2F;b.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>然而这样写并不管用，我们打开 /root/b.log 看一下它的报错。</p>
<p>提示 pm2 not found，然后我们使用 <code>which pm2</code> 查看 pm2 的路径，将 pm2 换成其路径，重新编辑 <code>/root/b.shell</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pm2 restart 0</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了利用 crontab 每分钟重启 pm2 的某个进程。当然需要根据自己的需求去设定重启时间。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识学习-5</title>
    <url>/2019/03/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-5/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 Java 中，类的继承只能是单一继承，也就是说，一个子类只能拥有一个父类。</p>
<p>Java 中用 extends 关键字来实现继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承的特点：</p>
<ol>
<li>子类拥有父类非 private 的属性和方法</li>
<li>子类可以拥有自己的属性和方法</li>
<li>子类可以用自己的方式实现父类的方法</li>
<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类</li>
</ol>
<p>Java 中用 extends 关键字来实现继承，用 super 关键字来实现对父类成员的访问，用来引用当前对象的父类，用 this 关键字指向自己的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  String name = <span class="string">&quot;father&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  String name = <span class="string">&quot;son&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.sayName();   <span class="comment">// father</span></span><br><span class="line">    <span class="keyword">this</span>.sayName();   <span class="comment">// son</span></span><br><span class="line">    sayName();        <span class="comment">// son</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>* 子类是不能继承父类的构造方法的，它只是隐式调用。如果父类的构造方法带有参数，则必须在子类的构造器中显式通过 super 关键字调用父类的构造方法并配有适当的参数。且必须在子类构造方法的第一行 *</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父类带参数构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  String name = <span class="string">&quot;son&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示调用 super</span></span><br><span class="line">    <span class="keyword">super</span>(name,age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.sayName();   <span class="comment">// father</span></span><br><span class="line">    <span class="keyword">this</span>.sayName();   <span class="comment">// son</span></span><br><span class="line">    sayName();        <span class="comment">// son</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果父类构造方法没有参数，则在子类的构造方法中不需要使用 super 关键字调用父类构造方法，系统会自动调用父类的无参构造方法。</p>
<p>Java 中所有的类都继承 Object 类，如果一个类没有使用 extends 关键字明确标识继承另一个类，那么这个类默认继承 Object 类。</p>
<p>Object 类的 toString() 方法返回对象的哈希 code 码（对象地址字符串）。</p>
<p>Object 类的 equals() 方法比较对象的引用是否指向同一块地址。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识学习-4</title>
    <url>/2019/03/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-4/</url>
    <content><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在面向对象程式设计方法中，封装是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>封装的优点：</p>
<ul>
<li>良好的封装能够减少耦合</li>
<li>类内部的结构可以自由修改</li>
<li>可以对成员变量进行更精确的控制</li>
<li>隐藏信息，实现细节</li>
</ul>
<h2 id="实现封装"><a href="#实现封装" class="headerlink" title="实现封装"></a>实现封装</h2><p>修改属性的可见性来限制对属性的访问（一般限制为private），例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。同时提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java中的成员内部类"><a href="#Java中的成员内部类" class="headerlink" title="Java中的成员内部类"></a>Java中的成员内部类</h2><p>当一个类包含另一个类时，内部类如何访问外部类中的成员属性？如何在外部调用内部类中的方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 外部类的私有属性</span></span><br><span class="line">  <span class="keyword">private</span> String name = <span class="string">&quot;Sillywa&quot;</span>;</span><br><span class="line">  <span class="comment">// 外部类的成员属性</span></span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 成员内部类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;wenwen&quot;</span>;	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的name：&quot;</span> + Person.<span class="keyword">this</span>.name);</span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的age：&quot;</span> + Person.<span class="keyword">this</span>.age);</span><br><span class="line">      System.out.println(<span class="string">&quot;内部类中的name：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建外部类的对象</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内部类的对象</span></span><br><span class="line">    Inner inn = person.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    inn.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出：</p>
<p><strong>* 内部类通过 外部类名.this.成员属性 访问外部类中的成员属性。 *</strong></p>
<p><strong>* 当需要调用内部类中的方法时，需要先实例化外部类，再实例化内部类。 *</strong></p>
<h2 id="Java中的静态内部类"><a href="#Java中的静态内部类" class="headerlink" title="Java中的静态内部类"></a>Java中的静态内部类</h2><p>静态内部类如何访问外部类的变量？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 外部类的私有静态属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Sillywa&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String city = <span class="string">&quot;wuhan&quot;</span>;</span><br><span class="line">  <span class="comment">// 外部类的成员属性</span></span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 静态内部类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;wenwen&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 静态内部类访问外部的非静态成员： `new 外部类().成员`</span></span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的age：&quot;</span> + <span class="keyword">new</span> Person().age);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 内部类没有与该成员同名的变量： 直接通过 `变量名访问`</span></span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的age：&quot;</span> + city);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 内部类存在与该成员同名的变量： 通过 `类名.静态成员访问`</span></span><br><span class="line">      System.out.println(<span class="string">&quot;外部类中的name：&quot;</span> + Person.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>* 调用时需要实现引入静态内部类 *</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> packageName.Person.Inner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">    <span class="comment">// 创建内部类的对象</span></span><br><span class="line">    Inner inn = <span class="keyword">new</span> Inner();</span><br><span class="line">    inn.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种情况：</p>
<ol>
<li>静态内部类访问外部的非静态成员： <code>new 外部类().成员</code></li>
<li>静态内部类访问外部的静态成员:<ul>
<li>内部类没有与该成员同名的变量： 直接通过 <code>变量名访问</code></li>
<li>内部类存在与该成员同名的变量： 通过 <code>类名.静态成员访问</code></li>
</ul>
</li>
</ol>
<h2 id="Java中的方法内部类"><a href="#Java中的方法内部类" class="headerlink" title="Java中的方法内部类"></a>Java中的方法内部类</h2><p><strong>* 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。 *</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 外部类中的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MInner</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> score = <span class="number">83</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score + <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建方法内部类的实例</span></span><br><span class="line">    MInner minner = <span class="keyword">new</span> MInner();</span><br><span class="line">    minner.getScore();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一定注意哦：*** 由于方法内部类不能在外部类的方法以外的地方使用(相当于“局部类”)，因此方法内部类不能使用访问控制符和static修饰符。 ***</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识学习-3</title>
    <url>/2019/03/11/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-3/</url>
    <content><![CDATA[<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类是一个模板，它描述一类对象的行为和状态。对象是类的一个实例。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类包含以下类型的变量：</p>
<p>1.<strong>* 局部变量 *</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。<br>2.<strong>* 成员变量 *</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。<br>3.<strong>* 类变量 *</strong>：类变量也声明在类中，方法体之外，但必须声明为static类型。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。*** 构造方法的名称必须与类同名，一个类可以有多个构造方法 ***。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化对象</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">12</span>,<span class="string">&quot;Sillywa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    person.sayAge()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="static-用于创建静态变量和静态方法"><a href="#static-用于创建静态变量和静态方法" class="headerlink" title="static 用于创建静态变量和静态方法"></a>static 用于创建静态变量和静态方法</h2><p>文件结构，一个 package 下面有以下三个类，一个 package 下的所有类都是相互可见的:</p>
<ul>
<li><code>Main.java</code>     程序入口</li>
<li><code>Person.java</code>   Person类</li>
<li><code>Dog.java</code>      Dog类</li>
</ul>
<p><strong>* 对各种变量而言，成员变量只在本类中可以访问，而用 static 声明的静态变量或方法在同一个 package 下的所有类都可以访问，相当于该 package 下的全局变量或方法。 *</strong></p>
<p><strong>* 因此，对于静态变量或静态方法，应使用类名访问。 *</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Person.allAge);</span><br><span class="line">    System.out.println(Dog.allAge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="comment">// 声明静态变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge = <span class="number">70</span>;</span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dog.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="comment">// 声明静态变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;dog age:&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>* 静态方法可以直接调用同类中的静态成员，但不能直接调用非静态成员。 *</strong></p>
<p><strong>* 普通方法中可以直接使用静态或非静态变量或方法。 *</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge = <span class="number">70</span>;</span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通方法中可以直接使用静态或非静态变量或方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;person name:&quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;person allAge:&quot;</span> + allAge);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayAllAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person allAge:&quot;</span> + allAge);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法可以直接调用同类中的静态成员，但不能直接调用非静态成员。</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person age:&quot;</span> + age);    <span class="comment">// 调用非静态变量，报错</span></span><br><span class="line">    sayName();                                  <span class="comment">// 调用非静态方法，报错</span></span><br><span class="line">    sayAllAge();                                <span class="comment">// 调用静态方法，成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>* 如果在静态方法中想要调用非静态成员，需先实例化对象。 *</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge = <span class="number">70</span>;</span><br><span class="line">  <span class="comment">// 构造方法与类同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> myAge, String myName)</span> </span>&#123;</span><br><span class="line">    age = myAge;</span><br><span class="line">    name = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person name:&quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;person allAge:&quot;</span> + allAge);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayAllAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person allAge:&quot;</span> + allAge);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在静态方法中想要调用非静态成员，需先实例化对象。</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">12</span>,<span class="string">&quot;Sillywa&quot;</span>);           <span class="comment">// 实例化对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;person age:&quot;</span> + person.age);    <span class="comment">// 调用非静态变量，成功</span></span><br><span class="line">    person.sayName();                                  <span class="comment">// 调用非静态方法，成功</span></span><br><span class="line">    sayAllAge();                                <span class="comment">// 调用静态方法，成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-static-静态初始化块"><a href="#使用-static-静态初始化块" class="headerlink" title="使用 static 静态初始化块"></a>使用 static 静态初始化块</h2><p><strong>* 需要特别注意：静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。 *</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">static</span> String name;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> allAge;</span><br><span class="line">  &#123;</span><br><span class="line">    age = <span class="number">10</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;为普通变量赋值&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    allAge = <span class="number">90</span>;</span><br><span class="line">    name = <span class="string">&quot;Sillywa&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;为静态变量赋值&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为静态变量赋值</span><br><span class="line">为普通变量赋值</span><br><span class="line">为普通变量赋值</span><br></pre></td></tr></table></figure>

<p><strong>* 可以看出，静态赋值最先执行，当实例化两个对象时，静态初始化只被执行一次。 *</strong></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识学习-2</title>
    <url>/2019/03/10/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1;     <span class="comment">// 建议使用</span></span><br><span class="line">String arr2[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数组长度</span></span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">arr2 = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明的同时指定数组长度</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并赋值时不能指定长度</span></span><br><span class="line"><span class="keyword">int</span>[] arr4 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="For-Each-循环"><a href="#For-Each-循环" class="headerlink" title="For-Each 循环"></a>For-Each 循环</h3><p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p>
<p>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(type element : array) &#123;</span><br><span class="line">  System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> item : arrs) &#123;</span><br><span class="line">  System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays-类提供的方法"><a href="#Arrays-类提供的方法" class="headerlink" title="Arrays 类提供的方法"></a>Arrays 类提供的方法</h3><p>首先引入 Arrays 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>

<p>1.<code>public static void sort(Object[] a)</code></p>
<p>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">63</span>,<span class="number">2</span>,<span class="number">35</span>,<span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(arrs);</span><br></pre></td></tr></table></figure>

<p>2.<code>public static void fill(int[] a, int val)</code></p>
<p>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">Arrays.fill(arrs,a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arrs) &#123;</span><br><span class="line">  System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>3.<code>public static boolean equals(long[] a, long[] a2)</code></p>
<p>如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arrs2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arrs3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> a = Arrays.equals(arrs1, arrs2);</span><br><span class="line"><span class="keyword">boolean</span> b = Arrays.equals(arrs1, arrs3);</span><br><span class="line">System.out.println(a);    <span class="comment">// true</span></span><br><span class="line">System.out.println(b);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>4.<code>public static int binarySearch(Object[] a, Object key)</code></p>
<p>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(数组长度) - 1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrs = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> index1 = Arrays.binarySearch(arrs, a);</span><br><span class="line"><span class="keyword">int</span> index2 = Arrays.binarySearch(arrs, b);</span><br><span class="line">System.out.println(index1);</span><br><span class="line">System.out.println(index2);</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h3><p>一般情况下，定义一个方法包含以下语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名) &#123;</span><br><span class="line">  ···</span><br><span class="line">  方法体</span><br><span class="line">  ···</span><br><span class="line">  return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>如果一个类中有两个或两个以上方法名相同、方法参数的个数、顺序或者类型不同的方法，则称为方法的重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载show方法，一个参数方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hello&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载show方法，两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hello&quot;</span> + name);</span><br><span class="line">  System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载show方法，两个参数顺序不同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> age,S tring name)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hello&quot;</span> + name);</span><br><span class="line">  System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>* 当重载方法被调用时，Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将会被执行。*</strong></p>
<p><strong>* 判断方法重载的依据 *</strong></p>
<ol>
<li>必须在同一个类中</li>
<li>方法名相同</li>
<li>方法参数个数、顺序或类型不同</li>
<li>与方法的修饰符或返回值没有关系</li>
</ol>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>如果一个方法的参数不确定，则可使用可变参数，一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<p>方法的可变参数的声明如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeName... parameterName</span><br></pre></td></tr></table></figure>

<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  printMax(<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">6</span>);</span><br><span class="line">  printMax(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(<span class="keyword">int</span>... numbers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;No data&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> max = numbers[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> item : numbers) &#123;</span><br><span class="line">    max = item &gt; max ? item : max;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识学习-1</title>
    <url>/2019/03/04/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<h2 id="Java-语言的特点"><a href="#Java-语言的特点" class="headerlink" title="Java 语言的特点"></a>Java 语言的特点</h2><ol>
<li>开源</li>
<li>一次编写，到处运行——跨平台性</li>
<li>与C/C++相似的语法结构</li>
<li>强类型</li>
<li>面向对象</li>
<li>丰富的库</li>
<li>使用垃圾回收机制进行内存管理</li>
<li>异常处理</li>
<li>并发处理</li>
<li>使用包对类进行分类</li>
</ol>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>JDK<br>Java development kit： Java 开发工具包</p>
</li>
<li><p>JRE<br>Java runtime environment：  Java 运行环境</p>
</li>
<li><p>JVM<br>Java virtual machine：  Java 虚拟机</p>
</li>
</ol>
<p>三者的关系：</p>


<h2 id="编写-Java-程序"><a href="#编写-Java-程序" class="headerlink" title="编写 Java 程序"></a>编写 Java 程序</h2><h3 id="使用记事本编写-Java-程序"><a href="#使用记事本编写-Java-程序" class="headerlink" title="使用记事本编写 Java 程序"></a>使用记事本编写 Java 程序</h3><ol>
<li>编写源程序 MyProgram.java</li>
<li>使用 javac 命令编译源程序，生成 MyProgram.calss 字节码文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac MyProgram.java</span><br></pre></td></tr></table></figure></li>
<li>使用 java 命令运行程序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java MyProgram</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="使用-Eclipse-编写-Java-程序"><a href="#使用-Eclipse-编写-Java-程序" class="headerlink" title="使用 Eclipse 编写 Java 程序"></a>使用 Eclipse 编写 Java 程序</h3><p>集成开发环境(IDE)是一类软件，将程序开发环境和调试环境集合在一起，提高开发效率。</p>
<ol>
<li>创建 Java 项目</li>
<li>创建程序包</li>
<li>编写 Java 源程序</li>
<li>运行 Java 程序</li>
</ol>


<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner stdIn = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取整数</span></span><br><span class="line">    <span class="keyword">int</span> a = stdIn.nextInt();</span><br><span class="line">    <span class="comment">// 读取小数</span></span><br><span class="line">    <span class="keyword">double</span> b = stdIn.nextDouble();</span><br><span class="line">    <span class="comment">// 读取字符串</span></span><br><span class="line">    <span class="comment">// 使用此方法读取字符串时，空白符和制表符被视为字符串的分隔符，因此如果输入中包含空格或者制表符，需要使用nextLine()</span></span><br><span class="line">    String s = stdIn.next();</span><br><span class="line">    <span class="comment">// 读取一整行</span></span><br><span class="line">    String sl = stdIn.nextLine();</span><br><span class="line">    </span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(sl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出的方法有很多，比如：</p>
<ul>
<li><code>System.out.print()</code>    直接输出</li>
<li><code>System.out.println()</code>  输出一行</li>
<li><code>System.out.printf()</code>   与C语言的printf()函数类似</li>
</ul>
<p>读取输入可以使用 Java 的 Scanner 类，使用方法如上。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下阿里云镜像安装以及Nginx安装</title>
    <url>/2019/02/27/Linux%E4%B8%8B%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8ANginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本篇文章主要记录了<code>CentOS 7</code>系统以及<code>RedHat 7</code>系统如何安装阿里云镜像以及<code>Nginx</code>，并对<code>Nginx</code>实现基本配置。</p>
<p>目前<code>RHEL/CentOS</code>软件包主要有三种类型：</p>
<ul>
<li><p><code>RPM</code>包<br><code>rpm</code>是一个完整的数据库平台，包含软件包的版本、安装路径、配置文件等全方面的服务，提供的查询、安装、卸载、升级四大功能，尤其是查询功能，常用的命令有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-q    查询指定软件包是否安装</span><br><span class="line">-qa   查询所有已安装软件列表</span><br><span class="line">-qi   查询指定软件包信息</span><br><span class="line">-ql   查询指定软件包文件列表</span><br><span class="line">-qc   查询指定软件包配置文件</span><br><span class="line">-qf   根据文件路径反向查找软件包</span><br></pre></td></tr></table></figure>
<p>由于<code>rpm</code>各个包的依赖性太强，因此一般通过<code>yum</code>进行<code>rpm</code>包的批量安装，类似于前端的npm包文管理工具</p>
</li>
<li><p>源码包<br>源码包更新及时，可定制化，但是需要自己手动编译，其依赖于编译环境，不推荐新手使用</p>
</li>
<li><p>绿色包</p>
</li>
</ul>
<p>其中我们比较常用的就是通过<code>yum</code>进行<code>rpm</code>包的安装。</p>
<p><code>yum</code>仓库早期使用系统安装光盘，或者系统自带，更新不及时，安装速度也比较慢。</p>
<p>随着技术的发展，目前国内有些比较好的镜像源：如<a href="https://opsx.alibaba.com/mirror">阿里云</a>、<a href="https://mirrors.163.com/">163</a>，都可以提供比较便捷的<code>yum</code>仓库服务。因此我们需要使用国内镜像来通过<code>yum</code>来进行<code>RPM</code>包的安装。</p>
<p>对于<code>CentOS</code>系统而言，官方自带<code>yum</code>库，而<code>RHEL</code>不提供<code>yum</code>库，因此在安装镜像之前<code>RHEL</code>需要卸载原来的红帽<code>yum</code>源，装上<code>CentOS</code>的<code>yum</code>组件。</p>
<p>接下来就是具体的安装步骤。</p>
<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><p>由于<code>CentOS 7</code>自带官方<code>yum</code>库，因此可以直接安装阿里云镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、备份</span><br><span class="line"></span><br><span class="line">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line">2、下载新的CentOS-Base.repo 到&#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"></span><br><span class="line">CentOS 5</span><br><span class="line"></span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-5.repo</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-5.repo</span><br><span class="line">CentOS 6</span><br><span class="line"></span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo</span><br><span class="line">CentOS 7</span><br><span class="line"></span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line"></span><br><span class="line">3、之后运行yum makecache生成缓存</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以参看<a href="https://opsx.alibaba.com/mirror">阿里云镜像站</a>。</p>
<h2 id="REHEL-7"><a href="#REHEL-7" class="headerlink" title="REHEL 7"></a>REHEL 7</h2><p><code>redhat</code>相对<code>CentOS</code>系统麻烦一些，具体步骤：</p>
<ol>
<li><p>卸载红帽<code>yum</code>源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e $(rpm -qa|grep yum) --nodeps</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除所有<code>repo</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf &#x2F;etc&#x2F;yum.conf</span><br><span class="line">rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">rm -rf &#x2F;var&#x2F;cache&#x2F;yum</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载<code>CentOS</code>相关的<code>yum</code>组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-3.4.3-161.el7.centos.noarch.rpm</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-plugin-fastestmirror-1.1.31-50.el7.noarch.rpm</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-updateonboot-1.1.31-50.el7.noarch.rpm</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-utils-1.1.31-50.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果没有wget命令则使用curl命令</span><br><span class="line">curl -o yum-utils-1.1.31-50.el7.noarch.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-utils-1.1.31-50.el7.noarch.rpm</span><br><span class="line">curl -o yum-3.4.3-161.el7.centos.noarch.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-3.4.3-161.el7.centos.noarch.rpm</span><br><span class="line">curl -o yum-metadata-parser-1.1.4-10.el7.x86_64.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">curl -o yum-plugin-fastestmirror-1.1.31-50.el7.noarch.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-plugin-fastestmirror-1.1.31-50.el7.noarch.rpm</span><br><span class="line">curl -o yum-updateonboot-1.1.31-50.el7.noarch.rpm https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;yum-updateonboot-1.1.31-50.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>安装时需要注意各个组件是否为最新版本，可前往目标网址查看。</p>
</li>
<li><p>安装所有相关组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh yum-* --nodeps</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载阿里云<code>base</code>仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">sed -i &#39;s#\$releasever#7#g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><p>经过以上步骤，我们已经安装了<code>yum</code>的阿里云镜像，里面只包含一些基本的库，因此我们还需要安装阿里云<code>epel</code>库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br></pre></td></tr></table></figure>

<p>接着可以下载<code>Nginx</code>官方镜像源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name&#x3D;nginx stable repo</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.key</span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是：<code>$releasever</code>为你系统的版本号</strong>。</p>


<p>然后就可以执行安装<code>Nginx</code>了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure>
<p>启动<code>Nginx</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start nginx   临时开启</span><br><span class="line">systemctl enable nginx  永久开启</span><br></pre></td></tr></table></figure>

<p>浏览器输入ip地址即可访问，如访问不了，请关闭防火墙。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld      临时关闭</span><br><span class="line">systemctl disable firewalld   永久关闭</span><br></pre></td></tr></table></figure>

<h2 id="Nginx文件说明"><a href="#Nginx文件说明" class="headerlink" title="Nginx文件说明"></a>Nginx文件说明</h2><p>全局配置文件：<code>/etc/nginx/nginx.conf</code></p>
<p>局部配置文件：<code>/etc/nginx/conf.d/*.conf</code></p>
<p>日志文件：<code>/var/log/nginx/&#123;access.log error.log&#125;</code><br>    访问日志：<code>access.log</code><br>    错误日志：<code>error.log</code></p>
<p>文档根目录：<code>/usr/share/nginx/html</code>    </p>
<p>如果要通过域名访问虚拟机，需要修改本地主机名解析记录：</p>
<ol>
<li><code>vim /etc/hosts</code></li>
<li>在文件中加入 <code>虚拟机ip 域名</code> 即可</li>
<li>访问本机 <code>c:\Windows\System32\drivers\etc\hosts</code></li>
<li>修改<code>hosts</code>文件，同第二步一样</li>
</ol>
<p>有关<code>Nginx</code>的更多可以参考<a href="/2018/12/22/nginx-1/" title="Ubuntu 系统 Nginx 服务下 ssl 证书配置">Ubuntu 系统 Nginx 服务下 ssl 证书配置</a> 以及 <a href="/2018/12/23/nginx-2/" title="Nginx 网站配置以及 NodeJS API 配置">Nginx 网站配置以及 NodeJS API 配置</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 网站配置以及 NodeJS API 配置</title>
    <url>/2018/12/23/nginx-2/</url>
    <content><![CDATA[<h3 id="网站配置简单说明"><a href="#网站配置简单说明" class="headerlink" title="网站配置简单说明"></a>网站配置简单说明</h3><p><code>Nginx</code> 主配置文件为  <code>/etc/nginx/nginx.conf</code></p>


<p><code>Nginx</code> 的 <code>server</code>模块配置文件放在 <code>/etc/nginx/sites-available</code>目录，该目录下默认有一个 <code>default</code> 文件，该文件为 <code>server</code> 模块文件。</p>


<p>我们可以看到 <code>root</code> 后面的路径就是我们网站存放的位置，因此你可以根据实际情况自己修改，我的网站是放在 <code>/var/www/sillywa.blog</code> 目录下，<code>Nginx</code> 会自动寻找该目录下的 <code>index.html</code> 文件。</p>
<p>其中 <code>server_name</code> 后面可以放我们的域名，多个域名用空格隔开</p>
<p>我们可以自己在 <code>default</code> 文件中新建其他 <code>server</code> 模块，<code>nginx.conf</code> 的 <code>http</code> 模块默认包含该目录下所有的文件</p>


<p>不过通过上图我们发现<code>nginx.conf</code> 默认包含的是 <code>/etc/nginx/sites-enabled/*</code> 下的所有文件，但是我们发现该目录下有一个 <code>default</code> 软链接，该软链接指向<code>/etc/nginx/sites-available/default</code> 文件，因此，对<code>/etc/nginx/sites-available/default</code> 文件的修改会同步到 <code>/etc/nginx/sites-enabled/default</code> </p>


<p>当然，除了直接修改  <code>/etc/nginx/sites-available/default</code> 文件外，我们也可以在 <code>/etc/nginx/conf.d</code> 文件夹下自己添加 <code>server</code> 配置文件，文件以<code>.conf</code>结尾。</p>
<h3 id="Nginx-与-NodeJS-简单结合"><a href="#Nginx-与-NodeJS-简单结合" class="headerlink" title="Nginx 与 NodeJS 简单结合"></a>Nginx 与 NodeJS 简单结合</h3><p>在 <code>Nginx</code> 中设置一个代理，让所有请求跳转到 <code>NodeJS</code> 服务的接口。</p>
<p>这是我们写好的 <code>NodeJS</code> 代码：</p>


<p>在 <code>NodeJS</code> 中我们设置了允许跨域，同时提供一个 <code>post</code> 方法的接口， <code>NodeJS</code> 监听 8888 端口。于是，我们在 <code>Nginx</code> 中加入如下配置：</p>
<p>可以在 <code>/etc/nginx/conf.d</code>文件夹下新建一个 <code>api.conf</code> 文件，然后写入如下配置：</p>


<p>其中的 <code>server_name</code> 是前端请求的 <code>api</code> 地址， <code>ssl</code> 是我们配置的 <code>ssl</code> 证书，可以参考<a href="/2018/12/22/nginx-1/" title="上一篇文章">上一篇文章</a>，<code>location</code> 做一个跳转，当有请求发到 <code>https://api.sillywa.com</code> 的时候， <code>Nginx</code> 会将请求转发到 <code>http://localhost:8888</code>，这样 <code>NodeJS</code> 就能接收到请求。</p>
<p>由于我们在 <code>NodeJS</code> 中允许了跨域，因此可以不必在 <code>Nginx</code> 中进行其他设置。</p>
<p>如果我们没有在 <code>NodeJS</code> 中做跨域， <code>Nginx</code> 中可以增加如下配置：</p>





]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 服务下 ssl 证书配置</title>
    <url>/2018/12/22/nginx-1/</url>
    <content><![CDATA[<p>最近在折腾 <code>Ubuntu</code> 系统以及如何让网站可以 <code>https</code> 访问，于是就了解到 <code>ssl</code> 证书以及 <code>Nginx</code> 服务。通过配置 <code>Nginx</code> 服务就可以让我们的网站可以通过 <code>https</code> 访问了。当然除了 <code>Nginx</code> 服务器可以选择之外，我们也可以利用 <code>Apache、Tomcat、IIS</code>等其他服务器，本文主要介绍 <code>Nginx。</code></p>
<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br><span class="line">&#x2F;&#x2F; 查看nginx版本</span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure>
<p><code>Ubuntu</code> 安装 <code>Nginx</code> 之后的文件结构大致为：</p>
<ul>
<li>所有配置文件都在 <code>/etc/nginx</code> 下面，并且每个虚拟主机已经安排在了 <code>/etc/nginx/sites-available</code> 下，该文件夹下有一个 <code>default</code> 配置文件</li>
<li>程序放在了 <code>/usr/sbin/nginx</code> </li>
<li>日志放在了 <code>/var/log/nginx</code> 中</li>
<li>启动脚本放在 <code>/etc/init.d/</code> 下</li>
<li>默认的虚拟主机的目录设置在了 <code>/var/www/nginx-default</code> (或者是 <code>/var/www</code>)，也就是说你的网站可以放在这个目录下</li>
</ul>
<h3 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure>

<p>之后可以访问 <code>http://你的公网 ip</code> ，默认监听 80 端口，启动时候若显示端口 80 被占用：<code> Starting nginx: [emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)</code> 修改文件：<code>/etc/nginx/sites-available/default</code>,去掉 <code>listen</code> 前面的 # 号 , # 号在该文件里是注释的意思 , 并且把 <code>listen</code> 后面的 80 端口号改为自己的端口，访问时需要添加端口号。</p>
<h3 id="配置-ssl-证书"><a href="#配置-ssl-证书" class="headerlink" title="配置 ssl 证书"></a>配置 ssl 证书</h3><p>阿里云购买的域名可以申请免费的 <code>ssl</code> 证书。下载之后就会有两个文件，一个 <code>.key</code> 文件，一个 <code>.pem </code>文件，<code>.key</code> 文件是证书私钥文件，<code>.pem</code> 文件是证书文件，一般包含两段内容。一般 <code>Nginx</code> 的一些文档会用该扩展名文件，在阿里云证书中与<code>.crt</code>文件一样。</p>
<p>最终我们获得了两个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example_com.key</span><br><span class="line">example_com.pem</span><br></pre></td></tr></table></figure>

<p>为了统一位置，我们可以把这两个文件放在 <code>/etc/ssl/private/</code> 目录，然后进入 <code>/etc/nginx/sites-available/</code> 目录修改 <code>default</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server; </span><br><span class="line">    listen 443 ssl default_server;</span><br><span class="line">    listen [::]:443 ssl default_server;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;example_com.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;example_com.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成之后重启 <code>Nginx</code> 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;nginx reload</span><br></pre></td></tr></table></figure>

<p>之后就可以用 <code>https://www.example.com</code> 访问你的网站了。如果是第一次配置，访问到的就应该是 <code>Nginx</code> 的欢迎页面，该页面一般存放在我们前面说的  <code>/var/www/nginx-default</code> 文件夹下，这里的  <code>nginx-default</code> 一般为 <code>html</code> 文件夹，该文件夹下有一个 <code>.html</code> 文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>web语音识别现状</title>
    <url>/2018/12/18/web%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<p>前几天试着做了一下<code>web</code>的语音识别服务，发现里面还是有不少坑的，因此想写一下<code>web</code>语音识别现状，并对几个语音识别框架作简要分析。</p>
<h2 id="annyang"><a href="#annyang" class="headerlink" title="annyang"></a>annyang</h2><p>如果在 <code>GitHub</code> 上搜索 <code>Speech recognition</code> ，最受欢迎的前端语音识别库就是 <code>annyang</code>，这个仓库有5.1k <code>star</code>，看着这么多<code>star</code>想着这个语音识别库一定非常好用，于是我就开始了 <code>annyang </code>的爬坑之旅。</p>
<p>首先我在前面先说一下 <code>annyang</code> 这个语音识别库的问题，主要有两点：</p>
<ul>
<li>对于三大浏览器，只兼容 <code>Chrome</code> 浏览器，不兼容 <code>IE</code> 和火狐</li>
<li>需要翻墙才能使用</li>
</ul>
<p>总的来说 <code>annyang</code> 的文档写的还算详细，照着文档一步一步做也能做出理想的效果，但是由于其以上两个问题，因此放弃了对这个框架的进一步探索。</p>
<p>接下来我就探索了一下，为什么这个库会有这样的问题：</p>
<p>首先第一点，<code>annyang</code> 是基于 <code>H5</code> 的 <code>Speech Recognition API</code>，下面这张图说明了这个<code>API</code>的兼容性：</p>


<p>可以看到，大部分浏览器都不支持 <code>Speech Recognition</code>。</p>
<p>接着我们来看一下 <code>MDN</code> 官方文档上怎么说</p>


<p>大概意思是说 <code>Speech Recognition</code> 基于一个识别引擎，这个识别引擎我们推测是<code>Chrome</code>的，因此这就说明了<code>Speech Recognition</code> 只有翻墙才能使用。</p>
<p>因此基于 <code>Speech Recognition</code> 的语音识别我们是无法采用的。</p>
<p>接下来看一下国内的语音识别服务。</p>
<h2 id="腾讯语音识别"><a href="#腾讯语音识别" class="headerlink" title="腾讯语音识别"></a>腾讯语音识别</h2><p>国内的语音识别服务都不是直接的语音识别，怎么说呢，就是需要你上传音频文件到它的指定接口，然后将音频文件的内容识别出来。因此我们就需要改变一下语音识别策略，首先在前端我们需要将用户说的话给录下来，然后生成音频文件传给腾讯服务的接口，但是呢，由于浏览器存在同源策略，我们不能直接将音频文件传给腾讯的接口，所以我们需要一个中间层来帮助我们转发请求，所以现在<strong>语音识别的基础流程</strong>是：</p>
<ol>
<li>前端生成音频文件传给后台</li>
<li>后台接受音频文件转发给腾讯语音识别<code>api</code></li>
<li>腾讯语音识别<code>api</code>返回结果给后台</li>
<li>后台返回结果给前端</li>
</ol>
<p>这里的后台我用的是<code>NodeJS</code>，但是在用腾讯语音识别时，首先需要接口鉴权，我们看一下接口鉴权的具体内容：</p>


<p>看到这些我内心是崩溃的，感觉超级麻烦。但是最后还是照着做了，做了之后就各种鉴权有问题，然后纠结了半天，换成了科大讯飞的语音识别。</p>
<h2 id="科大讯飞语音识别"><a href="#科大讯飞语音识别" class="headerlink" title="科大讯飞语音识别"></a>科大讯飞语音识别</h2><p>我选的是科大讯飞的语音听写<code>api</code>，然后也是要接口认证，当然，认证过程没有腾讯那么麻烦，但是也是不少坑，我最终也是掉进去了走不出来。</p>


<p>最后我终于想到了百度语音识别，然后开始了最后的尝试。</p>
<h2 id="百度语音识别"><a href="#百度语音识别" class="headerlink" title="百度语音识别"></a>百度语音识别</h2><p>首先说明一下，百度语音识别是及其友好的，没有上面的那些授权认证什么的，如果是用<code>NodeJS</code>写后台的话，只需要通过 <code>npm</code> 安装 <code>baidu-aip-sdk</code> 即可调用相应的语音服务。这里在官方文档上有一个<a href="https://github.com/Baidu-AIP/sdk-demo">demo</a>。同时大家也可以参考一下我做的一个完整的前后台语音识别<a href="https://github.com/Sillywa/speech-recognition">demo</a>。</p>
<p>因此最终我选择了百度语音识别，因为其他两个弄了半天也没弄好。</p>
<p>所以我建议大家如果用<code>NodeJS</code>来做后台的话，可以优先选择百度语音识别。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>变量对象</title>
    <url>/2018/12/07/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>前一篇文章<a href="/2018/12/07/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/" title="变量提升">变量提升</a>简单的介绍了一下变量提升原则，这篇文章将会从更专业的角度介绍变量提升。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>今天重点讲讲创建变量对象的过程。</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p>
<p>因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。</p>
<h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>我们先了解一个概念，叫全局对象。在 <a href="http://www.w3school.com.cn/jsref/jsref_obj_global.asp">W3School</a> 中也有介绍：</p>
<blockquote>
<p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。</p>
</blockquote>
<blockquote>
<p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p>
</blockquote>
<blockquote>
<p>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p>
</blockquote>
<p>如果看的不是很懂的话，容我再来介绍下全局对象:</p>
<p>1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>2.全局对象是由 Object 构造函数实例化的一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure>

<p>3.预定义了一堆，嗯，一大堆函数和属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 都能生效</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.Math.random());</span><br></pre></td></tr></table></figure>

<p>4.作为全局变量的宿主。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br></pre></td></tr></table></figure>

<p>5.客户端 JavaScript 中，全局对象有 window 属性指向自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.window.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br></pre></td></tr></table></figure>

<p>花了一个大篇幅介绍全局对象，其实就想说：</p>
<p>全局上下文中的变量对象就是全局对象呐！</p>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p>
<p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p>
<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p>
<ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p>
<p>变量对象会包括：</p>
<ol>
<li><p>函数的所有形参 (如果是函数上下文)</p>
<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
</li>
<li><p>函数声明</p>
<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li><p>变量声明</p>
<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
</li>
</ol>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">&quot;d&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ol>
<li><p>全局上下文的变量对象初始化是全局对象</p>
</li>
<li><p>函数上下文的变量对象初始化只包括 Arguments 对象</p>
</li>
<li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p>
</li>
<li><p>在代码执行阶段，会再次修改变量对象的属性值</p>
</li>
</ol>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>最后让我们看几个例子：</p>
<p>1.第一题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>

<p>第一段会报错：<code>Uncaught ReferenceError: a is not defined</code>。</p>
<p>第二段会打印：<code>1</code>。</p>
<p>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p>
<p>第一段执行 console 的时候， AO 的值是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        length: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p>
<p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p>
<p>2.第二题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>会打印函数，而不是 undefined 。</p>
<p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<p>转载至<a href="https://github.com/mqyqingfeng/Blog/blob/master/articles/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.md">深入系列文章/JavaScript深入之变量对象</a></p>
]]></content>
      <categories>
        <category>深入理解 Javascript 系列</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>变量提升</title>
    <url>/2018/12/07/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>提到<code>Javascript</code>是怎么执行代码的，大多数人的印象都是一行一行执行啊，接下来我们看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<p>如果是一行一行执行的话，第一行输出<code>a</code>的时候，<code>a</code>还未定义，所以代码会报错。</p>
<p>但是运行时发现代码能正确执行，而且第一行输出的是<code>undefined</code>，第三行输出 2；这是为什么呢？</p>
<p>原来我们发现<code>Javascrip</code>t并不是一行一行分析执行代码，而是一段一段分析，然后再执行。这里的一段一段可以看作是一个作用域。那么<code>Javascript</code>是怎么在分析代码的呢？</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p><code>Javascript</code>在进入到一个作用域时，首先会进行“预解析”，查找变量声明和函数声明，也就是找 <code>var</code> 关键字和 <code>function</code> 关键字，然后将变量声明和函数声明提升到作用域顶端，然后再开始执行代码。分析我们前面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<p>首先进行“预解析”，查找变量声明和函数声明，找到 <code>var a</code>，放到作用域顶端，继续查找变量声明和函数声明，发现没有了，然后开始执行代码。相当于以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>然后再看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>首先进行“预解析”，查找变量声明和函数声明，找到 <code>function a() &#123;&#125;</code>，放到作用域顶端，继续查找变量声明和函数声明，发现没有了，然后开始执行代码。相当于以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<h2 id="变量与函数同名"><a href="#变量与函数同名" class="headerlink" title="变量与函数同名"></a>变量与函数同名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>首先进行“预解析”，查找变量声明和函数声明，找到 <code>var a</code>，然后找到 <code>function a() &#123;&#125;</code>，此时由于函数名与变量名相同，<strong>函数声明会覆盖变量声明</strong>，因此此时代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;函数表达式&quot;</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;函数声明&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>需要注意的是函数表达式并不会提升，因此以上代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;函数声明&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line">a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;函数表达式&quot;</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>这里只讨论了较为简单的变量提升问题，当函数作用域镶套时，问题就会变复杂，但是基本分析原理还是一样的。每当进入一个作用域时按照上面的方法进行分析即可。</p>
<a href="/2018/12/07/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/" title="下一篇文章">下一篇文章</a>将从更专业的角度说明了变量提升。]]></content>
      <categories>
        <category>深入理解 Javascript 系列</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>词法作用域和动态作用域</title>
    <url>/2018/12/07/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量。<br>作用域有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所接受的<em>词法作用域</em>，也就是静态作用域，<code>Javascript</code> 正式基于这种作用域的。另一种叫做动态作用域，我们这里不作讨论。我们主要来看一下两者的区别。</p>
<h2 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h2><ul>
<li>词法作用域： 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定，换句话说，函数的作用域是函数在书写时决定的。</li>
<li>动态作用域： 动态作用域并不关心函数是如何声明以及在何处声明，只关心它们从何处调用，换句话说，函数的作用域是在函数被调用时决定的。</li>
</ul>
<p>看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure>
<p>假设 <code>Javascript</code> 采用词法作用域，我们看一下执行过程：</p>
<p>执行函数 <code>foo</code> ，在函数 <code>foo</code> 内部查找是否有局部变量 <code>a</code> ，如果没有，<strong>根据函数书写的位置</strong>，查找上面一层的代码，发现<code>a=1</code>，所以结果为1；</p>
<p>假设<code>Javascript</code>采用动态作用域，我们看一下执行过程：</p>
<p>执行函数<code>foo</code>，在函数<code>foo</code>内部查找是否有局部变量<code>a</code>，如果没有，<strong>就从调用函数的作用域</strong>，也就是<code>bar</code>内部查找变量<code>a</code>，发现<code>a=2</code>，所以结果为2；</p>
<p>根据我们前面的说明，<code>Javascript</code>是基于词法作用域的，所以结果为1。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>《JavaScript权威指南》在讲到词法作用域时，举了如下例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>
<p>根据词法作用域的规则，不论何时何地执行函数<code>f()</code>，返回的<code>scope</code>值都是<code>checkscope</code>内部局部变量<code>scope</code>的值，也就是<code>local scope</code>。</p>
]]></content>
      <categories>
        <category>深入理解 Javascript 系列</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>宽松相等和严格相等</title>
    <url>/2018/12/06/%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89%E5%92%8C%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<p>阅读本篇内容时建议先阅读<a href="/2018/12/06/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="隐式类型转换">隐式类型转换</a></p>
<p>我们通常认为“<code>==</code>检查值是否相等，<code>===</code>检查值和类型是否相等”。这样听起来蛮有道理，然而并不准确。正确的理解应该是：“<code>==</code>允许在相等比较中进行强制类型转换，而<code>===</code>不允许”。</p>
<h2 id="1-字符串和数字之间的相等比较"><a href="#1-字符串和数字之间的相等比较" class="headerlink" title="1. 字符串和数字之间的相等比较"></a>1. 字符串和数字之间的相等比较</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b =<span class="string">&#x27;42&#x27;</span></span><br><span class="line"></span><br><span class="line">a == b  <span class="comment">// true</span></span><br><span class="line">a === b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>以上代码很容易理解，因为没有进行强制类型转换，所以<code>a===b</code>为<code>false</code>。</p>
<p>而<code>a==b</code>为宽松相等，如果两个值类型不同，其中一个或者两个会进行强制类型转换。</p>
<p>但具体是怎么转换的？是字符串转换为数字还是数字转换为字符串？<br>ES5规范中这样规定：</p>
<blockquote>
<p>(1)如果Type(x)是数字，Type(y)是字符串，则返回 x == ToNumber(y)的结果<br>(2)如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果</p>
</blockquote>
<p>简单来说就是将字符串转换为数字进行相等比较。</p>
<h2 id="2-其它类型与布尔值之间的相等比较"><a href="#2-其它类型与布尔值之间的相等比较" class="headerlink" title="2. 其它类型与布尔值之间的相等比较"></a>2. 其它类型与布尔值之间的相等比较</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;42&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">a == b  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>我们知道<code>&#39;42&#39;</code>是一个真值，为什么<code>==</code>的结果不是<code>true</code>呢？根据ES5规范：</p>
<blockquote>
<p>(1)如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果<br>(2)如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果</p>
</blockquote>
<p>简单来说就是将布尔值转换为数字进行相等比较。</p>
<p>具体到这个例子，<code>b</code>通过<code>ToNumber(b)</code>转换为数字为<code>1</code>，变为 <code>&#39;42&#39; == 1</code>，按照前面的规则<code>&#39;42&#39;</code>转换为<code>42</code>，最后变为 <code>42 == 1</code>，结果为<code>false</code>。</p>
<h2 id="3-null和undefined之间宽松相等"><a href="#3-null和undefined之间宽松相等" class="headerlink" title="3. null和undefined之间宽松相等"></a>3. <code>null</code>和<code>undefined</code>之间宽松相等</h2><p>在<code>==</code>中null和<code>undefined</code>相等（它们也与其自身相等），除此之外的其它值都不存在这种情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"></span><br><span class="line">a == b      <span class="comment">// true</span></span><br><span class="line">a == <span class="literal">null</span>   <span class="comment">// true</span></span><br><span class="line">b == <span class="literal">null</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a == <span class="literal">false</span>  <span class="comment">// false</span></span><br><span class="line">b == <span class="literal">false</span>  <span class="comment">// false</span></span><br><span class="line">a == <span class="string">&quot;&quot;</span>     <span class="comment">// false</span></span><br><span class="line">b == <span class="string">&quot;&quot;</span>     <span class="comment">// false</span></span><br><span class="line">a == <span class="number">0</span>      <span class="comment">// false</span></span><br><span class="line">b == <span class="number">0</span>      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="4-对象和非对象之间的相等比较"><a href="#4-对象和非对象之间的相等比较" class="headerlink" title="4. 对象和非对象之间的相等比较"></a>4. 对象和非对象之间的相等比较</h2><p>关于对象（对象/函数/数组）和标量基本类型（字符串/数字/布尔值）之间相等的比较，ES5规范中如下规定：</p>
<blockquote>
<p>(1)如果Type(x)是数字或字符串，Type(y)是对象，则返回 x == ToPrimitive(y)的结果；<br>(2)如果Type(x)是对象，Type(y)是数字和字符串，则返回 ToPrimitive(x) == y的结果。<br>这里只提到了数字和字符串，没有布尔值，是因为我们之前介绍过布尔值会被强制转换为数字。<br>例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">42</span>]</span><br><span class="line">a == b  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>[42]</code>首先会调用<code>ToPrimitive</code>抽象操作转换为<code>&#39;42&#39;</code>，变成<code>42 == &#39;42&#39;</code>，然后变成 <code>42 == 42</code>，返回<code>true</code>。</p>
<h2 id="5-比较少见的情况"><a href="#5-比较少见的情况" class="headerlink" title="5. 比较少见的情况"></a>5. 比较少见的情况</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">null</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="literal">false</span> == []</span><br><span class="line"><span class="literal">false</span> == &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">null</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == []</span><br><span class="line"><span class="string">&#x27;&#x27;</span> == &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="number">0</span> == []</span><br><span class="line"><span class="number">0</span> == &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上相等判断均可通过我们前面的讲解分析出来，答案我就不写了。</p>
<p>下面来看一种极端情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] == ![]</span><br></pre></td></tr></table></figure>
<p>以上代码的结果是<code>true</code>还是<code>false</code>，我们先来分析一下：首先<code>![]</code>会被转换为<code>false</code>，变为<code>[] == false</code>，然后<code>[]</code>通过<code>ToPrimitive</code>操作转换为<code>&#39;&#39;</code>，即 <code>&#39;&#39; == false</code>，然后<code>false</code>通过<code>ToNumber</code>转换为<code>0</code>，变为<code>&#39;&#39; == 0</code>，最后<code>&#39;&#39;</code>通过<code>ToNumber</code>转换为<code>0</code>，变为 <code>0 == 0</code>，结果为<code>true</code>。</p>
<h2 id="安全运用隐式强制类型转换"><a href="#安全运用隐式强制类型转换" class="headerlink" title="安全运用隐式强制类型转换"></a>安全运用隐式强制类型转换</h2><p>我们要对<code>==</code>两边的值进行认真推敲，一下两个原则可以让我们有效的避免出错。</p>
<ol>
<li>如果两边的值中有<code>true</code>或<code>false</code>，千万不要使用<code>==</code></li>
<li>如果两边的值中有<code>[]、&#39;&#39;或者0</code>，尽量不要使用<code>==</code></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2018/12/06/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>冒泡排序是最简单的交换排序，冒泡排序基本原理：</p>
<blockquote>
<p>对 N 个元素的待排序序列，共进行 N-1 次循环。<br>在第 k 次循环中，从第1到第 N-k 个元素从前往后进行比较，每次比较相邻的两个元素，若前一个元素比后一个大则交换两元素的位置，否则位置保持不变。<br>这样一次循环，就把第 k 大的元素放在了 N-k 的位置上，称为第 k 趟冒泡。整个过程共进行 N-1 趟，直到第 1 个元素和第 2 个元素比较完成，最终剩余最小的元素留在第一个位置，排序结束。</p>
</blockquote>
<p>C 语言实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里我们可以增加一个flag,如果一趟排序下来没有任何元素交换，说明序列是有序的，不需要继续进行下一次循环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span>(i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                Swap(&amp;a[j],&amp;a[j+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全程无元素交换，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JS语言实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i,j;</span><br><span class="line">    <span class="keyword">let</span> flag;</span><br><span class="line">    <span class="keyword">let</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span>(i = N<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [a[j],a[j+<span class="number">1</span>]] = [a[j+<span class="number">1</span>],a[j]];</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全程无元素交换，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然最坏情况下，冒泡排序的时间复杂度为 <code>O(N²)</code> ；在最好情况下，由于用了 <code>flag</code> 标记，只需要进行 <code>O(N)</code> 次比较就从循环中跳出来了。程序的平均时间复杂度为 <code>O(N²)</code>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>同源策略及其解决方案</title>
    <url>/2018/12/06/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>“同源政策”是浏览器安全的基石，其设计目的是为了保证信息安全，防止恶意的网站窃取数据。所谓“同源”必须满足以下三个方面：</p>
<ol>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同（默认端口是80，可以省略）</li>
</ol>
<p>如果是非同源的，以下行为会受到限制：</p>
<ul>
<li><code>Cookie、LocalStorage</code>和<code>IndexDB</code>无法读取</li>
<li><code>DOM</code>无法获取</li>
<li><code>AJAX</code>请求不能发送</li>
</ul>
<p>接下来我们主要讲解如何解决以上三个方面的问题。</p>
<h3 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h3><p><code>Cookie</code>只有同源的网站才能获取，但是如果两个网页的一级域名相同，只是二级域名不同，可以设置相同的<code>document.domain</code>，两个网页就可以共享<code>cookie</code>了。</p>
<blockquote>
<p>很多人都误把带<code>www</code>当成一级域名，把其他前缀的当成二级域名，是错误的。正确的域名划分为：</p>
<ol>
<li>顶级域名：<code>.com</code></li>
<li>一级域名：<code>baidu.com</code></li>
<li>二级域名：<code>tieba.baidu.com</code></li>
</ol>
<p>举例来说，A网页是<code>http://w1.sillywa.com/a.html</code>，B网页是<code>http://w2.sillywa.com/b.html</code>，我们可以设置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;sillywa.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这样两个网页就可以共享<code>Cookie</code>了。</p>
<p>注意，这种方法只是用于<code>Cookie</code>和<code>iframe</code>，<code>LocalStorage</code>和<code>IndexDB</code>无法通过这种方法规避同源政策，而是要是用<code>PostMessage API</code>，下面我们会介绍。</p>
<h3 id="二、iframe"><a href="#二、iframe" class="headerlink" title="二、iframe"></a>二、iframe</h3><p>如果两个网页不同源，就没法拿到对方的<code>DOM</code>。典型的例子是<code>iframe</code>窗口和用<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>所以对于完全不同源的网站，目前可以使用一下三种办法规避同源问题：</p>
<ul>
<li>片段标识符(<code>fragment identifier</code>)</li>
<li><code>window.name</code></li>
<li>跨文档通信<code>API</code>(<code>window.postMessage</code>)</li>
</ul>
<h4 id="1-片段标识符"><a href="#1-片段标识符" class="headerlink" title="1.片段标识符"></a>1.片段标识符</h4><p>片段标识符指的是<code>URL</code>中<code>#</code>后面的内容，比如<code>http://sillywa.com/a.html#fragment</code>中的<code>#fragment</code>，如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息写入子窗口的片段标识符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myIframe&#x27;</span>).src = src</span><br></pre></td></tr></table></figure>
<p>子窗口通过监听<code>hashchange</code>事件得到通知：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.location.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-window-name"><a href="#2-window-name" class="headerlink" title="2.window.name"></a>2.window.name</h4><p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<h4 id="3-window-postMessage"><a href="#3-window-postMessage" class="headerlink" title="3. window.postMessage"></a>3. window.postMessage</h4><p><code>HTML5</code>为了解决跨窗口通讯问题引入了一个新的<code>API</code>：跨文档通信<code>API</code>。这个<code>API</code>为<code>window</code>新增了一个<code>window.postMessage()</code>方法，允许跨窗口通讯，不论这两个窗口是否同源。举例来说：假设父窗口为：<code>http://aaa.com</code>，子窗口为：<code>http://bbb.com</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父窗口向子窗口发送消息</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">&#x27;http://bbb.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line">popup.postMessage(<span class="string">&#x27;Hello World!&#x27;</span>, <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>postMessage()</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（<code>origin</code>），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。</p>
<p>同样，子窗口向父窗口发送消息可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">&#x27;Nice to see you&#x27;</span>, <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p><code>message</code>事件的<code>event</code>对象有以下三个属性：</p>
<ol>
<li><code>event.source：</code>发送消息的窗口</li>
<li><code>event.origin：</code>消息发送的网址</li>
<li><code>event.data：</code>消息内容</li>
</ol>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.source.postMessage(<span class="string">&#x27;Nice to see you!&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们将发送的消息改为<code>LocalStorage</code>，则可以互相读取<code>LocalStorage</code>。</p>
<h3 id="三、AJAX"><a href="#三、AJAX" class="headerlink" title="三、AJAX"></a>三、AJAX</h3><p>同样<code>AJAX</code>请求也会受到同源策略的影响，除了使用代理服务器外，还有一下方法可以实现跨域：</p>
<ul>
<li><code>jsonp</code></li>
<li><code>WebScoket</code></li>
<li><code>CORS</code></li>
</ul>
<h4 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h4><p><code>jsonp</code>想必大家都很了解，其由两部分组成：回调函数和数据。其基本思路是：动态插入<code>script</code>标签，向服务器请求<code>json</code>数据，返回的数据将在回调函数里获得。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.setAttribute(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;text/javascript&quot;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Your public IP address is: &#x27;</span> + data.ip);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">&#x27;http://example.com/ip?callback=foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于<code>JSONP</code>是必需的。</p>
<h4 id="2-WebScoket"><a href="#2-WebScoket" class="headerlink" title="2.WebScoket"></a>2.WebScoket</h4><p><code>WebScoket</code>不同于<code>http</code>，它提供一种双向通讯的功能，即客户端可以向服务器请求数据，同时服务器也可以向客户端发送数据。而<code>http</code>只能是单向的。</p>
<p>同时<code>WebScoket</code>使用<code>ws:\//</code>（非加密）和<code>wss:\//</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>要创建<code>WebScoket</code>，先实例化一个<code>WebScoket</code>对象并传入要连接的<code>URL</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scoket = <span class="keyword">new</span> WebScoket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>实例化<code>WebScoket</code>对象之后，浏览器会马上尝试建立连接。与<code>XHR</code>类似，<code>WebScoket</code>也有一系列表示当前状态的<code>readyState</code>属性，如下：</p>
<ul>
<li><code>WebScoket.OPENING</code>  (0)：正在建立连接</li>
<li><code>WebScoket.OPEN</code>  (1)：已经建立连接</li>
<li><code>WebScoket.CLOSING</code>  (2)：正在关闭连接</li>
<li><code>WebScoket.ClOSE</code>  (3)：已经关闭连接</li>
</ul>
<p><code>WebScoket</code>没有<code>readyStatechange</code>事件；不过它有其他的事件，我们待会介绍。</p>
<p>要关闭<code>WebScoket</code>连接，可以调用<code>close()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scoket.close()</span><br></pre></td></tr></table></figure>

<p><code>WebScoket</code>连接之后，就可以发送和就收数据。要发送数据可以调用<code>send()</code>方法，并传入字符串，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scoket = <span class="keyword">new</span> WebScoket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>)</span><br><span class="line">scoket.send(<span class="string">&#x27;hello word&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>因为<code>WebScoket</code>只能发送纯文本数据，所以对于复杂的数据类型我们应先将其序列化转化为json字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">scoket.send(<span class="built_in">JSON</span>.stringify(message))</span><br></pre></td></tr></table></figure>
<p>同样服务器必须先解析再读取数据。</p>
<p>当服务器向客户端发来消息时，<code>WebScoket</code>对象就会触发<code>message</code>事件。这个<code>message</code>事件与其它传递消息的协议类似，也就是把返回的数据保存在<code>event.data</code>的属性中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scoket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与通过<code>send()</code>发送到服务器的数据一样，<code>event.data</code>中返回的数据也是字符串。</p>
<p><code>WebScoket</code>对象还有其他三个事件，在连接生命周期的不同阶段触发。</p>
<ul>
<li><code>open：</code>在成功建立连接时触发</li>
<li><code>error</code>：在发生错误时触发，连接不能持续</li>
<li><code>close：</code>在连接关闭时触发<br><code>WebScoket</code>对象不支持<code>DOM2</code>级事件侦听器，因此必须使用<code>DOM0</code>级语法分别定义每个事件处理程序。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scoket = <span class="keyword">new</span> WebScoket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>)</span><br><span class="line">scoket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;connection start&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">scoket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;connection error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">scoket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这三个事件中只有<code>close</code>的<code>event</code>对象有额外的信息。这个事件的对象有三个额外的属性：<code>wasClean、code、reason</code>。其中<code>wasClean</code>是一个布尔值，表示连接是否已经明确地关闭；<code>code</code>是服务器返回的数值状态码；<code>reason</code>是一个字符串，包含服务器发回的信息。<h4 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h4><code>CORS</code>是一个<code>W3C</code>标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。</li>
</ul>
<p>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAX</code>只能同源使用的限制。</p>
<p>相比<code>jsonp</code>只能发送<code>get</code>请求，<code>CORS</code>允许发送任何类型的请求。但<code>CORS</code>要求浏览器和服务器同时支持。目前所有浏览器都支持，<code>IE</code>需要<code>IE10</code>以上。</p>
<p>整个<code>CORS</code>通讯过程中都是浏览器自动完成，不需要用户的参与。<code>CORS</code>通讯和同源的<code>AJAX</code>请求没有区别。浏览器一旦发现<code>AJAX</code>请求跨域，就会自动添加一些头部信息，有时候还会多出一次附加请求。</p>
<p>浏览器将<code>CORS</code>请求分为两类：简单请求和非简单请求。</p>
<p>只要同时满足一下两个条件就是简单请求，否则就是非简单请求：</p>
<p>（1）请求方法是下列方法之一：</p>
<ul>
<li><code>HEAD</code></li>
<li><code>GET</code></li>
<li><code>POST</code></li>
</ul>
<p>（2）<code>http</code>的头信息不超出以下几个字段：</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Last-Event-ID</code></li>
<li><code>Content-Type</code>：只限于三个值<code>application/x-www-form-urlencoded、multipart/form-data、text/plain</code></li>
</ul>
<p>对于简单请求，浏览器会自动在头部信息里增加一个<code>Origin</code>字段，用来表示请求来自与哪个源，服务器根据这个值决定是否同意此次请求。如果<code>Origin</code>不在请求范围内，服务器返回一个正常的<code>http</code>回应。这个回应的头信息中没有<code>Access-Control-Allow-Origin</code>字段，浏览器发现没有这个字段之后就会抛出一个错误。如果<code>Origin</code>在请求范围内，服务器返回的响应会多出几个头信息字段，其中一个是<code>Access-Control-Allow-Origin</code>，它的值要么是<code>Origin</code>的值，要么是*，表示允许任何域名的请求。</p>
<p>对于非简单请求，它会在正式通信之前，增加一次<code>http</code>查询请求，称为”预检”请求（<code>preflight</code>）。通常是一个<code>OPTION</code>请求。这个请求先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪<code>http</code>动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>如果大家想要更详细的了解<code>CORS</code>，可以参考以下文章。</p>
<p>参考文章：</p>
<p>阮一峰《<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a>》</p>
<p>阮一峰《<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a>》</p>
<p>参考书籍：</p>
<p>《javascript高级程序设计》</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器回流(Reflow)与重绘(Repaint)及其思考</title>
    <url>/2018/12/06/reflow-and-repaint/</url>
    <content><![CDATA[<p>我们知道浏览器在解析文档时，会经历以下步骤：</p>
<ol>
<li>将<code>HTML</code>解析为<code>DOM</code>，将<code>CSS</code>解析为<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并生成<code>Render Tree</code></li>
<li>然后根据<code>Render Tree</code>将节点绘制在页面上</li>
</ol>
<p>所谓回流是当元素尺寸、结构或者某些属性发生改变时，浏览器重新部分或者全部渲染文档的过程。<br>所谓重绘是指元素样式发生改变但并未改变其在文档流中的位置。</p>
<h3 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流(Reflow)"></a>回流(Reflow)</h3><p>我们理解了回流之后再看看哪些操作会导致浏览器回流：</p>
<ol>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或者位置发生变化</li>
<li>元素内容变化</li>
<li>元素字体变化</li>
<li>添加或删除<code>DOM</code></li>
<li>激活<code>CSS</code>伪类</li>
<li>查询某些属性或调用某些方法：<ul>
<li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li>
<li><code>offsetWidth、offsetHeight、offsetTop、offsetLeft</code></li>
<li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li>
<li><code>scrollIntoView()、scrollIntoViewIfNeeded()</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
<li><code>scrollTo()</code></li>
</ul>
</li>
</ol>
<h3 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘(Repaint)"></a>重绘(Repaint)</h3><p>当页面中元素的样式改变并不影响其在文档流中得到位置时，浏览器紧紧将新样式赋给它并重新绘制，这就是重绘。例如<code>color、background-color、visibility</code></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>既然这样那么我们如何避免重绘与回流呢？</p>
<ul>
<li>避免使用<code>table</code>布局</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上，脱离文档流的元素不会引起回流</li>
<li>可以使用<code>tranform</code>属性来设置动画</li>
<li>避免频繁操作样式，最好使用<code>class</code>来更改样式</li>
<li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面进行<code>DOM</code>操作</li>
<li>可以先将元素设为<code>display:none</code>，操作后再把它显示出来。因为在<code>display</code>为<code>none</code>的元素上操作不会引起重绘与回流</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS事件</title>
    <url>/2018/12/06/event/</url>
    <content><![CDATA[<p>事件用来处理js与HTML之间的交互，我们可以使用事件处理程序来监听事件，以便在事件发生时执行相应代码。</p>
<h3 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h3><ul>
<li>事件冒泡：IE事件流叫做事件冒泡，即事件由最具体的元素向外传播，是由内向外的</li>
<li>事件捕获：事件捕获即事件由不具体的元素到具体元素，是由外向内传播</li>
<li>DOM事件流：DOM2级事件规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段</li>
</ul>
<h3 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h3><ul>
<li><h4 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h4></li>
</ul>
<p>直接在html代码中绑定事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;doSomething()&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>我们一般不采用这种方法绑定事件，因为html代码与js代码耦合度太高，不便于维护。但是现在的vue框架使用的却是这种事件处理程序。</p>
<ul>
<li><h4 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h4></li>
</ul>
<p>这种方法就是将一个函数赋值给一个事件处理程序属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中我们需要注意的是DOM0级事件处理程序被认为是元素的方法，因此事件处理程序是在元素的作用域中运行的，this指向当前元素。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 输出元素的id属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h4></li>
</ul>
<p>DOM2级事件处理程序定义了两个方法，用于处理指定和删除事件处理程序的操作：<code>addEventListener()</code>和<code>removeEventListener()</code>。所有DOM节点都包含这两个方法，并且他们都接受三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后一个布尔值如果为true表示在捕获阶段调用事件处理程序；如果为false表示在冒泡阶段调用事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>使用DOM2级事件处理程序的好处是可以为一个节点添加多个事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>这两个事件处理程序会按照顺序依次执行，所以首先弹出0，再弹出1。</p>
<p>通过<code>addEventListener()</code>添加的事件处理程序只能使用<code>removeEventListener()</code>来移除；移除时使用的参数应当与添加时相同。这也就是说直接添加的匿名函数处理程序是无法移除的，举例来说：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 没有用</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>在这个例子中我们虽然调用<code>removeEventListener()</code>使用的看似相同的参数，其实两个匿名函数根本不同，所以我们的给函数起个名字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, handler, <span class="literal">false</span>)  <span class="comment">// 有效</span></span><br></pre></td></tr></table></figure>
<p>大多数情况下我们都应该在事件冒泡阶段调用事件处理程序以兼容各大浏览器。最好在只需要在事件到达目标前截获它的时候将事件处理程序添加到事件捕获阶段。</p>
<p><strong>需要注意的是DOM2级事件处理程序和DOM0级事件处理程序一样，事件处理程序中的this也是指向当前元素。</strong></p>
<ul>
<li><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4></li>
</ul>
<p>IE实现了与DOM2级处理程序中类似的两个方法：<code>attachEvent()和detachEvent()</code>，这两个方法接受相同的两个参数：事件名称和事件处理程序函数。事件处理程序默认被添加到事件冒泡阶段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是<code>attachEvent()</code>第一个参数为<code>&#39;onclick&#39;</code>而非<code>addEventListener()</code>中的<code>&#39;click&#39;</code></strong></p>
<p><strong>在IE中使用<code>attachEvent()</code>与DOM0级DOM2级方法的主要区别在于事件处理程序函数的作用域不一样。在使用DOM0级DOM2级方法时，事件处理函数的作用域为当前元素所在作用域，this指向当前元素，而在使用<code>attachEvent()</code>方法时，事件处理程序函数的作用域为全局作用域，this指向window。</strong></p>
<p>同样我们亦可以使用<code>attachEvent()</code>方法为一个元素添加多个事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>不过需要注意的是，与DOM事件处理不同，这些事件处理程序并不是按照他们添加的顺序依次执行，而是以相反的顺序执行</strong>。所以先弹出1，再弹出0。</p>
<p>与DOM事件处理程序一样，通过<code>attachEvent()</code>添加的事件也只能使用<code>detachEvent()</code>方法移除，参数必须一模一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    alert(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, handler)</span><br><span class="line">btn.detachEvent(<span class="string">&#x27;onclick&#x27;</span>, handler)</span><br></pre></td></tr></table></figure>

<p>在所有事件处理程序中HTML事件处理程序和DOM0级事件处理程序兼容所有浏览器，DOM2级事件处理程序兼容IE9+、Firefox、Chrome和OPera，IE事件处理程序兼容IE8及以下，不过现在大部分公司都不会兼容IE8及以下，所以广泛使用的还是DOM0级和DOM2级事件处理程序。</p>
<h3 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h3><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含所有与事件对象有关的信息。包括导致事件的元素、事件的类型等等。所有浏览器都支持event，但支持方式不同。</p>
<ul>
<li><h4 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h4><p>兼容DOM的浏览器都会将一个event对象传入到事件处理程序中。无论是DOM0级还是DOM2级事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>在通过HTML特性指定的事件处理程序时，同样存在event对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(event)&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>event对象包含一下常用属性与方法：</p>
</li>
<li><p><code>type</code>：事件类型如click</p>
</li>
<li><p><code>target</code>：事件实际发生的目标</p>
</li>
<li><p><code>preventDefault()</code>：取消事件的默认行为</p>
</li>
<li><p><code>stopPropagation()</code>：取消事件捕获或冒泡</p>
</li>
</ul>
<p>需要注意的是只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完毕，event对象就会被销毁。</p>
<ul>
<li><h4 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h4>与访问DOM中的event对象不同，访问IE中的event对象取决于事件处理程序。</li>
</ul>
<p>以下是DOM0级事件处理程序时的event：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = <span class="built_in">window</span>.event</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>event对象被看作为window的一个属性。</p>
<p>但是如果事件处理程序使用<code>attachEvent()</code>添加的，那么就会有一个event对象作为参数被传入事件处理函数中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果直接使用HTML事件处理程序，也可以通过event变量访问到event对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(event)&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>IE中的event对象同时也有一下几个常见的属性及方法：</p>
<ul>
<li><code>type</code></li>
<li><code>srcElement</code>：事件目标，相当于target</li>
<li><code>returnValue</code>：默认为true，设置为false可以取消事件的默认行为，相当于preventDefault()</li>
<li><code>cancelBubble</code>：默认为false，将其设置为true可以取消事件冒泡，相当于stopPropagation()</li>
</ul>
<h3 id="四、事件委托"><a href="#四、事件委托" class="headerlink" title="四、事件委托"></a>四、事件委托</h3><p>当事件处理程序过多时，为了避免我们一个个添加事件处理程序，我们可以考虑使用事件委托。考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;sayOne&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;sayTwo&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;sayThree&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>现在我们要点击li元素然后执行不同的函数，一般做法是给每一个li元素都添加一个事件处理程序，但是这种做法或导致页面性能下降，因此我们利用事件冒泡，只指定一个事件处理程序，用它来管理所有同类事件，具体实现方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>)</span><br><span class="line">list.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// target为当前点击的元素</span></span><br><span class="line">    <span class="keyword">var</span> target = event.target</span><br><span class="line">    <span class="keyword">switch</span>(target.id) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;sayOne&#x27;</span>:</span><br><span class="line">            alert(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;sayTwo&#x27;</span>:</span><br><span class="line">            alert(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;sayThree&#x27;</span>:</span><br><span class="line">            alert(<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM</title>
    <url>/2018/12/06/DOM/</url>
    <content><![CDATA[<p>所谓DOM就是文档对象模型，我们可以把一个文档的各种元素想象成一个节点树，每一段标记都可以通过树中的一个节点（Node）来表示：HTML元素通过元素节点表示、属性通过属性节点表示、文本通过文本节点表示。总共有12种节点类型，我们需要重点掌握元素节点，属性节点和文本节点。</p>
<h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>每一个节点都具有一系列公共属性，下面我们列举一下常见的属性：</p>
<ul>
<li><code>nodeType</code>: 显示节点的类型，1代表元素节点、2代表属性节点、3代表文本节点</li>
<li><code>nodeName</code>: 元素节点的标签名，以大写表示</li>
<li><code>tagName</code>: 与<code>nodeName</code>一样</li>
<li><code>nodeValue</code>: 元素节点的值，文本节点和属性节点才有值，元素节点的<code>nodeValue</code>为<code>null</code></li>
<li><code>attributes</code>: 返回属性节点的集合<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;wrapper&quot;</span> id=<span class="string">&quot;totop&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;totop&#x27;</span>).attributes[<span class="string">&quot;id&quot;</span>]  <span class="comment">// 此处是id属性节点，并不是id的值</span></span><br><span class="line"><span class="comment">// 要得到id的值，只需获取该属性节点的值</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;totop&#x27;</span>).attributes[<span class="string">&quot;id&quot;</span>].nodeValue</span><br><span class="line"><span class="comment">// 当然一般情况下我们这样获取id的值</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;totop&#x27;</span>).id</span><br></pre></td></tr></table></figure></li>
<li><code>firstChild</code>: 表示某个节点的第一个节点</li>
<li><code>lastChild</code>: 表示某个节点的最后一个节点</li>
<li><code>childNodes</code>: 表示某个节点的所有子节点的数组</li>
<li><code>parentNode</code>: 表示某个节点的第一个父节点</li>
<li><code>nextSibling</code>: 下一个兄弟节点</li>
<li><code>previousSibling</code>: 上一个兄弟节点</li>
</ul>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><ol>
<li>创建节点<ul>
<li>创建一个元素节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个div元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>创建一个文本节点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var text &#x3D; document.createTextNode(&#39;Hello Word&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>添加节点</li>
</ol>
<p>当我们创建了一个个节点之后我们需要把他们组合在一起，即将一个节点添加到另一个节点中。这是我们可以用<code>appendChild()</code>方法，将该节点添加到另一个节点的<code>childNodes</code>末尾。添加节点之后，<code>appendChild()</code>返回新增的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个div元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello Word&#x27;</span>)</span><br><span class="line">div.appendChild(text)</span><br><span class="line"><span class="comment">// 最后还需要将节点加入到body中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line"></span><br><span class="line">div.lastChild == div.appendChild(text)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>插入节点</li>
</ol>
<p>我们可以用<code>insertBefore()</code>方法来在一个节点之前插入另一个节点，调用该方法的应当是目标节点的父节点，这个方法接受两个参数：要插入的节点和目标节点。插入节点后，被插入的节点会变成目标节点的前一个兄弟节点(<code>previousSibling</code>)，同时返回插入的节点。如果第二个参数是<code>null</code>，则和<code>appendChild()</code>方法一样。</p>
<p>下面是该方法的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parentElement.insertBefore(newElement, targetElement)</span><br></pre></td></tr></table></figure>
<p>我们不必搞清楚目标元素的父元素是谁，因为<code>targetElement</code>元素的<code>parentNode</code>就是目标元素的父元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">targetElement.parentNode.insertBefore(newElement, targetElement)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>移除节点</li>
</ol>
<ul>
<li><p><code>replaceChild()</code>：该方法替换一个节点的子节点，接受两个参数：第一个为新的节点，第二个为目标节点，返回目标节点并从文档中被移除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换第一个子节点</span></span><br><span class="line">someNode.replaceChild(newNode, someNode.firstChild)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>removeChild()</code>：该方法接受一个参数，即要移除的节点，返回移除的节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除第一个子节点</span></span><br><span class="line">someNode.removeChild(someNode.firstChild)</span><br></pre></td></tr></table></figure>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3></li>
</ul>
<ol>
<li>获取属性</li>
</ol>
<p>通常情况下我们可以使用<code>getAttribute()</code>方法来获取一个属性节点的值，该方法只有一个参数：要获取的属性的名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someNode.getAttribute(attribute)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>设置属性</li>
</ol>
<p>当我们需要修改或设置属性时，可以使用<code>setAttribute()</code>方法，该方法接受两个参数：要设置或修改的属性，属性值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someNode.setAttribute(attribute, value)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>移除属性</li>
</ol>
<p>当我们需要移除属性时，可以使用<code>removeAttribute()</code>方法，该方法接受一个参数：要移除的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someNode.removeAttribute(attribute)</span><br></pre></td></tr></table></figure>
<h3 id="理解元素的子节点"><a href="#理解元素的子节点" class="headerlink" title="理解元素的子节点"></a>理解元素的子节点</h3><p>我们需要注意的是不同浏览器处理子节点的方式是不一样的，以下面代码为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很显然<code>&lt;div&gt;</code>元素有3个子节点，分别是3个<code>&lt;p&gt;</code>元素，但是这种说法只有在IE浏览器中才是正确的。因为在其它浏览器中<code>&lt;div&gt;</code>有7个子节点，增加了4个文本节点（表示<code>&lt;p&gt;</code>元素之间的空隙）。如果像下面这样删除空格，那么所有浏览器都会返回相同数量的子节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此如果要通过<code>childNodes</code>属性遍历子节点，一定要判断节点类型即<code>nodeType</code>的值，只有当<code>nodeType</code>值为1时，才能进行操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = element.childNodes.length; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.childNodes[i].nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Object.defineProperty() 的原生js双向数据绑定</title>
    <url>/2018/12/06/%E5%8E%9F%E7%94%9Fjs%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>前面我们介绍过存储器属性(<a href="/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/" title="重新认识JS对象（一）-- 对象及其属性">重新认识JS对象（一）-- 对象及其属性</a>)，以及如何用<code>Object.defineProperty()</code>定义一个存储器属性，今天我们介绍如何用<code>Object.defineProperty()</code>实现双向数据绑定。</p>
<p>我们知道一个存储器属性有四个属性描述符：<code>get，set，configurable，enumerable</code>。我们来复习一下如何创建一个存储器属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    name: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;nickname&#x27;</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上代码我们给<code>user</code>创建了一个名为<code>nickname</code>的存储器属性。</p>
<p>接下来我们改写<code>get</code>和<code>set</code>，让它们与<code>DOM</code>绑定，并实现双向数据绑定，以下为具体实现的伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> user = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;inputValue&#x27;</span>, &#123;</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>我们打开控制台，改变<code>user.inputValue</code>的值，会发现<code>input</code>输入框里的值也发生变化；同样我们在<code>input</code>输入框里面输入值，在控制台打印<code>user.inputValue</code>，会发现<code>user.inputValue</code>也发生了变化。这样我们就实现了双向的数据绑定。</p>
<p>如果多个<code>DOM</code>绑定同一个数据，我们可以监听<code>input</code>输入框的<code>keyup</code>事件，只要触发了<code>keyup</code>事件我们就把<code>user.inputValue</code>的值赋给另一个<code>DOM</code>，具体实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;test&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> user = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;inputValue&#x27;</span>, &#123;</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value = value</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML = user.inputValue</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>最后附上源码图片<br><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e673d16d3544a?w=809&h=889&f=png&s=92772"></p>
<p>思考：其实实现双向数据绑定并不一定要用<code>Object.defineProperty()</code>，其主要是运用存储器属性的<code>get和set</code>，以下代码也可以实现双向数据绑定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;test&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> user = &#123;</span><br><span class="line">      <span class="keyword">get</span> <span class="title">inputValue</span>() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span> <span class="title">inputValue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).value = value</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>).innerHTML = user.inputValue</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式类型转换</title>
    <url>/2018/12/06/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="一、抽象值操作"><a href="#一、抽象值操作" class="headerlink" title="一、抽象值操作"></a>一、抽象值操作</h2><p>在javascript中隐式类型转换总是返回基本类型值，如字符串、数字、布尔值，不会返回对象或者函数。所以我们在介绍隐式类型转换之前首先来看一看字符串、数字、布尔值之间类型转换的基本规则。这里涉及到<code>ToString</code>、<code>ToNumber</code>和<code>ToBoolean</code>，同时我们还会介绍<code>ToPrimitive</code>。</p>
<h3 id="（一）ToString"><a href="#（一）ToString" class="headerlink" title="（一）ToString"></a>（一）<code>ToString</code></h3><p><code>ToString</code>负责处理非字符串到字符串的强制类型转换。</p>
<p>(1)基本类型的值转化为字符串的基本规则：</p>
<pre><code>1. null转化为&quot;null&quot;
2. undefined转化为&quot;undefined&quot; 
3. true转化为&quot;true&quot;
4. 数字的字符串转化规则遵循通用规则，不过那些极小或者极大的数值使用指数形式：

var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000
a.toString()  // &quot;1.07e21&quot;</code></pre>
<p>(2)对于普通对象来说，如果没有自定义<code>toString()</code>方法，返回<code>&quot;[object Object]&quot;</code>。如果有自己的<code>toString()</code>方法就会调用该方法并返回值。</p>
<p>(3)数组的<code>toString()</code>返回所有单元字符串化以后再用”,”连接起来：</p>
<pre><code>var a = [1,2,3]
a.toString()  // &quot;1,2,3&quot;</code></pre>
<p>(4)日期、正则、函数也遵循通用规则。</p>
<h3 id="（二）ToNumber"><a href="#（二）ToNumber" class="headerlink" title="（二）ToNumber"></a>（二）<code>ToNumber</code></h3><p>(1)基本类型的值转化为数字的基本规则：</p>
<pre><code>1. null转化为0
2. undefined转化为NaN
3. true转化为1，false转化为0
4. 字符串的处理遵循通用规则

Number(&quot;23&quot;)  // 23
Number(&quot;&quot;)    // 0</code></pre>
<p>(2)对象或者数组首先会被转化为相应的基本类型，如果返回的是非数字的基本类型，再按照以上规则进行转化。其中对象转化为基本类型的时候会使用<code>ToPrimitive</code>操作。</p>
<h3 id="（三）ToPrimitive"><a href="#（三）ToPrimitive" class="headerlink" title="（三）ToPrimitive"></a>（三）<code>ToPrimitive</code></h3><p><code>ToPrimitive</code>操作会首先检查对象是否有<code>valueOf()</code>方法，如果有并且返回基本类型的值，就调用该方法进行类型转化。如果没有就使用<code>toString()</code>返回的值。</p>
<p>如果<code>valueOf()</code>和<code>toString()</code>均不返回基本类型的值，就会产生<code>TypeError</code>错误。</p>
<p>如果不对对象和数组的<code>valueOf()</code>和<code>toString()</code>方法进行重写，那么：</p>
<p>(1)对象的<code>valueOf()</code>返回对象本身，<code>toString()</code>返回<code>&quot;[object Object]&quot;</code></p>
<p>(2)数组的<code>valueOf()</code>返回数组本身，<code>toString()</code>返回所有单元字符串化以后再用”,”连接起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.valueOf()   <span class="comment">// &#123; name: &#x27;sillywa&#x27; &#125;</span></span><br><span class="line">a.toString()  <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line">b.valueOf()   <span class="comment">// [1,2,3]</span></span><br><span class="line">b.toString()  <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="（四）ToBoolean"><a href="#（四）ToBoolean" class="headerlink" title="（四）ToBoolean"></a>（四）<code>ToBoolean</code></h3><ol>
<li><code>null</code>转化为<code>false</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><code>undefined</code>转化为<code>false</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>除””以外，所有字符串转化为<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>)  <span class="comment">// fasle</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;abc&quot;</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;0&#x27;</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>除0（包括+0和-0）和<code>NaN</code>外，所有数字转化为<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">-9</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>所有对象转化为<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([])  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是通过new关键字得到的是一个对象</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Boolean</span>(a &amp;&amp; b &amp;&amp; c)</span><br><span class="line">d   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="二、隐式类型转化"><a href="#二、隐式类型转化" class="headerlink" title="二、隐式类型转化"></a>二、隐式类型转化</h2><h3 id="（一）字符串和数字之间的隐式类型转化"><a href="#（一）字符串和数字之间的隐式类型转化" class="headerlink" title="（一）字符串和数字之间的隐式类型转化"></a>（一）字符串和数字之间的隐式类型转化</h3>(1)数字转化为字符串</li>
</ol>
<p>+运算符既能用于数字相加，也能用于字符串拼接。那么javascript是怎么判断我们要执行那个操作的呢？例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;42&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">a + b  <span class="comment">// &quot;420&quot;</span></span><br><span class="line">c + d  <span class="comment">// 42</span></span><br><span class="line">e + f  <span class="comment">// &quot;420&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上代码不难理解，通常我们认为+运算符两边只要有一个操作数是字符串就会执行字符串的拼接操作，但是实际情况更为复杂，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a + b  <span class="comment">// &quot;1,23,4&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>a,b</code>都不是字符串，但是它们都被转化为字符串进行拼接操作，原因何在？</p>
<p>简单的理解应当是如果+运算符其中一个是字符串或者可以通过<code>ToPrimitive</code>（针对于对象，包括数组）转化为字符串，则执行字符串的拼接；否则执行数字相加。</p>
<p><em style="color:red">需要注意的是如果是 <code>+ &#39;42&#39;</code>代表强制类型转化为数字，即 <code>42</code>。</em></p>
<p>(2)字符串转化为数字</p>
<p>- , * , /都可以用来将字符串转化为数字，其规则与+类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;3.14&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = a - <span class="number">0</span></span><br><span class="line">b  <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<p>同样对于对象和数组也是一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>]</span><br><span class="line">a - b   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>为了执行减法运算，<code>a、b</code>都需要被转化为数字，首先通过<code>ToPrimitive</code>转化为字符串再转化为数字。</p>
<h3 id="（二）布尔值到数字的隐式类型转化"><a href="#（二）布尔值到数字的隐式类型转化" class="headerlink" title="（二）布尔值到数字的隐式类型转化"></a>（二）布尔值到数字的隐式类型转化</h3><p>简单举了例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="literal">false</span>  <span class="comment">// 1</span></span><br><span class="line"><span class="number">1</span>+ <span class="literal">true</span>  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="（三）隐式类型转化为布尔值"><a href="#（三）隐式类型转化为布尔值" class="headerlink" title="（三）隐式类型转化为布尔值"></a>（三）隐式类型转化为布尔值</h3><p>以下几种情况会发生隐式类型转化为布尔值</p>
<ol>
<li><code>if(..)</code>条件判断语句</li>
<li><code>for()</code>中的条件判断</li>
<li><code>while()</code>和<code>do..while(..)</code>中的条件判断</li>
<li><code>? :</code> 三目运算符中的条件判断</li>
<li>逻辑运算符 <code>|| </code>和<code> &amp;&amp;</code> 左边的操作数</li>
</ol>
<h3 id="（四）-和-amp-amp"><a href="#（四）-和-amp-amp" class="headerlink" title="（四）|| 和 &amp;&amp;"></a>（四）<code>|| 和 &amp;&amp;</code></h3><p>ES5规范中有如下描述</p>
<blockquote>
<p><code>&amp;&amp;</code>和 <code>||</code> 运算符并不一定返回布尔值，而是两个操作数其中一个的值</p>
</blockquote>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">a || b  <span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b  <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line">c || b  <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line">c &amp;&amp; b  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p><code>|| 和 &amp;&amp;</code> 首先会对第一个操作数进行条件判断，如果其不是布尔值，会被转化为布尔值，在进行判断。</p>
<p>对于 <code>||</code> 如果第一个操作数返回true则返回第一个操作数的值，如果第一个操作数返回false就返回第二个操作数的值。</p>
<p>对于 <code>&amp;&amp;</code> 如果第一个操作数返回true则返回第二个操作数的值，如果第一个操作数返回false就返回第一个操作数的值。</p>
<p>本篇就介绍到这里，下篇介绍隐式类型转换之(宽松相等和严格相等)。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识JS对象（三）-- 原型及原型链</title>
    <url>/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、原型检测"><a href="#一、原型检测" class="headerlink" title="一、原型检测"></a>一、原型检测</h2><p>javascript中提供<code>Object.getPrototypeOf()</code>方法来获得对象的直接原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1)  <span class="comment">// &#123;constructor: ƒ Person()&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1.__proto__)  <span class="comment">// Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person2)  <span class="comment">// &#123;name: &quot;sillywa&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>javascript有以下几种方法检测一个对象的原型：</p>
<ol>
<li><code>isPrototypeOf()</code>：检测一个对象是否是另一个对象的原型</li>
<li><code>obj.constructor.prototype</code>：检测非<code>Object.create()</code>创建的对象的原型<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// isPrototypeOf()方法</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj1)  <span class="comment">// true</span></span><br><span class="line">obj1.isPrototypeOf(obj2)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj2)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.constructor.prototype</span></span><br><span class="line">obj1.constructor.prototype === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// obj1是obj2的原型，以下等式应为true</span></span><br><span class="line">obj2.constructor.prototype === obj1  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 而实际上</span></span><br><span class="line">obj2.constructor.prototype === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
以上代码中<code>obj1</code>是<code>obj2</code>的原型，<code>obj2.constructor.prototype === obj1</code>应为<code>true</code>但是实际上却是<code>false</code>，因为<code>obj2</code>的<code>__proto__</code>里面并没有一个<code>constructor</code>属性，<code>obj2.constructor</code>实际上是<code>obj1</code>的<code>__proto__</code>里面的<code>constructor</code>，所以<code>obj2.constructor.prototype === Object.prototype</code>。<br><img src="https://user-gold-cdn.xitu.io/2018/2/2/161555a08b89f7c8?w=501&h=377&f=png&s=40282"><h2 id="二、constructor、-proto-与prototype之间的关系"><a href="#二、constructor、-proto-与prototype之间的关系" class="headerlink" title="二、constructor、__proto__与prototype之间的关系"></a>二、<code>constructor</code>、<code>__proto__</code>与<code>prototype</code>之间的关系</h2>在javascript中我们每创建一个对象，该对象都会获得一个<code>__proto__</code>属性（该属性是个对象），该属性指向创建该对象的<code>构造函数的原型</code>即<code>prototype</code>，同时<code>__proto__</code>对象有一个<code>constructor</code>属性指向该构造函数。这里我们需要注意的是只有函数才有<code>prototype</code>，每个对象（函数也是对象）都有<code>__proto__</code>，<code>Object</code>本身是个构造函数。举例来说：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="comment">// 也可以使用对象字面量创建，但使用Object.create()情况会不一样</span></span><br><span class="line"><span class="comment">// Object本身是个构造函数</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// true</span></span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line">obj.__proto__.constructor === <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 我们一般习惯这样写</span></span><br><span class="line">obj.constructor === <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
当我们访问<code>obj.constructor</code>的时候，<code>obj</code>本身是没有<code>constructor</code>属性的，但属性访问会沿着<code>__proto__</code>向上查找，即在<code>obj.__proto__</code>里面寻找<code>constructor</code>属性，如果找到了就返回值，如果未找到则继续向上查找直到<code>obj.__proto__.__proto__...(__proto__) === null </code>为止，没有找到则返回undefined。这样由<code>__proto__</code>构成的一条查找属性的线称为‘原型链’。<h2 id="三、进一步探讨"><a href="#三、进一步探讨" class="headerlink" title="三、进一步探讨"></a>三、进一步探讨</h2>我们知道JS是单继承的，<code>Object.prototype</code>是原型链的顶端，所有对象从它继承了包括<code>toString</code>等等方法和属性。</li>
</ol>
<p>前面我们说到<code>Object</code>本身是构造函数，那么它继承了<code>Function.prototype</code>;<code>Function</code>也是对象，继承了<code>Object.prototype</code>。这里就有一个鸡和蛋的问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>以下是ES规范的解释：</p>
<blockquote>
<p><code>Function</code>本身就是函数，<code>Function.__proto__</code>是标准的内置对象<code>Function.prototype</code>。<br><code>Function.prototype.__proto__</code>是标准的内置对象<code>Object.prototype</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;sillywa&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/2/161558d58482d19c?w=826&h=253&f=png&s=20926"></p>
<p>总的来说：先有<code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code>继承<code>Object.prototype</code>而产生，最后，<code>Function</code>和<code>Object</code>和其它构造函数继承<code>Function.prototype</code>而产生。</p>
<h2 id="四、Object-create"><a href="#四、Object-create" class="headerlink" title="四、Object.create()"></a>四、<code>Object.create()</code></h2><p>我们知道通过<code>Object.create()</code>创建的对象实际上等于将该对象的<code>__proto__</code>指向<code>Object.create()</code>里面的参数对象，那么当涉及到原型时它是怎么工作的呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a)</span><br><span class="line"></span><br><span class="line">b.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// false</span></span><br><span class="line">b.__proto__ === a  <span class="comment">// true</span></span><br><span class="line">b.__proto__.constructor === <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">b.__proto__.hasOwnProperty(<span class="string">&#x27;constructor&#x27;</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>下面我们来具体看一看当<code>var b = Object.create(a)</code>到底发生了什么，以下实在浏览器中的结果：<br><img src="https://user-gold-cdn.xitu.io/2018/2/2/161555a08b89f7c8?w=501&h=377&f=png&s=40282"><br>我们可以看到当<code>var b = Object.create(a)</code>实际上是把<code>b</code>的<code>__proto__</code>指向了<code>a</code>。当访问<code>b.constructor</code>时，实际上访问的是<code>b.__proto__.__proto__.constructor</code>。</p>
<h2 id="五、实例与总结"><a href="#五、实例与总结" class="headerlink" title="五、实例与总结"></a>五、实例与总结</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;sillywa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.__proto__ === Person.prototype</span><br><span class="line">person1.__proto__.__proto__ === Person.prototype.__proto__</span><br><span class="line">person1.__proto__.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line">Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype </span><br><span class="line">person1.__proto__.__proto__.__proto__ === <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">Person.__proto__ === <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>
<p>以上均返回<code>true</code>，前五个等式和第一部分内容相关，最后一个等式为第二部分内容，<strong>需要注意的是IE浏览器里面并没有实现<code>__proto__</code>，为了便于理解我们可以这样解释，但是最好不要在实际中使用</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/2/161557f207fff784?w=823&h=242&f=png&s=21059"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识JS对象（二）-- 对象及其属性</title>
    <url>/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>前面介绍了如何创建对象，对象的存储器属性以及对象的特性（属性描述符），今天我们接着前面的来介绍对象及其属性。</p>
<h2 id="一、删除属性"><a href="#一、删除属性" class="headerlink" title="一、删除属性"></a>一、删除属性</h2><p><code>delete</code> 运算符可以用来删除对象的属性，它的操作数应当是个属性访问表达式（如果是个非法的操作数，早严格模式下会报错）。但它只能删除对象的自有属性，不能删除在原型对象上的属性，如果需要删除原型对象上的属性，需要在原型里面进行操作。</p>
<p>当<code>delete</code> 删除属性成功或者没有任何副作用时，返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name  <span class="comment">// 删除name属性，返回true</span></span><br><span class="line">person1.name  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图删除原型上的属性</span></span><br><span class="line"><span class="keyword">delete</span> person1.sex  <span class="comment">// 无法删除，没有任何副作用，返回true</span></span><br><span class="line">person1.sex  <span class="comment">// &#x27;boy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除sex属性</span></span><br><span class="line"><span class="keyword">delete</span> Person.prototype.sex</span><br><span class="line">person1.sex  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="comment">// 或者可以这样，和上面的效果一样</span></span><br><span class="line"><span class="keyword">delete</span> person1.__proto__.sex</span><br></pre></td></tr></table></figure>
<p><code>delete</code> 不能删除那些<code>configurable</code>为<code>false</code>的属性，也不能删除通过变量声明或者函数声明创建的全局对象的属性。在严格模式下删除不可配置的属性会报错，非严格模式下返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype  <span class="comment">// 不能删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">this</span>.x  <span class="comment">// 不能删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">this</span>.f  <span class="comment">// 不能删除</span></span><br></pre></td></tr></table></figure>
<h2 id="二、检测属性"><a href="#二、检测属性" class="headerlink" title="二、检测属性"></a>二、检测属性</h2><p>有三种方法可以检测对象中是否含有某个属性：</p>
<ol>
<li><code>in 运算符</code>：  检测属性在自身及原型链上是否存在</li>
<li><code>hasOwnProperty()</code>：  检测属性是否为自有属性（不包括继承属性）</li>
<li><code>propertyIsEnumerable()</code>：  检测属性为自有属性切可枚举<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// in 运算符</span></span><br><span class="line"><span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> person1  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;sex&#x27;</span> <span class="keyword">in</span> person1  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty()</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">&#x27;sex&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// propertyIsEnumerable</span></span><br><span class="line">person1.propertyIsEnumerable(<span class="string">&#x27;age&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">person1.propertyIsEnumerable(<span class="string">&#x27;sex&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 定义一个不可枚举的属性college</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person1,<span class="string">&#x27;college&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="string">&#x27;wuhan&#x27;</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">person1.propertyIsEnumerable(<span class="string">&#x27;college&#x27;</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
判断一个对象中是否存在某个属性不能用<code>!=undefined</code>，因为即使这个属性不存在也会返回<code>undefined</code>。<h2 id="三、枚举属性"><a href="#三、枚举属性" class="headerlink" title="三、枚举属性"></a>三、枚举属性</h2>枚举属性即遍历对象中所有的属性包括可枚举属性与不可枚举属性。</li>
</ol>
<p>遍历可枚举属性有以下两种方法：</p>
<ol>
<li><code>for in循环</code>：  遍历对象中所有可枚举的属性，包括<strong>自有属性和继承属性</strong>。可以配合<code>hasOwnProperty()</code>方法得到自有属性。</li>
<li><code>Object.keys()</code>：  遍历对象中所有可枚举的<strong>自有属性</strong>，返回由这些属性组成的数组。</li>
</ol>
<p>遍历不可枚举的属性有一种方法：</p>
<ol>
<li><code>Object.getOwnPropertyNames()</code> 它和<code>Object.keys()</code>类似，返回对象所有自有属性的名称，<strong>包括不可枚举的属性</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person1,<span class="string">&#x27;college&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="string">&#x27;wuhan&#x27;</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// person1有三个属性，一个可枚举自有属性name，一个可枚举继承属性sex，一个不可枚举自有属性college</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可枚举的自有属性和继承属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop)   <span class="comment">// &#x27;name&#x27;,&#x27;sex&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 仅仅返回可枚举的自有属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (person1.hasOwnProperty(prop)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(prop)   <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可枚举的自有属性组成的数组</span></span><br><span class="line"><span class="built_in">Object</span>.keys(person1)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所有自有属性组成的数组，包括不可枚举的属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person1)  <span class="comment">// [&#x27;name&#x27;,&#x27;college&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>至此对象及其属性介绍完毕，下一章将讨论对象的<a href="/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/" title="原型及原型链">原型及原型链</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识JS对象（一）-- 对象及其属性</title>
    <url>/2018/12/06/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86JS%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h2><p>javascript中有三种方法可以创建一个对象：</p>
<ol>
<li><p>对象字面量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>new 构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.create()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>需要注意的是通过<code>Object.create()</code>创建的对象实际上等于将该对象的<code>__proto__</code>指向<code>Object.create()</code>里面的参数对象，而<code>obj</code>本身是个空对象。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 等价于 obj.__proto__ = &#123; name: &#x27;jack&#x27;, age: 12 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__)  <span class="comment">// &#123; name: &#x27;jack&#x27;, age: 12 &#125;</span></span><br><span class="line">obj.toString()   <span class="comment">// &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果往<code>Object.create()</code>里面传入的是<code>null</code>，则创建的对象不继承<code>Object</code>的任何方法及属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__)  <span class="comment">// undefined</span></span><br><span class="line">obj.toString()  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>如果想创建一个空对象，需要传入<code>Object.prototype</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// 和 &#123;&#125; 、new Object()一样</span></span><br></pre></td></tr></table></figure>
<h2 id="二、对象的属性"><a href="#二、对象的属性" class="headerlink" title="二、对象的属性"></a>二、对象的属性</h2><p>我们知道，对象的属性是由名字、值和一组特性组成（属性的特性待会介绍）。在ES5中属性值可以用一个或两个方法代替，这两个方法就是<code>getter</code>和<code>setter</code>。由<code>getter</code>和<code>setter</code>定义的属性称为“存储器属性”，它不同于数据类型的属性，数据属性只有一个简单的值。我们重点讲解存储器属性。</p>
<p>当我们查询存储器属性时会调用<code>getter</code>方法（无参数）。这个方法返回值就是属性存取表达式返回的值。</p>
<p>当我们设置存储器属性时会调用<code>setter</code>方法（有参数）。这个方法修改存储器属性的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    num: <span class="number">12</span>,</span><br><span class="line">    age: <span class="number">13</span>,</span><br><span class="line">    get num1 () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.num</span><br><span class="line">    &#125;,</span><br><span class="line">    set num1 (value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = value</span><br><span class="line">    &#125;,</span><br><span class="line">    get age1 () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.num1   <span class="comment">// 12</span></span><br><span class="line">obj.num1 = <span class="number">120</span></span><br><span class="line">obj.num1  <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line">obj.age1  <span class="comment">// 13</span></span><br><span class="line">obj.age1 = <span class="number">130</span></span><br><span class="line">obj.age1  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>存储器属性定义为一个或者两个和属性同名的函数，这个函数定义没有使用<code>function</code>关键字而是使用<code>get</code>和<code>set</code>。</p>
<p>可以看出如果该属性只有<code>getter</code>方法则只能读取该属性不能设置该属性，同样如果只有<code>setter</code>方法就只能设置该属性，不能读取该属性，只有当两者都有时才能正常读取和设置属性。</p>
<h2 id="三、对象属性的特性"><a href="#三、对象属性的特性" class="headerlink" title="三、对象属性的特性"></a>三、对象属性的特性</h2><p>每个对象的数据属性都有四个特性（也可以说是属性描述符），分别为：</p>
<ol>
<li><code>value</code>  属性的值</li>
<li><code>writable</code>  可写性，如果为<code>false</code>该值将不能被修改</li>
<li><code>enumerable</code>  可枚举性，如果为<code>false</code>将不能被枚举</li>
<li><code>configurable</code>  可配置性，如果为<code>false</code>将不能被配置，即不能被<code>delete</code>操作符删除，不能更改这四个特性，一旦设为<code>false</code>则无法再设为<code>true</code>，也就是一个不可逆过程</li>
</ol>
<p>前面我们讲过存储器属性，每隔对象的存储器属性同样也有四个特性，分别为：</p>
<ol>
<li><code>get</code></li>
<li><code>set</code></li>
<li><code>enumerable</code></li>
<li><code>configurable</code></li>
</ol>
<p>如果想要获得一个对象某个属性的这四个特性，可以调用 Object.getOwnPropertyDescriptor() 方法，该方法接受两个参数，第一个为对象，第二个为对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    get age1 () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age1</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">age1</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.age1 = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取数值属性的特性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &quot;jack&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取存储器属性的特性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;age1&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;enumerable: true, configurable: true, get: ƒ, set: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图获取不存在的属性，返回undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;sex&#x27;</span>)  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图获取原型上的属性，返回undefined </span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;toString&#x27;</span>)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看出，<code>Object.getOwnPropertyDescriptor()</code> 只能得到自有属性的描述符，要想获得继承属性的特性，我们可以把该对象的原型传进去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line">Person.prototype.age = <span class="number">13</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person1.__proto__, <span class="string">&#x27;sex&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &quot;boy&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上可以看出，我们通过对象字面量和<code>new</code>运算符创建的对象的属性它们的<code>writable</code>,<code>enumerable</code>,<code>configurable</code>都有<code>true</code>，默认都是可写、可枚举、可配置。如果要修改属性的特性可以调用<code>Object.defineProperty()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sillywa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将name属性设为不可枚举并将其值设为jack</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &quot;jack&quot;, writable: true, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增age属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">12</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: 12, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将name变为存储器属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;set: undefined, enumerable: false, configurable: true, get: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">obj.age = <span class="number">78</span></span><br><span class="line">obj.age  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是通过<code>Object.defineProperty()</code> 创建的属性其<code>writable</code>, <code>enumerable</code>, <code>configurable</code> 都为<code>false</code>。尝试修改不写的属性不会报错，但也不会修改，只有在严格模式下才会报错。</p>
<p>如果需要同时修改和创建多个属性，可以使用<code>Object.defineProperties()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperties(&#123;&#125;,&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">&#x27;sillywa&#x27;</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span> + <span class="built_in">this</span>.name</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="四、属性的设置和屏蔽"><a href="#四、属性的设置和屏蔽" class="headerlink" title="四、属性的设置和屏蔽"></a>四、属性的设置和屏蔽</h2><p>我们知道当我们书写以下代码时</p>
<p><code>obj.foo = &#39;bar&#39;</code></p>
<p>如果<code>obj</code>存在一个名为<code>foo</code>的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p>
<p>如果<code>foo</code>不是直接存在于obj中，<code>[[prototype]]</code>链就会被遍历，如果原型链上找不到<code>foo</code>，<code>foo</code>就直接被添加到<code>obj</code>上。</p>
<p>然而，如果原型链上找到了<code>foo</code>属性，情况就有些不一样了。</p>
<p>如果属性<code>foo</code>既出现在<code>obj</code>中也在其原型链中，那么<code>obj</code>中包含的<code>foo</code>属性就会屏蔽原型链里面的<code>foo</code>属性，这就是属性屏蔽，原理就是属性的查找规则。</p>
<p>下面我们看一下如果<code>foo</code>不直接存在于<code>obj</code>中，而是在其原型链中时，<code>obj.foo = &#39;bar&#39;</code>会出现的三种情况：</p>
<ol>
<li>如果原型链中存在名为<code>foo</code>的普通数据访问属性并且其<code>writable</code>为<code>true</code>，那么就会直接在<code>obj</code>中添加<code>foo</code>属性，它是属性屏蔽。</li>
<li>如果原型链中存在<code>foo</code>，但其<code>writabla</code>为<code>false</code>，那么无法修改已有属性或者在<code>obj</code>中创建屏蔽属性。如果运行在严格模式下，会抛出一个错误。否则这条赋值语句会被忽略，不会发生属性屏蔽。</li>
<li>如果原型链上存在<code>foo</code>并且它是一个<code>setter</code>，那就一定会调用这个<code>setter</code>。<code>foo</code>不会被添加到<code>obj</code>中，也不会重新定义这个<code>setter</code>。</li>
</ol>
<p>大多数人认为，如果向原型链中已存在的属性赋值，就一定会发生属性屏蔽，但以上三种情况只有一种是如此。</p>
<p>如果希望在任何情况下都屏蔽<code>foo</code>，那就不能使用<code>=</code>操作符来赋值，而是使用<code>Object.defineProperty()</code>来向<code>obj</code>中添加<code>foo</code>。</p>
<p>情况一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Person.prototype.foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line">obj.foo = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">obj.foo   <span class="comment">// &#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>
<p>情况二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">&#x27;foo&#x27;</span>,&#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line">obj.foo = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">obj.foo  <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>情况三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: &#x27;foo&#x27;,</span><br><span class="line">    set foo (value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = value</span><br><span class="line">    &#125;,</span><br><span class="line">    get foo () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line">obj.foo = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">obj.foo  <span class="comment">// &#x27;bar&#x27;</span></span><br><span class="line"><span class="comment">// obj中并没有foo这个属性，只是调用了setter</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>有些情况下会隐式产生屏蔽，一定要注意，思考一下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">obj.a  <span class="comment">// 2</span></span><br><span class="line">myObj.a  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">myObj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">myObj.a ++  <span class="comment">// 隐式屏蔽</span></span><br><span class="line"></span><br><span class="line">obj.a  <span class="comment">// 2</span></span><br><span class="line">myObj.a  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">myObj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>尽管<code>myObj.a ++ </code>看起来是查找并增加<code>obj.a</code>的属性，但是别忘了<code>++</code>操作符相当于<code>myObj.a = myObj.a + 1</code>；因此<code>++</code>操作首先会通过原型链查找到<code>obj.a</code>，并读取其值为2，然后加1赋值给<code>myObj.a</code>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT 高级配置</title>
    <url>/2018/12/05/topnext/</url>
    <content><![CDATA[<p>前一篇文章介绍了NexT的基本配置，其主要涉及两个配置文件第一个是主目录下的<code>_config.yml</code>，另一个是我们的主题配置文件<code>thems/next/_config.yml</code>，接下来我们继续深入。</p>
<h1 id="添加社交网址"><a href="#添加社交网址" class="headerlink" title="添加社交网址"></a>添加社交网址</h1><p>在<code>thems/next/_config.yml</code>查找 <code>social</code>，找到如下代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Social Links.</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span></span><br><span class="line"><span class="symbol">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || github</span></span><br><span class="line">  E-<span class="symbol">Mail:</span> <span class="symbol">mailto:</span>yourname@gmail.com <span class="params">||</span> envelope</span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br></pre></td></tr></table></figure>
<p>去掉 <code>social</code> 的注释并将你需要展示的信息网址注释去掉，可以修改名称和网址。</p>
<p>效果如图：</p>


<h1 id="页面底部添加访问量"><a href="#页面底部添加访问量" class="headerlink" title="页面底部添加访问量"></a>页面底部添加访问量</h1><p>在<code>thems/next/_config.yml</code>查找 <code>busuanzi</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">busuanzi_count:</span></span><br><span class="line">  <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">total_visitors_icon:</span> user</span><br><span class="line">  <span class="symbol">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">total_views_icon:</span> eye</span><br><span class="line">  <span class="symbol">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">post_views_icon:</span> eye</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>

<p>本地查看访问量可能有误，但是放到线上就没问题了。</p>
<h1 id="为文章添加评论与阅读次数"><a href="#为文章添加评论与阅读次数" class="headerlink" title="为文章添加评论与阅读次数"></a>为文章添加评论与阅读次数</h1><p>在<code>leancloud</code>上面注册帐号，新建一个应用，找到应用对应的<code>appid</code>和<code>appkey</code>，然后在<code>thems/next/_config.yml</code>查找 <code>valine</code>，将填入<code>appid</code>和<code>appkey</code>以下代码中，相应字段设为<code>true</code>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">valine:</span></span><br><span class="line">  <span class="symbol">enable:</span> <span class="literal">true</span> <span class="comment"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span></span><br><span class="line">  <span class="symbol">appid:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="symbol">appid:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="symbol">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="symbol">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="symbol">placeholder:</span> Just go go <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="symbol">avatar:</span> mm <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="symbol">guest_info:</span> nick,mail,link <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="symbol">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line">  <span class="symbol">visitor:</span> <span class="literal">true</span> <span class="comment"># leancloud-counter-security is not supported for now. </span></span><br></pre></td></tr></table></figure>

<h1 id="为页面添加搜索功能"><a href="#为页面添加搜索功能" class="headerlink" title="为页面添加搜索功能"></a>为页面添加搜索功能</h1><p>在<code>thems/next/_config.yml</code>查找 <code>local_search</code>，并将<code>enable</code>设为<code>true</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">local_search:</span></span><br><span class="line">  <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="symbol">trigger:</span> auto</span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="symbol">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># unescape html strings to the readable one</span></span><br><span class="line">  <span class="symbol">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后访问<a href="https://github.com/theme-next/hexo-generator-searchdb">注释提供的网址</a>，按它的步骤操作。</p>
<h1 id="文章分享链接"><a href="#文章分享链接" class="headerlink" title="文章分享链接"></a>文章分享链接</h1><p>在<code>thems/next/_config.yml</code>查找 <code>needmoreshare</code>，并将<code>enable</code>设为<code>true</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">needmoreshare2:</span></span><br><span class="line">  <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">postbottom:</span></span><br><span class="line">    <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="symbol">options:</span></span><br><span class="line">      <span class="symbol">iconStyle:</span> box</span><br><span class="line">      <span class="symbol">boxForm:</span> horizontal</span><br><span class="line">      <span class="symbol">position:</span> bottomCenter</span><br><span class="line">      <span class="symbol">networks:</span> Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line">  <span class="symbol">float:</span></span><br><span class="line">    <span class="symbol">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="symbol">options:</span></span><br><span class="line">      <span class="symbol">iconStyle:</span> box</span><br><span class="line">      <span class="symbol">boxForm:</span> horizontal</span><br><span class="line">      <span class="symbol">position:</span> middleRight</span><br><span class="line">      <span class="symbol">networks:</span> Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后访问<a href="https://github.com/theme-next/theme-next-needmoreshare2">注释提供的网址</a>，按它的步骤操作。</p>
<h1 id="博客页脚记时"><a href="#博客页脚记时" class="headerlink" title="博客页脚记时"></a>博客页脚记时</h1><p>打开 <code>\themes\next\layout\_partials\footer.swig</code>，在最下面添加如下代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date();</span><br><span class="line">    function createtime() &#123;</span><br><span class="line">        var grt= new Date(<span class="string">&quot;12/03/2018 00:00:00&quot;</span>);<span class="regexp">//</span>此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+<span class="number">250</span>);</span><br><span class="line">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = Math.floor(days);</span><br><span class="line">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = Math.floor(hours);</span><br><span class="line">        <span class="keyword">if</span>(String(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum);</span><br><span class="line">        mnum = Math.floor(minutes); <span class="keyword">if</span>(String(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum);</span><br><span class="line">        snum = Math.round(seconds); <span class="keyword">if</span>(String(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125;</span><br><span class="line">        document.getElementById(<span class="string">&quot;timeDate&quot;</span>).innerHTML = <span class="string">&quot;Running for &quot;</span>+dnum+<span class="string">&quot; Days &quot;</span>;</span><br><span class="line">        document.getElementById(<span class="string">&quot;times&quot;</span>).innerHTML = hnum + <span class="string">&quot; Hours &quot;</span> + mnum + <span class="string">&quot; m &quot;</span> + snum + <span class="string">&quot; s&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setInterval(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>并将以下代码放在这个文件你喜欢的位置，然后查看效果。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span id=<span class="string">&quot;timeDate&quot;</span>&gt;&lt;<span class="regexp">/span&gt;&lt;span id=&quot;times&quot;&gt;&lt;/span</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>NexT</code>高级配置就介绍这么多，至此，我们已搭建出一个比较完整的博客，然后接下来就可以快乐的写博客啦！</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 及 NexT 基本配置与使用</title>
    <url>/2018/12/05/usehexo/</url>
    <content><![CDATA[<p>前一篇文章介绍了如何搭建博客，但是没有介绍如何使用和个性化配置博客。因此这篇文章主要来介绍<code>Hexo</code>的主题及其配置以及如何来写自己的博客。</p>
<h1 id="主题下载与应用"><a href="#主题下载与应用" class="headerlink" title="主题下载与应用"></a>主题下载与应用</h1><p><code>Hexo</code>提供各种各样的主题，我们可以进入<a href="https://hexo.io/themes/">官网</a>去选择自己喜欢的主题，然后在<code>GitHub</code>上有其具体的介绍。</p>
<p>接下来我们以<a href="https://github.com/theme-next/hexo-theme-next">NexT</a>主题为例进行介绍。</p>
<p>截至目前为止，<code>NexT</code>主题已经从v5.1.x更新至<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">v6.6.0</a>，仓库也从原来的老仓库迁移到<a href="https://github.com/theme-next/hexo-theme-next">这里</a>。因此<code>NexT</code>主题的很多配置都和以前不一样了，我当时在网上看的时候全是老版本的配置方法，花费了不少时间。最后发现其实可以自己看着<code>themes</code>下的<code>_config.yml</code>进行配置，很多插件都在<a href="https://github.com/theme-next">theme-next</a>这个仓库有。</p>
<h2 id="下载-NexT"><a href="#下载-NexT" class="headerlink" title="下载 NexT"></a>下载 NexT</h2><p>切换到主目录，然后克隆整个仓库到<code>themes/next</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>之后我们会发现 <code>themes</code>下多了个<code>next</code>文件夹，即我们的主题文件夹。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>整个 <code>Hexo</code> 博客有两个主要的配置文件，第一个是主目录下的<code>_config.yml</code>，另一个是我们的主题配置文件，是<code>thems/next/_config.yml</code>。</p>
<p>现在我们开始将我们下载的主题应用到我们的博客中，我们只需修改主目录下的<code>_config.yml</code>，如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">theme:</span> <span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>然后<code>hexo s</code>启动博客即可。<br><strong>需要注意的是：每当我们修改了主目录下的<code>_config.yml</code>，只有重启博客服务才能生效；而修改<code>thems/next/_config.yml</code>是不需要重启博客服务的。</strong></p>
<p>同样我们可以在主目录下的<code>_config.yml</code>进行其他设置，我们可以看到里面有网站基本设置，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hexo           </span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">author: John Doe</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>网站标题</td>
</tr>
<tr>
<td>subtitle</td>
<td>网站副标题</td>
</tr>
<tr>
<td>description</td>
<td>网站描述</td>
</tr>
<tr>
<td>author</td>
<td>作者名字</td>
</tr>
<tr>
<td>language</td>
<td>网站语言，NexT v6.0.3以后中文设为 zh-CN</td>
</tr>
</tbody></table>
<p>具体全部配置参考<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a>。</p>
<p>我们暂时不需要全部理解其意思，只要把网站的基本描述改为你自己的就好。</p>
<h1 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h1><h2 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h2><p><code>Scheme</code> 的切换通过更改主题配置文件，打开<code>thems/next/_config.yml</code>，搜索 scheme 关键字。 你会看到有三行 <code>scheme</code> 的配置，将你需用启用的 <code>scheme</code> 前面注释 <code>#</code> 去除即可。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="symbol">scheme:</span> Muse</span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。<br>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白<br>Mist - Muse 的紧凑版本，整洁有序的单栏外观<br>Pisces - 双栏 Scheme，小家碧玉似的清新</p>
</blockquote>
<p>选择对应的外观，刷新浏览器即可预览。</p>
<h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><p>打开<code>thems/next/_config.yml</code>，找到如下代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line">  <span class="symbol">home:</span> / <span class="params">||</span> home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="symbol">archives:</span> /archives/ <span class="params">||</span> archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<p>这里是进行菜单配置，去掉哪个注释，就会多一个相应的菜单选项。</p>
<p>当需要<code>about</code>、<code>tags</code>、<code>categories</code> 需要手动创建这个页面，如果不创建点击则不会出现相应页面。</p>
<p>使用如下命令创建这些文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>之后<code>source</code>文件夹下就会出现三个这样的文件夹。</p>
<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>打开<code>thems/next/_config.yml</code>，找到如下代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">avatar:</span></span><br><span class="line">  <span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># You can also use other linking images.</span></span><br><span class="line">  <span class="symbol">url:</span> <span class="comment">#/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line">  <span class="symbol">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span></span><br><span class="line">  <span class="symbol">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line">  <span class="symbol">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>修改字段 <code>avatar</code>， 值设置成头像的链接地址，参考<a href="http://theme-next.iissnan.com/getting-started.html#avatar-setting">这个链接</a>。</p>
<p>以上主题设置可以参考<a href="http://theme-next.iissnan.com/">Next文档</a>。</p>
<h2 id="tags-和-categories-设置"><a href="#tags-和-categories-设置" class="headerlink" title="tags 和 categories 设置"></a>tags 和 categories 设置</h2><p>当菜单中有了 <code>tags</code> 和 <code>categories</code> 时，我们需要在 <code>Front-matter</code> 中添加 <code>type</code> 属性。所谓 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a> 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量。</p>
<p><code>tags/index.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-12-05 10:00:29</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>categories/index.md</code> 同理。</p>
<p>只有这样当我们新建一篇博客时，指定的<code>tags</code>和<code>categories</code>才会同步，<code>hexo</code>才会识别出来你的 <code>tags</code> 和 <code>categories</code>。所以接下来我们看如何新建一篇博客。</p>
<h1 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h1><p>新建博客很简单，使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章题目&quot;</span><br></pre></td></tr></table></figure>
<p>这样就会在<code>source</code>目录下自动创建一个名为 <code>文章题目.md</code> 的文件，我们只要在这个文件上写文章就行了。同样我们需要每篇文章指定一个或多个 <code>tags</code> 和 一个 <code>categories</code>。这样你的菜单中<code>tags</code> 页面 和<code>categories</code>页面就会有内容了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章题目</span><br><span class="line">date: 2018-12-05 15:42:22</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这样整个 <code>NexT</code> 基本配置就结束了，之后将会介绍一些<a href="/2018/12/05/topnext/" title="更高级的配置">更高级的配置</a>。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo and GitHub Pages 博客搭建</title>
    <url>/2018/12/05/hexo/</url>
    <content><![CDATA[<p>最近没事想着自己来搭建一个博客，在网上看了一些资料发现，<code>Hexo + GitHub</code> 是目前比较常用的博客搭建系统，因此就照着网上的教程一步一步，历经一天左右的时间搭建了这个个人博客。</p>
<p>想着用博客来记录自己的学习笔记，希望自己能把写博客这个习惯坚持下来。</p>
<p>ok，接下来就来看看我是怎么一步步搭建这个博客的。</p>
<h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><h2 id="了解-Hexo"><a href="#了解-Hexo" class="headerlink" title="了解 Hexo"></a>了解 Hexo</h2><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>在安装<code>Hexo</code>之前我们需要知道电脑里有没有下面的应用程序，如果没有，点击安装，具体安装方法就不做介绍了；如果有则直接看下一步。</p>
<ul>
<li><a href="https://nodejs.org/en/">Node.js</a></li>
<li><a href="https://git-scm.com/">Git</a></li>
</ul>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>以上两个程序安装成功之后，接下来使用 <code>npm</code> 安装 <code>Hexo</code>，如果 <code>npm</code> 安装较慢，可考虑使用淘宝镜像 <a href="https://npm.taobao.org/">cnpm</a>，安装完 <code>cnpm</code> 之后可将下面所有用到 <code>npm</code> 的地方换为<code>cnpm</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>输入以下命令检查 <code>Hexo</code> 是否安装成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo --version</span><br></pre></td></tr></table></figure>
<p>如果有版本信息则安装 <code>Hexo</code> 成功。</p>
<h1 id="开始搭建博客"><a href="#开始搭建博客" class="headerlink" title="开始搭建博客"></a>开始搭建博客</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>Hexo</code>安装完成之后，用以下命令新建一个文件夹并初始化 <code>Hexo</code> 所需文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder_name&gt;</span><br><span class="line">cd folder_name</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p><code>hexo init</code>过程可能会较慢，请耐心等待。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>以上过程结束之后，用如下命令在本地运行我们的博客。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><code>hexo server</code> 可以简写为 <code>hexo s</code>。</p>
<p>接着我们用浏览器打开 <code>localhost:4000</code> 即可看到我们搭建的博客。</p>
<h1 id="将博客放入GitHub"><a href="#将博客放入GitHub" class="headerlink" title="将博客放入GitHub"></a>将博客放入GitHub</h1><p>博客搭建好之后，我们在 <code>GitHub</code> 新建一个仓库，可以命名为 <code>your_blog_name.github.io</code> ，以后就可以直接通过<code>your_blog_name.github.io</code>访问你的博客了。</p>
<p><strong>请务必将仓库名设为xxx.github.io xxx为你自定义，否则之后会出现很多问题</strong></p>
<p>新建好之后，在你的博客目录下，即前面提到的 <code>folder_name</code>下，使用如下命令关联<code>GitHub</code>仓库。</p>
<p>如果是第一次使用<code>GitHub</code>或者是没有配置 <code>ssh</code> 可能会要求输入帐号密码 ，最好的解决办法是<a href="https://segmentfault.com/a/1190000002645623">配置ssh</a>，然后再进行以下操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure>

<p>接着打开主目录（folder_name）下的 <code>_config.yml</code>配置文件，找到 <code>deploy</code>，进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: &lt;远程仓库地址&gt;</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<p>然后安装以下插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后执行以下命令生成静态文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>可简写为 <code>hexo g</code></p>
<p>最后将文件上传到<code>GitHub</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>可简写为 <code>hexo d</code></p>
<h1 id="开启Pages服务"><a href="#开启Pages服务" class="headerlink" title="开启Pages服务"></a>开启Pages服务</h1><p><code>GitHub</code>上找到我们的仓库，点击右边的<code>Settings</code>：</p>

<p>下滑找到 <code>GitHub Pages</code> ，点击 <code>master branch</code>，点击 <code>save</code>，即可开启<code>Pages</code>服务。</p>


<p>点击<code>GitHub Pages</code>旁边给出的链接即可访问你的博客了。</p>
<p>这样你的博客基本上就搭建成功了，下一篇我们介绍<a href="/2018/12/05/usehexo/" title="如何配置和使用Hexo">如何配置和使用Hexo</a>。</p>
<p>大家也可以参考<a href="https://hexo.io/zh-cn/">Hexo官网</a>。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
